<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Ink Colour Matcher + Predictor</title>
  <style>
    :root { --gap: 12px; --radius: 14px; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin:0; padding:24px; background:#0b0c10; color:#e6e6e6; }
    h1 { font-size: 1.25rem; margin: 0 0 8px; }
    .app { max-width: 1200px; margin: 0 auto; display: grid; gap: var(--gap); grid-template-columns: 420px 1fr; align-items: start; }
    .card { background:#111318; border:1px solid #22252e; border-radius: var(--radius); padding:16px; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    label { display:block; font-size:.85rem; color:#98a2b3; margin-bottom:6px; }
    input, select { width:100%; padding:10px 12px; border-radius:10px; outline:none; background:#0e1015; border:1px solid #2a2f3a; color:#e6e6e6; }
    input::placeholder { color:#7b8496; }
    .row { display:grid; grid-template-columns:1fr 1fr 1fr; gap:var(--gap); }
    .row2 { display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); }
    .btn { cursor:pointer; padding:10px 12px; border-radius:10px; border:1px solid #2a2f3a; background:#141824; color:#e6e6e6; font-weight:600; }
    .btn:hover { filter:brightness(1.1); }
    table { width:100%; border-collapse:collapse; }
    th, td { text-align:left; padding:10px; border-bottom:1px dashed #242938; font-variant-numeric: tabular-nums; }
    th { color:#9aa4b2; font-weight:600; }
    .result-row { transition: background .2s; cursor:pointer; }
    .result-row:hover { background: rgba(255,255,255,.05); }
    .swatch { width:3.1rem; height:2.1rem; border-radius:6px; border:1px solid rgba(255,255,255,.2); }
    .pill { font-size:.8rem; color:#98a2b3; }
    .muted { color:#7b8496; font-size:.85rem; }
    .formula-box { background:#0e1015; border:1px solid #2a2f3a; border-radius:10px; padding:12px; margin-top:16px; }
    .formula-box h2 { margin:0 0 8px; font-size:1rem; color:#ccc; }
    .formula-box ul { margin:0; padding-left:18px; }
    .stack { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .flex { display:flex; gap:8px; }
    @media (max-width: 900px) { .app { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="app">
    <!-- Left Column: Target + Controls -->
    <div class="card">
      <div class="top" style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap: wrap;">
        <h1>Ink Colour Matcher</h1>
        <div class="pill">
          <span id="countLabel">0</span> reference colours
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <div><label for="L">L*</label><input id="L" type="number" step="0.01" placeholder="e.g. 52.30"></div>
        <div><label for="a">a*</label><input id="a" type="number" step="0.01" placeholder="e.g. 12.80"></div>
        <div><label for="b">b*</label><input id="b" type="number" step="0.01" placeholder="e.g. -4.10"></div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="pms">Search by PMS (number only)</label>
          <input id="pms" type="text" placeholder="e.g. 186 or 3005"/>
        </div>
        <div style="align-self:end;">
          <button class="btn" id="pmsBtn">Find PMS</button>
        </div>
      </div>

      <div class="flex" style="margin-top:12px;">
        <button class="btn" id="findBtn">Find Closest</button>
        <button class="btn" id="clearBtn">Clear</button>
      </div>

      <div class="formula-box" style="margin-top:12px;">
        <h2>What does “Distance” mean?</h2>
        <p class="muted">Distance = <strong>ΔE00 (CIEDE2000)</strong> computed in the same reference space used for the dataset. k<sub>L</sub>=k<sub>C</sub>=k<sub>H</sub>=1.</p>
      </div>

      <!-- Predictor Controls -->
      <div class="formula-box" id="predictorBox">
        <h2>Suggest Formula (uses both backings)</h2>
        <div class="row2" style="margin-bottom:8px;">
          <div>
            <label for="maxInks">Max inks in recipe</label>
            <input id="maxInks" type="number" min="2" max="8" step="1" value="5"/>
          </div>
          <div class="muted" style="align-self:end;">Basis combines over‑white and over‑black responses.</div>
        </div>
        <div class="flex">
          <button class="btn" id="suggestBtn">Suggest Formula</button>
          <div id="predictMsg" class="muted" style="align-self:center;"></div>
        </div>
        <div id="suggestedFormula" class="formula-box" style="display:none;"></div>
      </div>

    </div>

    <!-- Right Column: Results -->
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;">
        <h1>Closest Matches</h1>
        <div class="stack" style="align-items:center;">
          <div class="swatch" id="targetSwatch" title="Target"></div>
          <div class="muted" id="targetEcho">Target: –</div>
        </div>
      </div>
      <table>
        <thead>
          <tr>
            <th>Colour</th>
            <th>Swatch</th>
            <th>L*</th>
            <th>a*</th>
            <th>b*</th>
            <th>Distance</th>
          </tr>
        </thead>
        <tbody id="resultsTbody"></tbody>
      </table>
      <div id="formulaPanel" class="formula-box" style="display:none;"></div>
    </div>
  </div>

<script>
// ===== Utilities =====
const $ = sel => document.querySelector(sel);
const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));

// Bradford D50 -> D65 (for sRGB display; math stays D50)
function d50ToD65([X,Y,Z]){
  // Simple 3x3 Bradford matrix from D50 to D65
  const M = [
    [ 0.9555766, -0.0230393, 0.0631636],
    [-0.0282895,  1.0099416, 0.0210077],
    [ 0.0122982, -0.0204830, 1.3299098]
  ];
  return [
    M[0][0]*X + M[0][1]*Y + M[0][2]*Z,
    M[1][0]*X + M[1][1]*Y + M[1][2]*Z,
    M[2][0]*X + M[2][1]*Y + M[2][2]*Z
  ];
}

function labToXyz(L,a,b){
  // D50 reference white (2°)
  const Yn=1, Xn=0.96422, Zn=0.82521;
  const fy=(L+16)/116;
  const fx=f=>f>0.206893?f*f*f:(f-16/116)/7.787;
  return { X: fx((a/500)+fy)*Xn, Y: fx(fy)*Yn, Z: fx(fy-(b/200))*Zn };
}
function xyzToLab(X,Y,Z){
  // D50 reference white (2°)
  const Xn=0.96422, Yn=1, Zn=0.82521;
  const f=t=>t>0.008856?Math.cbrt(t):(7.787*t+16/116);
  const L = 116*f(Y/Yn)-16;
  const a = 500*(f(X/Xn)-f(Y/Yn));
  const b = 200*(f(Y/Yn)-f(Z/Zn));
  return {L,a,b};
}
function labToSrgb(L,a,b){
  // Lab (D50) -> XYZ (D50)
  const {X,Y,Z} = labToXyz(L,a,b);
  // Adapt to D65 for sRGB display
  const [Xd, Yd, Zd] = d50ToD65([X,Y,Z]);
  // XYZ (D65) -> linear sRGB
  let r =  3.2406*Xd -1.5372*Yd -0.4986*Zd;
  let g = -0.9689*Xd +1.8758*Yd +0.0415*Zd;
  let b2=  0.0557*Xd -0.2040*Yd +1.0570*Zd;
  const lin=[r,g,b2].map(v=>v<=0.0031308?12.92*v:1.055*Math.pow(v,1/2.4)-0.055);
  r=clamp(Math.round(lin[0]*255),0,255);
  g=clamp(Math.round(lin[1]*255),0,255);
  b2=clamp(Math.round(lin[2]*255),0,255);
  return {r,g,b:b2};
}

// ΔE2000 (kL=kC=kH=1)
function deltaE2000(l1,l2){
  const L1=l1.L,a1=l1.a,b1=l1.b, L2=l2.L,a2=l2.a,b2=l2.b;
  const deg2rad=Math.PI/180;
  const avgLp=(L1+L2)/2;
  const C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2), avgC=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2;
  const C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2), avgCp=(C1p+C2p)/2;
  const hp=(x,y)=>{const h=Math.atan2(y,x)*180/Math.PI; return (h>=0?h:h+360)};
  const h1p=hp(a1p,b1), h2p=hp(a2p,b2);
  let avgHp = Math.abs(h1p-h2p)>180 ? (h1p+h2p+360)/2 : (h1p+h2p)/2;
  const T = 1 - 0.17*Math.cos((avgHp-30)*deg2rad) + 0.24*Math.cos((2*avgHp)*deg2rad)
            + 0.32*Math.cos((3*avgHp+6)*deg2rad) - 0.20*Math.cos((4*avgHp-63)*deg2rad);
  let dHp = h2p - h1p; if (dHp>180) dHp-=360; if (dHp<-180) dHp+=360;
  const dLp = L2 - L1;
  const dCp = C2p - C1p;
  const dHp_rad = 2*Math.sqrt(C1p*C2p)*Math.sin((dHp*deg2rad)/2);
  const Sl = 1 + (0.015*Math.pow(avgLp-50,2))/Math.sqrt(20 + Math.pow(avgLp-50,2));
  const Sc = 1 + 0.045*avgCp;
  const Sh = 1 + 0.015*avgCp*T;
  const Rt = -2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7)))
            * Math.sin( (60*Math.exp(-Math.pow((avgHp-275)/25,2))) * deg2rad );
  return Math.sqrt(Math.pow(dLp/Sl,2) + Math.pow(dCp/Sc,2) + Math.pow(dHp_rad/Sh,2) + Rt*(dCp/Sc)*(dHp_rad/Sh));
}

// ===== State =====
let COLOURS = [];// from colours.json
let FORMULAS = {};// from DC_Formulas.json (can be workbook-style)
let ASSORTMENT = {};// from assortment_colour_data.json { ink: {white:[{conc,L,a,b}], black:[...]}}

// Name & PMS helpers
function normaliseName(s){ return String(s||'').trim().toUpperCase().replace(/\s+/g,' '); }
function extractPmsNumber(name){
  if(!name) return null; const m = String(name).toUpperCase().match(/PANTONE\s*([0-9A-Z]+(?:[\- ]?[0-9A-Z]+)*)/);
  return m? m[1].replace(/\s+/g,'').replace(/^\-/,''): null;
}

let FORMULAS_NORM = {};
let COLOUR_TO_FORMULA = {};
function buildFormulaIndex(){
  const rows = [];
  FORMULAS_NORM = {};
  COLOUR_TO_FORMULA = {};
  // Flatten workbook-style DC_Formulas
  if (Array.isArray(FORMULAS)) {
    rows.push(...FORMULAS);
  } else if (FORMULAS && typeof FORMULAS === 'object') {
    for (const k of Object.keys(FORMULAS)) {
      if (Array.isArray(FORMULAS[k])) rows.push(...FORMULAS[k]);
      else if (FORMULAS[k] && typeof FORMULAS[k] === 'object' && Array.isArray(FORMULAS[k].rows)) {
        rows.push(...FORMULAS[k].rows);
      }
    }
  }
  // Build per-colour arrays of inks
  const byColour = new Map();
  rows.forEach(r => {
    const cname = r.Colour || r.colour || r.Color || r.color || r.NAME || r.Name;
    if (!cname) return;
    const items = [];
    for (let i = 1; i <= 12; i++) {
      const ink = r[`Ingredient ${i}`] || r[`Ink ${i}`] || r[`INGREDIENT ${i}`] || r[`ingredient ${i}`];
      if (!ink) continue;
      let pct = r[`%${i}`] || r[`${i}%`] || r[`% ${i}`] || r[`Percent ${i}`] || r[`Percent${i}`] || r['%'] || '';
      items.push({ ink, percent: pct });
    }
    const arr = byColour.get(cname) || [];
    arr.push(...items);
    byColour.set(cname, arr);
    FORMULAS_NORM[normaliseName(cname)] = arr;
  });
  // Pre-bind colour names to best formula key
  (COLOURS || []).forEach(c => {
    const name = c.name || c.Colour || c.color || '';
    const norm = normaliseName(name);
    if (byColour.has(name)) { COLOUR_TO_FORMULA[name] = norm; return; }
    if (FORMULAS_NORM[norm]) { COLOUR_TO_FORMULA[name] = norm; return; }
    const p = extractPmsNumber(name);
    if (p) {
      for (const key of byColour.keys()){
        if ((extractPmsNumber(key)||'') === p) { COLOUR_TO_FORMULA[name] = normaliseName(key); break; }
      }
    }
  });
}

// ===== UI helpers =====
function updateTargetEcho(){
  const L=parseFloat($('#L').value), a=parseFloat($('#a').value), b=parseFloat($('#b').value);
  if([L,a,b].some(v=>Number.isNaN(v))){ $('#targetEcho').textContent = 'Target: –'; $('#targetSwatch').style.background = '#0000'; return; }
  $('#targetEcho').textContent = `Target: L ${L.toFixed(2)} a ${a.toFixed(2)} b ${b.toFixed(2)}`;
  const rgb = labToSrgb(L,a,b); $('#targetSwatch').style.background = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
}

// ===== Matching =====
function getTargetLab(){
  const L=parseFloat($('#L').value), a=parseFloat($('#a').value), b=parseFloat($('#b').value);
  if([L,a,b].some(v=>Number.isNaN(v))) return null; return {L,a,b};
}
function findClosest(){
  const target = getTargetLab(); if(!target){ alert('Enter a valid colour first.'); return; }
  const rows = COLOURS.map(c=>({
    raw: c,
    name: c.name || c.Colour || c.color || '—',
    L:c.L, a:c.a, b:c.b,
    de: deltaE2000({L:c.L,a:c.a,b:c.b}, target)
  })).sort((a,b)=>a.de-b.de).slice(0,100);

  const tbody = $('#resultsTbody'); tbody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr'); tr.className='result-row';
    const rgb=labToSrgb(r.L,r.a,r.b);
    tr.innerHTML = `
      <td>${r.name}</td>
      <td><div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div></td>
      <td>${r.L.toFixed(2)}</td>
      <td>${r.a.toFixed(2)}</td>
      <td>${r.b.toFixed(2)}</td>
      <td>${r.de.toFixed(2)}</td>`;
    tr.addEventListener('click', ()=> showFormulaFor(r.name));
    tbody.appendChild(tr);
  });
}

function showFormulaFor(colourName){
  const panel = $('#formulaPanel');
  let list = null;
  const bound = COLOUR_TO_FORMULA[colourName];
  if(bound) list = FORMULAS_NORM[bound];
  if(!list) list = FORMULAS_NORM[normaliseName(colourName)];
  if(!list){
    const want = extractPmsNumber(colourName);
    if(want){
      for (const key in FORMULAS_NORM){
        if ((extractPmsNumber(key)||'') === want){ list = FORMULAS_NORM[key]; break; }
      }
    }
  }
  if(!list || !list.length){ panel.style.display='none'; return; }
  let html = `<h2>Existing Formula: ${colourName}</h2><ul>`;
  list.forEach(item=>{ html += `<li>${item.ink || item.Ink || 'Ink'}${item.percent!==''?` — ${item.percent}%`:''}</li>`; });
  html += '</ul>';
  panel.innerHTML = html; panel.style.display='block';
}

// ===== PMS Search =====
function findByPms(){
  const qRaw = ($('#pms').value||'').trim().toUpperCase(); if(!qRaw){ alert('Enter a PMS number'); return; }
  const q = qRaw.replace(/^PANTONE\s*/,'');
  const hits = COLOURS.filter(c=>{
    const p = extractPmsNumber(c.name||c.Colour||c.color||'');
    return p && p.includes(q);
  });
  const tbody = $('#resultsTbody'); tbody.innerHTML='';
  if(!hits.length){ alert('No PMS match found'); return; }
  hits.slice(0,100).forEach(c=>{
    const rgb=labToSrgb(c.L,c.a,c.b);
    const tr=document.createElement('tr'); tr.className='result-row';
    tr.innerHTML = `
      <td>${c.name||c.Colour||c.color||'—'}</td>
      <td><div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div></td>
      <td>${(+c.L).toFixed(2)}</td>
      <td>${(+c.a).toFixed(2)}</td>
      <td>${(+c.b).toFixed(2)}</td>
      <td>—</td>`;
    tr.addEventListener('click', ()=>{ $('#L').value=c.L; $('#a').value=c.a; $('#b').value=c.b; updateTargetEcho(); showFormulaFor(c.name||c.Colour||c.color||''); });
    tbody.appendChild(tr);
  });
  const c = hits[0]; $('#L').value = c.L; $('#a').value=c.a; $('#b').value=c.b; updateTargetEcho();
}

// ===== Predictor =====
function buildCombinedBasis(){
  // Use all measured concentrations; average white/black twins at each conc
  const basis = []; // {name, ink, conc, vec:[X,Y,Z], scale}
  for (const ink of Object.keys(ASSORTMENT)){
    const W = (ASSORTMENT[ink].white||[]);
    const B = (ASSORTMENT[ink].black||[]);
    const concSet = new Set([...W.map(x=>x.conc), ...B.map(x=>x.conc)]);
    Array.from(concSet).sort((a,b)=>a-b).forEach(conc=>{
      const w = W.find(x=>x.conc===conc) || null;
      const b = B.find(x=>x.conc===conc) || null;
      if(!w && !b) return;
      const xw = w? labToXyz(w.L,w.a,w.b) : null;
      const xb = b? labToXyz(b.L,b.a,b.b) : null;
      let X,Y,Z;
      if(xw && xb){ X=(xw.X+xb.X)/2; Y=(xw.Y+xb.Y)/2; Z=(xw.Z+xb.Z)/2; }
      else if(xw){ X=xw.X; Y=xw.Y; Z=xw.Z; }
      else { X=xb.X; Y=xb.Y; Z=xb.Z; }
      const norm = Math.max(1e-9, Math.hypot(X,Y,Z));
      basis.push({ name: `${ink}@${conc}%`, ink, conc, vec:[X/norm, Y/norm, Z/norm], scale:norm });
    });
  }
  return basis;
}
function nnlsProject(A, y, iters=1600){
  const m=A.length, n=A[0].length;
  let w = new Array(n).fill(1/n);
  const AT = Array.from({length:n},(_,j)=>A.map(row=>row[j]));
  const ATy = new Array(n).fill(0);
  for(let j=0;j<n;j++){ let s=0; for(let i=0;i<m;i++) s += AT[j][i]*y[i]; ATy[j]=s; }
  const ATA = Array.from({length:n},()=>new Array(n).fill(0));
  for(let i=0;i<n;i++) for(let j=0;j<n;j++){ let s=0; for(let k=0;k<m;k++) s+= AT[i][k]*A[k][j]; ATA[i][j]=s; }
  for(let it=0; it<iters; it++){
    const ATAw = new Array(n).fill(0);
    for(let i=0;i<n;i++){ let s=0; for(let j=0;j<n;j++) s += ATA[i][j]*w[j]; ATAw[i]=s; }
    for(let j=0;j<n;j++){
      const denom = Math.max(1e-9, ATAw[j]);
      w[j] = Math.max(0, w[j] * (ATy[j]/denom));
    }
    let sum = w.reduce((a,b)=>a+b,0); if(sum>0){ for(let j=0;j<n;j++) w[j]/=sum; } else { w.fill(1/n); }
  }
  return w;
}
function suggestFormula(){
  const targetLab = getTargetLab(); if(!targetLab){ alert('Enter a valid colour first.'); return; }
  const basis = buildCombinedBasis(); if(basis.length===0){ alert('No basis inks available'); return; }
  const maxInks = clamp(parseInt($('#maxInks').value||'5',10),2,8);
  const tXYZ = labToXyz(targetLab.L, targetLab.a, targetLab.b);
  const tNorm = Math.max(1e-9, Math.hypot(tXYZ.X,tXYZ.Y,tXYZ.Z));
  const y=[tXYZ.X/tNorm, tXYZ.Y/tNorm, tXYZ.Z/tNorm];
  const A=[[],[],[]]; basis.forEach(b=>{ A[0].push(b.vec[0]); A[1].push(b.vec[1]); A[2].push(b.vec[2]); });
  let w = nnlsProject(A, y, 1600);
  const withIdx = w.map((val,idx)=>({val, idx})).filter(o=>o.val>1e-6).sort((a,b)=>b.val-a.val).slice(0, Math.min(maxInks*2, w.length));
  const byInk = new Map();
  withIdx.forEach(k=>{ const col = basis[k.idx]; byInk.set(col.ink, (byInk.get(col.ink)||0) + k.val); });
  const merged = Array.from(byInk.entries()).map(([ink,weight])=>({ink, weight})).sort((a,b)=>b.weight-a.weight).slice(0, maxInks);
  const sumw = merged.reduce((a,b)=>a+b.weight,0)||1; merged.forEach(p=> p.weight = p.weight/sumw);

  const mix=[0,0,0];
  merged.forEach(p=>{
    const cols = basis.filter(b=>b.ink===p.ink);
    let X=0,Y=0,Z=0, t=0;
    cols.forEach(c=>{ const mag=c.scale; X+=c.vec[0]*mag; Y+=c.vec[1]*mag; Z+=c.vec[2]*mag; t++; });
    if(t>0){ X/=t; Y/=t; Z/=t; }
    mix[0]+= p.weight*X; mix[1]+=p.weight*Y; mix[2]+=p.weight*Z;
  });
  const mixLab = xyzToLab(mix[0], mix[1], mix[2]);
  const dE = deltaE2000(mixLab, targetLab);
  const rgb = labToSrgb(mixLab.L, mixLab.a, mixLab.b);

  let html = `<h2>Suggested Formula</h2>`;
  html += `<div class="stack" style="align-items:center;">
    <div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div>
    <div class="muted">Predicted: L ${mixLab.L.toFixed(2)} a ${mixLab.a.toFixed(2)} b ${mixLab.b.toFixed(2)} · ΔE00: <strong>${dE.toFixed(2)}</strong></div>
  </div>`;
  html += `<ul>` + merged.map(p=>`<li>${p.ink} — ${(p.weight*100).toFixed(1)}%</li>`).join('') + `</ul>`;
  html += `<div class="muted">Dual-backing basis across concentrations, column-normalised + multiplicative NNLS (Lab/XYZ in D50). For tighter fit, next step is opacity-aware compositing.</div>`;
  const box = $('#suggestedFormula'); box.innerHTML = html; box.style.display='block';
}

// ===== Wire up =====
$('#findBtn').addEventListener('click', findClosest);
$('#clearBtn').addEventListener('click', ()=>{
  $('#L').value=''; $('#a').value=''; $('#b').value=''; updateTargetEcho();
  $('#resultsTbody').innerHTML=''; $('#formulaPanel').style.display='none';
  $('#suggestedFormula').style.display='none';
});
$('#suggestBtn').addEventListener('click', suggestFormula);
$('#pmsBtn').addEventListener('click', findByPms);
['L','a','b'].forEach(id=> $('#'+id).addEventListener('input', updateTargetEcho));

// ===== Load JSON =====
Promise.all([
  fetch('colours.json').then(r=>r.json()),
  fetch('DC_Formulas.json').then(r=>r.json()),
  fetch('assortment_colour_data.json').then(r=>r.json())
]).then(([colours, formulas, assortment])=>{
  COLOURS = colours; FORMULAS = formulas; ASSORTMENT = assortment;
  buildFormulaIndex();
  $('#countLabel').textContent = COLOURS.length;
}).catch(err=>{ alert('Error loading JSON: '+err); });

updateTargetEcho();
</script>
</body>
</html>
