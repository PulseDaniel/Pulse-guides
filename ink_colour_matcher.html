<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Lab (D50/2°) Colour Matcher — ΔE00</title>
	<style>
		:root { --fg:#111; --bg:#fff; --muted:#666; --chip-bd:#ccc; --ok:#0a7; --warn:#e79f00; --bad:#c33; }
		html,body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,sans-serif; color:var(--fg); background:var(--bg); }
		header { padding:16px 20px; border-bottom:1px solid #eee; }
		h1 { font-size:18px; margin:0 0 6px; }
		.small { color:var(--muted); font-size:13px; }
		main { padding:16px 20px 28px; max-width:1100px; }
		.panel { display:grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap:12px; align-items:end; }
		label { display:flex; flex-direction:column; gap:6px; font-size:13px; color:#333; }
		input[type="number"] { font:inherit; padding:8px; border:1px solid #ddd; border-radius:8px; width:100%; }
		button { padding:10px 14px; border:0; border-radius:10px; background:#111; color:#fff; cursor:pointer; font-weight:600; }
		button:disabled { opacity:.6; cursor:not-allowed; }
		.chips { display:flex; gap:16px; align-items:center; margin:14px 0 0; flex-wrap:wrap; }
		.chip { width:64px; height:36px; border:1px solid var(--chip-bd); border-radius:8px; background:#fff; }
		.kv { font-size:13px; color:var(--muted); }
		.results { margin-top:18px; border-top:1px solid #eee; }
		table { width:100%; border-collapse:collapse; font-size:14px; }
		th, td { padding:10px 8px; border-bottom:1px solid #f0f0f0; text-align:left; }
		th { position:sticky; top:0; background:#fafafa; z-index:1; }
		td .sw { width:42px; height:22px; border:1px solid var(--chip-bd); border-radius:6px; display:inline-block; vertical-align:middle; margin-right:8px; }
		.badge { display:inline-block; padding:2px 6px; border-radius:999px; font-size:12px; font-weight:600; }
		.badge.ok { background:#e7faf4; color:var(--ok); }
		.badge.warn { background:#fff5e5; color:var(--warn); }
		.badge.bad { background:#ffecee; color:var(--bad); }
		tfoot td { color:var(--muted); font-size:12px; padding-top:14px; }
		footer { padding:14px 20px 28px; color:var(--muted); font-size:12px; }
		.flex { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
		.code { font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,"Roboto Mono","Courier New",monospace; font-size:12px; background:#f7f7f7; padding:2px 6px; border-radius:6px; }
	</style>
</head>
<body>
<header>
	<h1>Colour Matcher (Lab D50/2° • ΔE00)</h1>
	<div class="small">Illuminant: <b>D50</b> • Observer: <b>2°</b> • Distance: <b>CIEDE2000</b> (k<sub>L</sub>=k<sub>C</sub>=k<sub>H</sub>=1). On-screen chips use D50→D65 Bradford → sRGB for display only.</div>
</header>

<main>
	<section class="panel" id="controls">
		<label> L*
			<input id="L" type="number" step="0.01" min="0" max="100" placeholder="e.g. 50.12">
		</label>
		<label> a*
			<input id="a" type="number" step="0.01" min="-160" max="160" placeholder="e.g. 12.34">
		</label>
		<label> b*
			<input id="b" type="number" step="0.01" min="-160" max="160" placeholder="e.g. -5.67">
		</label>
		<label> Results
			<input id="limit" type="number" step="1" min="1" max="5000" value="50">
		</label>
		<label> Data source
			<select id="dataSource">
				<option value="colours.json">colours.json (default)</option>
				<option value="upload">Upload JSON…</option>
			</select>
		</label>
		<div>
			<button id="runBtn">Match by ΔE00</button>
		</div>
	</section>

	<div class="chips" id="targetRow" aria-live="polite">
		<div>
			<div class="small">Target (preview)</div>
			<div class="chip" id="targetChip" title="Target preview"></div>
		</div>
		<div class="kv" id="targetMeta"></div>
	</div>

	<section class="results">
		<table>
			<thead>
			<tr>
				<th>#</th>
				<th>Colour</th>
				<th>ΔE00</th>
				<th>Lab (D50)</th>
				<th>Preview</th>
			</tr>
			</thead>
			<tbody id="rows">
			<tr><td colspan="5" class="small">Enter L*, a*, b* and press “Match by ΔE00”.</td></tr>
			</tbody>
			<tfoot>
			<tr>
				<td colspan="5">
					<span class="badge ok">ΔE≤2 ≈ very close</span>
					<span class="badge warn">ΔE 3–5 ≈ noticeable</span>
					<span class="badge bad">ΔE&gt;5 ≈ clearly different</span>
					<span style="margin-left:10px">• Data expected in <span class="code">{ name, L, a, b }</span> (floats, D50/2°).</span>
				</td>
			</tr>
			</tfoot>
		</table>
	</section>

	<input id="fileInput" type="file" accept="application/json" style="display:none" />
</main>

<footer>
	<div class="flex">
		<div>Display pipeline: Lab(D50) → XYZ(D50) → <em>Bradford</em> → XYZ(D65) → sRGB (clamped for monitor). Ranking happens only in Lab D50 with ΔE00.</div>
	</div>
</footer>

<script>
/* ============================
   Utilities
   ============================ */
const $ = sel => document.querySelector(sel);
const clamp01 = x => Math.min(1, Math.max(0, x));
const toNumber = v => Number.parseFloat(v);
const fmt = n => (Number.isFinite(n) ? n.toFixed(2) : n);

/* ============================
   Colour math — Lab(D50) core
   ============================ */

// ΔE2000 with kL=kC=kH=1
function deltaE2000(lab1, lab2) {
	const { L: L1, a: a1, b: b1 } = lab1;
	const { L: L2, a: a2, b: b2 } = lab2;

	const avgLp = (L1 + L2) / 2;
	const C1 = Math.hypot(a1, b1);
	const C2 = Math.hypot(a2, b2);
	const avgC = (C1 + C2) / 2;

	const G = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));
	const a1p = a1 * (1 + G);
	const a2p = a2 * (1 + G);
	const C1p = Math.hypot(a1p, b1);
	const C2p = Math.hypot(a2p, b2);
	const avgCp = (C1p + C2p) / 2;

	const h1p = Math.atan2(b1, a1p) * 180 / Math.PI + (Math.atan2(b1, a1p) < 0 ? 360 : 0);
	const h2p = Math.atan2(b2, a2p) * 180 / Math.PI + (Math.atan2(b2, a2p) < 0 ? 360 : 0);

	let dLp = L2 - L1;
	let dCp = C2p - C1p;

	let dhp;
	if (C1p * C2p === 0) {
		dhp = 0;
	} else {
		let dh = h2p - h1p;
		if (dh > 180) dh -= 360;
		if (dh < -180) dh += 360;
		dhp = dh;
	}
	const dHp = 2 * Math.sqrt(C1p * C2p) * Math.sin((dhp * Math.PI / 180) / 2);

	// Mean metrics
	let avgHp;
	if (C1p * C2p === 0) {
		avgHp = h1p + h2p;
	} else {
		let hsum = h1p + h2p;
		if (Math.abs(h1p - h2p) > 180) {
			avgHp = (hsum < 360) ? (hsum + 360) / 2 : (hsum - 360) / 2;
		} else {
			avgHp = hsum / 2;
		}
	}

	const T = 1
		- 0.17 * Math.cos((avgHp - 30) * Math.PI / 180)
		+ 0.24 * Math.cos((2 * avgHp) * Math.PI / 180)
		+ 0.32 * Math.cos((3 * avgHp + 6) * Math.PI / 180)
		- 0.20 * Math.cos((4 * avgHp - 63) * Math.PI / 180);

	const dRo = 30 * Math.exp(-(((avgHp - 275) / 25) ** 2));
	const RC = 2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7)));
	const RT = -RC * Math.sin(2 * dRo * Math.PI / 180);

	const SL = 1 + (0.015 * ((avgLp - 50) ** 2)) / Math.sqrt(20 + ((avgLp - 50) ** 2));
	const SC = 1 + 0.045 * avgCp;
	const SH = 1 + 0.015 * avgCp * T;

	const dE = Math.sqrt(
		(dLp / SL) ** 2 +
		(dCp / SC) ** 2 +
		(dHp / SH) ** 2 +
		RT * (dCp / SC) * (dHp / SH)
	);
	return dE;
}

// Lab(D50) -> XYZ(D50)
function labD50ToXyz(lab) {
	const {L, a, b} = lab;
	const fy = (L + 16) / 116;
	const fx = fy + (a / 500);
	const fz = fy - (b / 200);

	const f3 = t => t ** 3;
	const invf = t => (t > 6/29) ? f3(t) : (t - 16/116) / 7.787;

	const xr = invf(fx);
	const yr = (L > (6/29)**3 * 903.3) ? f3(fy) : L / 903.3; // piecewise per Lab definition
	const zr = invf(fz);

	// D50 white (Xn,Yn,Zn) from CIE (2°)
	const Xn = 96.422, Yn = 100.000, Zn = 82.521;
	return { X: xr * Xn, Y: yr * Yn, Z: zr * Zn };
}

// Bradford adaptation XYZ(D50) -> XYZ(D65)
function xyzD50ToD65(xyz) {
	const M = [
		[ 0.8951,  0.2664, -0.1614],
		[-0.7502,  1.7135,  0.0367],
		[ 0.0389, -0.0685,  1.0296],
	];
	const Mi = [
		[ 0.9869929, -0.1470543, 0.1599627],
		[ 0.4323053,  0.5183603, 0.0492912],
		[-0.0085287,  0.0400428, 0.9684867],
	];
	const D50 = [96.422, 100.000, 82.521];
	const D65 = [95.047, 100.000, 108.883];

	const mult = (M, v) => ([
		M[0][0]*v[0] + M[0][1]*v[1] + M[0][2]*v[2],
		M[1][0]*v[0] + M[1][1]*v[1] + M[1][2]*v[2],
		M[2][0]*v[0] + M[2][1]*v[1] + M[2][2]*v[2],
	]);

	const cone    = mult(M, [xyz.X, xyz.Y, xyz.Z]);
	const srcCone = mult(M, D50);
	const dstCone = mult(M, D65);

	const scale = [
		cone[0] * (dstCone[0] / srcCone[0]),
		cone[1] * (dstCone[1] / srcCone[1]),
		cone[2] * (dstCone[2] / srcCone[2]),
	];
	const out = mult(Mi, scale);
	return { X: out[0], Y: out[1], Z: out[2] };
}

// XYZ(D65) -> sRGB(0–255)
function xyzD65ToSrgb(xyz) {
	// linear sRGB
	let rl =  3.2406*(xyz.X/100) - 1.5372*(xyz.Y/100) - 0.4986*(xyz.Z/100);
	let gl = -0.9689*(xyz.X/100) + 1.8758*(xyz.Y/100) + 0.0415*(xyz.Z/100);
	let bl =  0.0557*(xyz.X/100) - 0.2040*(xyz.Y/100) + 1.0570*(xyz.Z/100);

	const comp = t => t <= 0.0031308 ? 12.92*t : 1.055*Math.pow(t, 1/2.4) - 0.055;
	const r = Math.round(255 * clamp01(comp(rl)));
	const g = Math.round(255 * clamp01(comp(gl)));
	const b = Math.round(255 * clamp01(comp(bl)));
	return { r, g, b };
}

// Convenience: Lab(D50) -> sRGB(D65)
function labD50ToSrgb(lab) {
	return xyzD65ToSrgb(xyzD50ToD65(labD50ToXyz(lab)));
}

/* ============================
   Data loading
   ============================ */

let COLOURS = []; // { name, L, a, b, ... }

async function loadColoursFrom(urlOrFile) {
	if (urlOrFile instanceof File) {
		const text = await urlOrFile.text();
		return JSON.parse(text);
	} else {
		const res = await fetch(urlOrFile, { cache: "no-store" });
		if (!res.ok) throw new Error(`Failed to fetch ${urlOrFile}: ${res.status}`);
		return res.json();
	}
}

function validateList(list) {
	return list
		.filter(d => d && isFinite(+d.L) && isFinite(+d.a) && isFinite(+d.b))
		.map(d => ({ ...d, L:+d.L, a:+d.a, b:+d.b }));
}

/* ============================
   Matching
   ============================ */
function matchByLab(targetLab, list) {
	return list
		.map(d => ({
			...d,
			score: deltaE2000(targetLab, { L:d.L, a:d.a, b:d.b }),
			_rgb: labD50ToSrgb({ L:d.L, a:d.a, b:d.b })
		}))
		.sort((a,b) => a.score - b.score);
}

function deltaBadgeClass(x){
	if (x <= 2) return "badge ok";
	if (x <= 5) return "badge warn";
	return "badge bad";
}

/* ============================
   UI glue
   ============================ */
const els = {
	L: $("#L"), a: $("#a"), b: $("#b"), limit: $("#limit"),
	runBtn: $("#runBtn"), rows: $("#rows"), targetChip: $("#targetChip"),
	targetMeta: $("#targetMeta"), dataSource: $("#dataSource"), fileInput: $("#fileInput")
};

async function ensureDataLoaded() {
	if (COLOURS.length) return;
	try {
		const list = await loadColoursFrom("colours.json");
		COLOURS = validateList(list);
	} catch (e) {
		console.warn("Could not auto-load colours.json:", e);
	}
}

function setChip(el, rgb) {
	el.style.background = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
}

async function run() {
	await ensureDataLoaded();
	if (els.dataSource.value === "upload" && els.fileInput.files[0]) {
		COLOURS = validateList(await loadColoursFrom(els.fileInput.files[0]));
	}

	if (!COLOURS.length) {
		els.rows.innerHTML = `<tr><td colspan="5">No colours loaded. Place <span class="code">colours.json</span> next to this HTML or choose “Upload JSON…”.</td></tr>`;
		return;
	}

	const L = toNumber(els.L.value), a = toNumber(els.a.value), b = toNumber(els.b.value);
	if (!Number.isFinite(L) || !Number.isFinite(a) || !Number.isFinite(b)) {
		els.rows.innerHTML = `<tr><td colspan="5">Enter valid Lab (D50) numbers first.</td></tr>`;
		return;
	}

	const target = { L, a, b };
	const targetRGB = labD50ToSrgb(target);
	setChip(els.targetChip, targetRGB);
	els.targetMeta.textContent = `Target Lab(D50): L* ${fmt(L)}, a* ${fmt(a)}, b* ${fmt(b)} • Preview sRGB: rgb(${targetRGB.r}, ${targetRGB.g}, ${targetRGB.b})`;

	const limit = Math.max(1, Math.min(5000, Math.round(toNumber(els.limit.value) || 50)));
	const ranked = matchByLab(target, COLOURS).slice(0, limit);

	if (!ranked.length) {
		els.rows.innerHTML = `<tr><td colspan="5">No valid colour entries found in JSON.</td></tr>`;
		return;
	}

	const rows = ranked.map((d, i) => {
		const rgb = d._rgb;
		return `<tr>
			<td>${i+1}</td>
			<td><span class="sw" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></span>${d.name ?? "(unnamed)"}</td>
			<td><span class="${deltaBadgeClass(d.score)}">${fmt(d.score)}</span></td>
			<td>L* ${fmt(d.L)} &nbsp; a* ${fmt(d.a)} &nbsp; b* ${fmt(d.b)}</td>
			<td>rgb(${rgb.r}, ${rgb.g}, ${rgb.b})</td>
		</tr>`;
	}).join("");

	els.rows.innerHTML = rows;
}

// Data source switching
els.dataSource.addEventListener("change", () => {
	if (els.dataSource.value === "upload") {
		els.fileInput.click();
	}
});

// Kick off
els.runBtn.addEventListener("click", () => run());

// Optional: Enter to run
[els.L, els.a, els.b].forEach(inp => inp.addEventListener("keydown", (e) => {
	if (e.key === "Enter") run();
}));
</script>
</body>
</html>
