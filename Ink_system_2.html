<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Ink Mix Predictor â€” 6v Anilox (Upgraded Solver)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --bg:#0f1115; --panel:#151923; --muted:#8a90a5; --text:#e9edf3; --accent:#7bd389; --warn:#f6d36b; --bad:#ff7a7a; --chipBorder:#272b34; }
  *{box-sizing:border-box}
  body{margin:0; font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text)}
  header{padding:18px 22px; border-bottom:1px solid #232737; background:linear-gradient(180deg,#141824,#11141d); display:flex; justify-content:space-between; align-items:center}
  h1{margin:0; font-size:18px}
  #counts{font-size:12px; color:var(--muted)}
  main{display:grid; gap:16px; grid-template-columns: 360px 1fr; padding:18px}
  .card{background:var(--panel); border:1px solid #232737; border-radius:14px; padding:14px}
  .row{display:flex; gap:10px; align-items:center}
  label{display:block; font-size:12px; color:var(--muted); margin-bottom:4px}
  input[type="number"], input[type="text"], select{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a2f3f; background:#0e111a; color:var(--text); outline:none;
  }
  input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button{appearance:none;margin:0}
  button{ background:#1c2230; color:var(--text); border:1px solid #2a2f3f; padding:10px 12px; border-radius:10px; cursor:pointer; }
  button.primary{background:var(--accent); color:#0b1016; border:none; font-weight:600}
  .grid{display:grid; gap:10px}
  .grid.cols-2{grid-template-columns:1fr 1fr}
  .grid.cols-3{grid-template-columns:1fr 1fr 1fr}
  .muted{color:var(--muted)}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a2f3f; color:var(--muted); font-size:12px}
  .chip{width:36px; height:24px; border-radius:6px; border:1px solid var(--chipBorder); background:#777}
  .list{display:grid; gap:8px; margin-top:6px}
  .swatchRow{display:grid; grid-template-columns: 48px 1fr auto; gap:12px; align-items:center; padding:8px; border-radius:10px; border:1px solid #222738; background:#111521}
  .swatchRow:hover{border-color:#2e3448}
  .linkish{cursor:pointer; text-decoration:none; color:inherit}
  .tag{font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #2a2f3f; color:var(--muted); background:#0f1420}
  .sectionTitle{font-weight:600; margin:4px 0 8px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .flex-between{display:flex; justify-content:space-between; align-items:center}
  .bad{color:var(--bad)} .warn{color:var(--warn)} .good{color:var(--accent)}
  .table{width:100%; border-collapse:separate; border-spacing:0 6px; font-size:13px}
  .table td{padding:6px 8px; background:#0f131f; border-top:1px solid #22283a; border-bottom:1px solid #22283a}
  .table tr td:first-child{border-left:1px solid #22283a; border-top-left-radius:8px; border-bottom-left-radius:8px}
  .table tr td:last-child{border-right:1px solid #22283a; border-top-right-radius:8px; border-bottom-right-radius:8px}
  .small{font-size:12px}
  .sliderRow{display:grid; grid-template-columns:120px 1fr 56px; gap:10px; align-items:center}
  .hint{font-size:12px; color:var(--muted)}
  .hr{height:1px; background:#22283a; margin:10px 0}
  .kbd{font-size:12px; border:1px solid #2a2f3f; background:#111521; padding:2px 6px; border-radius:6px}
  .footer{padding:12px 18px; border-top:1px solid #232737; color:var(--muted); font-size:12px}
</style>
</head>
<body>
<header>
  <h1>ðŸŽ¯ Ink Mix Predictor â€” Kubelkaâ€“Munk, 6v (Upgraded)</h1>
  <div id="counts" class="pill">Pantones: 0 Â· Formulas: 0 Â· Colorants: 0</div>
</header>

<main>
  <section class="card">
    <div class="grid">
      <div>
        <label for="pantoneSearch">Pantone search (optional)</label>
        <input id="pantoneSearch" placeholder="e.g., PANTONE 186 C" />
      </div>
      <div class="grid cols-3">
        <div><label for="L">L*</label><input id="L" type="number" step="0.01" value="50" /></div>
        <div><label for="a">a*</label><input id="a" type="number" step="0.01" value="0" /></div>
        <div><label for="b">b*</label><input id="b" type="number" step="0.01" value="0" /></div>
      </div>
      <div class="row">
        <button id="matchBtn" class="primary">Find closest 8</button>
        <span class="hint">Enter LAB or pick a Pantone to prefill LAB.</span>
      </div>
    </div>
    <div class="hr"></div>
    <div id="nearestWrap">
      <div class="flex-between">
        <div class="sectionTitle">Closest Pantone (Î”E00)</div>
        <div class="pill small" id="pantoneCount">0 total</div>
      </div>
      <div class="list" id="nearestList"></div>
    </div>
  </section>

  <section class="card">
    <div class="grid">
      <div class="sectionTitle">Existing Formula (if available)</div>
      <div id="existingFormula" class="muted small">Click a Pantone from the left to reveal stored formula.</div>

      <div class="hr"></div>

      <div class="sectionTitle">Predict a New Formula (KM + upgraded optimiser)</div>
      <div class="grid cols-2">
        <div class="sliderRow">
          <div class="hint">Max ingredients</div>
          <input id="maxInks" type="range" min="2" max="6" step="1" value="4" />
          <div class="pill" id="maxInksVal">4</div>
        </div>
        <div class="sliderRow">
          <div class="hint">Max Black (%)</div>
          <input id="maxBlack" type="range" min="0" max="40" step="1" value="10" />
          <div class="pill" id="maxBlackVal">10%</div>
        </div>
      </div>
      <div class="grid cols-2">
        <div class="sliderRow">
          <div class="hint">Extender policy</div>
          <select id="preferExt">
            <option value="auto" selected>Auto</option>
            <option value="always">Always include</option>
            <option value="never">Never include</option>
          </select>
          <div class="pill">Filmweight tâ‚€ auto-fit (6v) Â±10% micro-scale</div>
        </div>
        <div class="row">
          <button id="predictBtn" class="primary">Suggest formula</button>
          <span id="predictStatus" class="hint"></span>
        </div>
      </div>

      <div class="hr"></div>

      <div id="predictionOutput" style="display:none">
        <div class="flex-between">
          <div class="sectionTitle">Suggested Mix</div>
          <div id="predDe" class="pill">Î”E00: â€“</div>
        </div>
        <table class="table" id="mixTable"></table>
        <div class="row">
          <div class="pill" id="predLab">L*a*b*: â€“</div>
          <div id="predWarn" class="hint"></div>
        </div>
        <div class="hint" id="calibHint"></div>
      </div>
    </div>
  </section>
</main>

<div class="footer">
  Files required alongside this page: <span class="kbd">colours.json</span> Â· <span class="kbd">DC_Formulas.json</span> Â· <span class="kbd">DC21_jan25.json</span> Â· <span class="kbd">assortment_colour_data.json</span>.
</div>

<script>
/* ------------ helpers ------------ */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function round2(x){ return Math.round(x*100)/100; }
function numOr(v, alt){
  const n = (v === null || v === undefined || v === '') ? NaN : Number(v);
  if (Number.isFinite(n)) return n;
  const m = (alt === null || alt === undefined || alt === '') ? NaN : Number(alt);
  return Number.isFinite(m) ? m : NaN;
}
async function fetchJSON(path){
  const r = await fetch(path);
  if(!r.ok) throw new Error('Failed to fetch '+path+': '+r.status+' '+r.statusText);
  return r.json();
}
function asArray(maybe){
  if (Array.isArray(maybe)) return maybe;
  if (maybe && typeof maybe === 'object'){
    if (Array.isArray(maybe.records)) return maybe.records;
    if (Array.isArray(maybe.data)) return maybe.data;
    return Object.values(maybe);
  }
  return [];
}
function canonicalPantoneName(s){
  if(!s) return '';
  s = String(s).toUpperCase().trim().replace(/\s+/g,' ');
  s = s.replace(/PANTONE\s*/,'PANTONE ');
  s = s.replace(/(\d)([A-Z])$/, '$1 $2');
  return s;
}
function bestInkLabel(c){
  const cands = [c.DisplayName, c.FullName, c.LongName, c.Name, c.name, c.Label, c.Code, c.code, c.Id, c.id];
  const nonEmpty = cands.map(x=> (x==null?'':String(x).trim())).filter(x=>x);
  if(!nonEmpty.length) return 'Ink';
  // pick the longest string (most descriptive)
  nonEmpty.sort((a,b)=>b.length-a.length);
  // include code/id if distinct & short
  const extra = (c.code||c.Code||c.id||c.Id||'').toString().trim();
  if(extra && !nonEmpty[0].toLowerCase().includes(extra.toLowerCase())) return nonEmpty[0] + ' ('+extra+')';
  return nonEmpty[0];
}

/* ------------ colour math ------------ */
const WL = Array.from({length:36},(_,i)=>380+10*i);
const CMF = {
  x:[0.001368,0.002236,0.004243,0.007650,0.014310,0.023190,0.043510,0.077630,0.134380,0.214770,0.283900,0.328500,0.348280,0.348060,0.336200,0.318700,0.290800,0.251100,0.195360,0.142100,0.095640,0.057950,0.032010,0.014700,0.004900,0.002400,0.009300,0.029100,0.063270,0.109600,0.165500,0.225750,0.290400,0.359700,0.433450,0.512050],
  y:[0.000039,0.000064,0.000120,0.000217,0.000396,0.000640,0.001210,0.002180,0.004000,0.007300,0.011600,0.016840,0.023000,0.029800,0.038000,0.048000,0.060000,0.073900,0.090980,0.112600,0.139020,0.169300,0.208020,0.258600,0.323000,0.407300,0.503000,0.608200,0.710000,0.793200,0.862000,0.914850,0.954000,0.980300,0.994950,1.000000],
  z:[0.006450,0.010550,0.020050,0.036210,0.067850,0.110200,0.207400,0.371300,0.645600,1.039050,1.385600,1.622960,1.747060,1.782600,1.772110,1.744100,1.669200,1.528100,1.287640,1.041900,0.812950,0.616200,0.465180,0.353300,0.272000,0.212300,0.158200,0.111700,0.078250,0.057250,0.042160,0.029840,0.020300,0.013400,0.008750,0.005750]
};
const D50 = [0.0341,0.3601,0.6861,1.0120,1.3382,1.6643,1.9903,2.3164,2.6424,2.9685,3.2945,3.6205,3.9466,4.2726,4.5987,4.9247,5.2508,5.5768,5.9029,6.2289,6.5550,6.8810,7.2070,7.5331,7.8591,8.1852,8.5112,8.8373,9.1633,9.4893,9.8154,10.141,10.467,10.793,11.119,11.445];
function trapz(y, step){ let s=0; for(let i=1;i<y.length;i++) s += (y[i-1]+y[i]); return s * step/2; }
const k_norm = 100 / trapz(WL.map((_,i)=>D50[i]*CMF.y[i]),10);
const whiteD50 = (()=>({ X: k_norm*trapz(WL.map((_,i)=>D50[i]*CMF.x[i]),10), Y:100, Z: k_norm*trapz(WL.map((_,i)=>D50[i]*CMF.z[i]),10) }))();
function xyzFromSpectrum(R){
  const X = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.x[i]),10);
  const Y = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.y[i]),10);
  const Z = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.z[i]),10);
  return {X,Y,Z};
}
function labFromXYZ(X,Y,Z){
  const xr = X/whiteD50.X, yr = Y/whiteD50.Y, zr = Z/whiteD50.Z;
  const f = t => t>0.008856? Math.cbrt(t): (7.787*t + 16/116);
  const fx=f(xr), fy=f(yr), fz=f(zr);
  const L = 116*fy - 16, a = 500*(fx-fy), b = 200*(fy-fz);
  return {L,a,b};
}
function labFromSpectrum(R){ const {X,Y,Z} = xyzFromSpectrum(R); return labFromXYZ(X,Y,Z); }
function deltaE00(l1,l2){
  const L1=l1.L, a1=l1.a, b1=l1.b, L2=l2.L, a2=l2.a, b2=l2.b;
  const kL=1,kC=1,kH=1;
  const C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2), Cbar=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(Cbar,7)/(Math.pow(Cbar,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2, C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2);
  const h1p=(Math.atan2(b1,a1p)*180/Math.PI+(Math.atan2(b1,a1p)<0?360:0));
  const h2p=(Math.atan2(b2,a2p)*180/Math.PI+(Math.atan2(b2,a2p)<0?360:0));
  const dLp=L2-L1, dCp=C2p-C1p;
  let dhp=0; if(C1p*C2p!==0){ dhp=h2p-h1p; if(dhp>180) dhp-=360; if(dhp<-180) dhp+=360; }
  const dHp=2*Math.sqrt(C1p*C2p)*Math.sin((dhp*Math.PI/180)/2);
  const Lbar=(L1+L2)/2, Cbarp=(C1p+C2p)/2;
  const hbarp=(C1p*C2p===0)?(h1p+h2p): (Math.abs(h1p-h2p)>180?(h1p+h2p+360)/2:(h1p+h2p)/2);
  const T=1-0.17*Math.cos((hbarp-30)*Math.PI/180)+0.24*Math.cos((2*hbarp)*Math.PI/180)+0.32*Math.cos((3*hbarp+6)*Math.PI/180)-0.20*Math.cos((4*hbarp-63)*Math.PI/180);
  const Sl=1+(0.015*Math.pow(Lbar-50,2))/Math.sqrt(20+Math.pow(Lbar-50,2)), Sc=1+0.045*Cbarp, Sh=1+0.015*Cbarp*T;
  const delTheta=30*Math.exp(-Math.pow((hbarp-275)/25,2)); const Rc=2*Math.sqrt(Math.pow(Cbarp,7)/(Math.pow(Cbarp,7)+Math.pow(25,7)));
  const Rt=-Rc*Math.sin(2*delTheta*Math.PI/180);
  return Math.sqrt(Math.pow(dLp/(kL*Sl),2)+Math.pow(dCp/(kC*Sc),2)+Math.pow(dHp/(kH*Sh),2)+Rt*(dCp/(kC*Sc))*(dHp/(kH*Sh)));
}
function hexFromLab(L,a,b){
  if(!Number.isFinite(L)||!Number.isFinite(a)||!Number.isFinite(b)) return '#777';
  const fy=(L+16)/116, fx=a/500+fy, fz=fy-b/200;
  const xr=fx**3>0.008856?fx**3:(116*fx-16)/903.3;
  const yr=L>8?fy**3:L/903.3;
  const zr=fz**3>0.008856?fz**3:(116*fz-16)/903.3;
  let X=xr*whiteD50.X, Y=yr*whiteD50.Y, Z=zr*whiteD50.Z;
  const Ma=[[0.8951,0.2664,-0.1614],[-0.7502,1.7135,0.0367],[0.0389,-0.0685,1.0296]];
  const MaI=[[0.9869929,-0.1470543,0.1599627],[0.4323053,0.5183603,0.0492912],[-0.0085287,0.0400428,0.9684867]];
  const mul=(M,v)=>[M[0][0]*v[0]+M[0][1]*v[1]+M[0][2]*v[2],M[1][0]*v[0]+M[1][1]*v[1]+M[1][2]*v[2],M[2][0]*v[0]+M[2][1]*v[1]+M[2][2]*v[2]];
  const D50w=[whiteD50.X,whiteD50.Y,whiteD50.Z], D65w=[95.047,100,108.883];
  const cW=mul(Ma,D50w), cD=mul(Ma,D65w), c=mul(Ma,[X,Y,Z]);
  const S=[cD[0]/cW[0], cD[1]/cW[1], cD[2]/cW[2]], aXYZ=mul(MaI,[c[0]*S[0],c[1]*S[1],c[2]*S[2]]);
  X=aXYZ[0]; Y=aXYZ[1]; Z=aXYZ[2];
  let r= 3.2406*X/100 + -1.5372*Y/100 + -0.4986*Z/100;
  let g=-0.9689*X/100 +  1.8758*Y/100 +  0.0415*Z/100;
  let b2= 0.0557*X/100 + -0.2040*Y/100 +  1.0570*Z/100;
  const gamma=u=>u<=0.0031308?12.92*u:(1.055*Math.pow(u,1/2.4)-0.055);
  [r,g,b2]=[r,g,b2].map(u=>gamma(clamp(u,0,1)));
  const toHex=t=>(Math.round(t*255)).toString(16).padStart(2,'0');
  return `#${toHex(r)}${toHex(g)}${toHex(b2)}`;
}

/* ------------ KM engine (two-constant; 6v thickness with micro-scale) ------------ */
// fractions sum to 1.  R = function of (fractions, t0*s, substrateR)
function mixReflectance(colorantSet, fractions, t0, s, substrateR){
  const n = WL.length, K = new Array(n).fill(0), S = new Array(n).fill(0);
  for(let i=0;i<colorantSet.length;i++){
    const f = fractions[i]*t0*s; if(f<=0) continue;
    const cst = colorantSet[i].consts; const k1=cst.k1||[], k2=cst.k2||[], s1=cst.s1||[], s2=cst.s2||[];
    for(let j=0;j<n;j++){
      const K1=k1[j]||0, K2=k2[j]||0, S1=s1[j]||0, S2=s2[j]||0;
      K[j] += K1*f + K2*f*f;
      S[j] += S1*f + S2*f*f;
    }
  }
  for(let j=0;j<n;j++){ if(S[j]<=1e-12) S[j]=1e-12; }
  const R = new Array(n);
  for(let j=0;j<n;j++){
    const a = 1 + K[j]/S[j];
    const b = Math.sqrt(Math.max(a*a - 1, 1e-12));
    const r_inf = a - b;
    const tau = Math.exp(-2*b*S[j]);
    const Rg = substrateR[j] ?? 0.9;
    const denom = 1 - Rg*r_inf*tau;
    R[j] = denom===0 ? r_inf : (r_inf + (Rg - r_inf)*tau/denom);
    R[j] = clamp(R[j], 0.0001, 0.9999);
  }
  return R;
}

/* ------------ state ------------ */
const state = {
  pantones: [],
  formulas: new Map(),   // key: canonical Pantone
  colorants: [],         // {meta, name (best), consts}
  substrateR: new Array(WL.length).fill(0.9),
  t0: 1.0,
  blackNames: ['black','pp60 top black','k'],
  extenderNames: ['extender','transparent','clear','base','varnish'],
  assort: null
};
function indexOfBlack(){ for (let i=0;i<state.colorants.length;i++){ const nm = state.colorants[i].name.toLowerCase(); for(const kw of state.blackNames){ if(nm.includes(kw)) return i; } } return -1; }
function indexOfExtender(){ for (let i=0;i<state.colorants.length;i++){ const nm = state.colorants[i].name.toLowerCase(); for(const kw of state.extenderNames){ if(nm.includes(kw)) return i; } } return -1; }

/* ------------ robust JSON loading ------------ */
async function loadAll(){
  // colours
  const colours = asArray(await fetchJSON('colours.json'));
  state.pantones = colours.map(o=>{
    const L = numOr(o.L, o.l); const a = numOr(o.a, o.A); const b = numOr(o.b, o.B);
    const name = (o.Name||o.name||o.Pantone||o.pantone||o.title||'').toString();
    const hex = (o.Hex || o.hex) || hexFromLab(L,a,b);
    return { name, L, a, b, hex };
  }).filter(x => Number.isFinite(x.L)&&Number.isFinite(x.a)&&Number.isFinite(x.b));
  document.getElementById('pantoneCount').textContent = String(state.pantones.length) + ' total';

  // formulas
  const formRaw = await fetchJSON('DC_Formulas.json');
  const formArr = asArray(formRaw);
  const recs = formArr.length ? formArr
              : (formRaw && typeof formRaw==='object' ? Object.keys(formRaw).map(k=>({Pantone:k, ...(formRaw[k]||{})})) : []);
  const byCanon = new Map();
  for(const rec of recs){
    const name0 = (rec.Pantone || rec.Pantone_Name || rec.Name || rec.name || '').toString().trim();
    const key = canonicalPantoneName(name0); if(!key) continue;
    const entries=[];
    for(let i=1;i<=12;i++){
      const inkKeys = [`Ink ${i}`, `Ink${i}`, `Colour ${i}`, `Color ${i}`, `Colorant ${i}`, `Ingredient ${i}`];
      const pctKeys = [(i===1?'%':'%'+i), (i+'%'), `Percent${i}`, `P${i}`, `Amount${i}`];
      let inkName=''; for(const K of inkKeys){ if(rec[K]!==undefined){ inkName=String(rec[K]).trim(); if(inkName) break; } }
      let pct=NaN; for(const P of pctKeys){ if(rec[P]!==undefined){ const v=Number(rec[P]); if(Number.isFinite(v)){ pct=v; break; } } }
      if(inkName && Number.isFinite(pct)) entries.push({ink: inkName, percent: pct});
    }
    if(!entries.length){
      const keys=Object.keys(rec);
      for(const k of keys){
        const m = k.match(/ink\s*([0-9]+)/i);
        if(m){
          const idx=m[1];
          const inkName = (rec[k]||'').toString().trim();
          const pct = Number(rec['%'+(idx==='1'?'':idx)] ?? rec[idx+'%'] ?? rec['Percent'+idx] ?? rec['P'+idx]);
          if(inkName && Number.isFinite(pct)) entries.push({ink: inkName, percent: pct});
        }
      }
    }
    if(entries.length) byCanon.set(key, entries);
  }
  state.formulas = byCanon;

  // calibration (substrate + colorants)
  const dc21 = await fetchJSON('DC21_jan25.json');
  const subR = findSubstrateReflectance(dc21);
  if(subR && subR.length===WL.length) state.substrateR = subR;
  const cands = findColorants(dc21);
  state.colorants = cands;

  // assortment (optional)
  try{ state.assort = await fetchJSON('assortment_colour_data.json'); }catch{ state.assort=null; }

  // fit t0 (6v)
  const tFit = fitThicknessFromLadders();
  state.t0 = Number.isFinite(tFit) ? tFit : 1.0;

  // diagnostics
  document.getElementById('counts').textContent = `Pantones: ${state.pantones.length} Â· Formulas: ${state.formulas.size} Â· Colorants: ${state.colorants.length}`;
  const hint = document.getElementById('calibHint');
  if(hint) hint.textContent = 'Calibrated tâ‚€ = '+state.t0.toFixed(3)+' (with Â±10% micro-scale in optimisation)';
}
function findSubstrateReflectance(root){
  let best=null;
  (function walk(o){
    if(!o || typeof o!=='object') return;
    if(o.reflectance){
      const v=o.reflectance;
      if(Array.isArray(v) && v.length>=WL.length){ best=v.slice(0,WL.length).map(Number); }
      else if(typeof v==='object'){
        const arr=WL.map(wl=> Number(v[wl] ?? v[String(wl)])); if(arr.every(Number.isFinite)) best=arr;
      }
    }
    for(const k of Object.keys(o)){ const val=o[k]; if(typeof val==='object') walk(val); }
  })(root);
  return best;
}
function arrFromMaybe36(v){
  if(!v) return null;
  if(Array.isArray(v) && v.length>=WL.length) return WL.map((_,i)=> Number(v[i])||0);
  if(typeof v==='object'){ return WL.map(wl=> Number(v[wl] ?? v[String(wl)] ?? 0)); }
  return null;
}
function normaliseColorant(el){
  if(!el || typeof el!=='object') return null;
  const meta = {...el};
  const nameBest = bestInkLabel(el);
  const km = el.km_constants || el.KM || el.KMConstants || el.km || {};
  const k1 = arrFromMaybe36(km.k1 || km.K1 || el.k1 || el.K1);
  const k2 = arrFromMaybe36(km.k2 || km.K2 || el.k2 || el.K2);
  const s1 = arrFromMaybe36(km.s1 || km.S1 || el.s1 || el.S1);
  const s2 = arrFromMaybe36(km.s2 || km.S2 || el.s2 || el.S2);
  if(!(k1||s1)) return null;
  return { meta, name: nameBest, consts:{ k1:k1||new Array(WL.length).fill(0), k2:k2||new Array(WL.length).fill(0), s1:s1||new Array(WL.length).fill(0), s2:s2||new Array(WL.length).fill(0) } };
}
function findColorants(root){
  const out=[];
  (function walk(node){
    if(!node) return;
    if(Array.isArray(node)){
      if(node.length && typeof node[0]==='object'){
        const looks = node.some(el=> el && typeof el==='object' && (el.km_constants||el.KM||el.K1||el.k1||el.s1||el.S1));
        if(looks){ node.forEach(el=>{ const c=normaliseColorant(el); if(c) out.push(c); }); return; }
      }
      node.forEach(walk); return;
    }
    if(typeof node==='object'){
      if(Array.isArray(node.colorants)) node.colorants.forEach(el=>{ const c=normaliseColorant(el); if(c) out.push(c); });
      for(const v of Object.values(node)) walk(v);
    }
  })(root);
  // dedupe by name string
  const seen = new Set(); const uniq=[];
  for(const c of out){ const key=c.name.toLowerCase(); if(!seen.has(key)){ seen.add(key); uniq.push(c); } }
  return uniq;
}

/* ------------ fit t0 from ladders ------------ */
function fitThicknessFromLadders(){
  if(!state.assort || state.colorants.length===0) return NaN;
  const idx = new Map(state.colorants.map(c=>[c.name.toLowerCase(), c]));
  const samples=[];
  (function scan(obj){
    if(!obj) return;
    if(Array.isArray(obj)){ obj.forEach(scan); return; }
    if(typeof obj==='object'){
      const keys=Object.keys(obj);
      const hasConc = keys.some(k=>/concentration|percent|strength|load/i.test(k));
      const L = numOr(obj.L, obj.l), A = numOr(obj.A, obj.a), B = numOr(obj.B, obj.b);
      const hasLab = Number.isFinite(L)&&Number.isFinite(A)&&Number.isFinite(B);
      if(hasConc && hasLab){
        const nm = (obj.name || obj.colorant || obj.Colorant || obj.ink || '').toString().trim().toLowerCase();
        const c = idx.get(nm);
        if(c){
          let conc = obj.concentration; if(!Number.isFinite(Number(conc))) conc = obj.percent || obj.strength || obj.load;
          conc = Number(conc);
          if(Number.isFinite(conc)){
            if(conc>1.0001) conc/=100;
            conc = clamp(conc,0,1);
            samples.push({cobj:c, conc, lab:{L, a:A, b:B}});
          }
        }
      }
      for(const v of Object.values(obj)) scan(v);
    }
  })(state.assort);

  if(samples.length < 10) return NaN;

  const extIdx = indexOfExtender();
  function rmsDE(t0){
    let se=0, n=0;
    for(const s of samples){
      const inks = extIdx>=0 ? [s.cobj, state.colorants[extIdx]] : [s.cobj];
      const fr = extIdx>=0 ? [s.conc, 1 - s.conc] : [s.conc];
      const R = mixReflectance(inks, fr, t0, 1.0, state.substrateR);
      const lab = labFromSpectrum(R);
      const dE = deltaE00(lab, s.lab);
      se += dE*dE; n++;
    }
    return Math.sqrt(se/Math.max(1,n));
  }
  let bestT=1.0, bestE=Infinity;
  for(let t=0.6; t<=1.6; t+=0.02){
    const e=rmsDE(Number(t.toFixed(2)));
    if(e<bestE){ bestE=e; bestT=Number(t.toFixed(2)); }
  }
  return bestT;
}

/* ------------ Nearest Pantone + Existing Formula ------------ */
function findNearestPantones(L,a,b,k){
  const target = {L:Number(L), a:Number(a), b:Number(b)};
  const scored = state.pantones.map(p=>{
    const dE = deltaE00(target, {L:p.L,a:p.a,b:p.b});
    const hex = p.hex || hexFromLab(p.L,p.a,p.b) || '#777';
    return {name:p.name, L:p.L, a:p.a, b:p.b, hex, dE};
  }).sort((x,y)=>x.dE - y.dE);
  return scored.slice(0,k);
}
function showExistingFormula(name){
  const wrap=document.getElementById('existingFormula');
  const key=canonicalPantoneName(name);
  const rec=state.formulas.get(key);
  if(!rec){ wrap.innerHTML = '<span class="muted">No stored formula for <b>'+name+'</b>.</span>'; return; }
  const rows = rec.map(r=>'<tr><td class="mono">'+r.ink+'</td><td class="mono" style="text-align:right">'+round2(r.percent)+'%</td></tr>').join('');
  wrap.innerHTML = '<div class="flex-between"><div class="sectionTitle" style="margin:0 0 6px 0">'+name+
    '</div><div class="pill small">Total: '+round2(rec.reduce((s,x)=>s+x.percent,0))+'%</div></div>'+
    '<table class="table">'+rows+'</table>';
}

/* ------------ Upgraded predictor ------------ */
// Forward-select up to maxInks best candidates before fine optimisation.
function selectInkSubset(targetLab, maxInks){
  const inks = state.colorants;
  const N = inks.length;
  const ext = indexOfExtender();
  const chosen = new Set();
  // Start from the single ink that alone gets closest
  function scoreWithSet(testSet){
    const fr = new Array(N).fill(0);
    // naive equal split among chosen (normalised below)
    const arr=[...testSet];
    for(const i of arr){ fr[i]=1; }
    // add 0.3 extender if available to stabilise L*
    if(ext>=0) fr[ext]+=0.3;
    let s=fr.reduce((a,b)=>a+b,0); for(let i=0;i<N;i++) fr[i]/=s;
    // quick one-step optimise s (film micro-scale) only, keep fr fixed
    let best=Infinity, bestS=1.0, bestLab=null;
    for(let t=0.9;t<=1.1;t+=0.02){
      const R = mixReflectance(inks, fr, state.t0, t, state.substrateR);
      const L = labFromSpectrum(R);
      const d=deltaE00(targetLab, L);
      if(d<best){best=d; bestS=t; bestLab=L;}
    }
    return {de:best, s:bestS, lab:bestLab};
  }
  // greedy forward
  for(let k=0;k<Math.min(maxInks, Math.max(1,N)); k++){
    let bestI=-1, bestDE=Infinity, bestPack=null;
    for(let i=0;i<N;i++){
      if(chosen.has(i)) continue;
      const test = new Set(chosen); test.add(i);
      const got=scoreWithSet(test);
      if(got.de < bestDE){ bestDE=got.de; bestI=i; bestPack=got; }
    }
    if(bestI>=0) chosen.add(bestI);
  }
  return [...chosen];
}

function predictMixForLab(targetLab, options){
  const maxInks = Number(options.maxInks)||4;
  const maxBlackPct = Number(options.maxBlackPct)||10;
  const preferExt = options.preferExt || 'auto';
  const seedPantone = options.seedPantone || null;

  const inks = state.colorants;
  if(!inks.length) throw new Error('No colorants loaded');

  const N=inks.length;
  const blackIdx = indexOfBlack(), extIdx = indexOfExtender(), kMaxBlack = maxBlackPct/100;

  // --- build candidate subset
  let subset = selectInkSubset(targetLab, maxInks);
  // seed with stored formula if available to help labels & realism
  if(seedPantone && state.formulas.has(canonicalPantoneName(seedPantone))){
    const rec = state.formulas.get(canonicalPantoneName(seedPantone));
    const indices = rec.map(r=> inks.findIndex(c=> c.name.toLowerCase()===r.ink.toLowerCase())).filter(i=>i>=0);
    subset = Array.from(new Set([...subset, ...indices])).slice(0, maxInks);
  }
  if(extIdx>=0 && preferExt!=='never' && !subset.includes(extIdx)) subset = [...subset, extIdx].slice(0, maxInks);

  // --- variables: fractions for subset + micro-scale s
  const M = subset.length;
  let x = new Array(M).fill(1/M); // start fractions equal
  let s = 1.0;

  // helper: project fractions under constraints
  function project(vec){
    // map back to full length to enforce black cap
    const full = new Array(N).fill(0);
    for(let j=0;j<M;j++) full[subset[j]] = Math.max(0, vec[j]);
    if(blackIdx>=0){ full[blackIdx] = Math.min(full[blackIdx], kMaxBlack); }
    if(extIdx>=0){
      if(preferExt==='never') full[extIdx]=0;
      if(preferExt==='always') full[extIdx]=Math.max(full[extIdx], 0.1);
    }
    // sparsify to â‰¤ maxInks already done by subset
    let sum=full.reduce((a,b)=>a+b,0);
    if(sum<=0){ if(extIdx>=0) full[extIdx]=1; else full[subset[0]]=1; sum=1; }
    for(let i=0;i<N;i++) full[i]/=sum;
    // return reduced
    return subset.map(i=>full[i]);
  }

  function objective(vec, scale){
    const full = new Array(N).fill(0);
    for(let j=0;j<M;j++) full[subset[j]] = vec[j];
    const R = mixReflectance(inks, full, state.t0, scale, state.substrateR);
    const lab = labFromSpectrum(R);
    const dE = deltaE00(targetLab, lab);
    // mild L* dev penalty to push toward correct lightness if chroma is similar
    const pL = Math.abs(lab.L - targetLab.L) * 0.02;
    return {val:dE + pL, dE, lab};
  }

  // multi-start seeds
  const seeds=[];
  // 1) equal in subset (+ optional extender)
  seeds.push({x: project(x.slice()), s:1.0});
  // 2) seed from existing formula if present
  if(seedPantone && state.formulas.has(canonicalPantoneName(seedPantone))){
    const rec = state.formulas.get(canonicalPantoneName(seedPantone));
    const tmp = new Array(N).fill(0);
    let tot=0;
    for(const r of rec){
      const idx = inks.findIndex(c=> c.name.toLowerCase()===r.ink.toLowerCase());
      if(idx>=0){ tmp[idx]+=Math.max(0, r.percent/100); tot+=Math.max(0, r.percent/100); }
    }
    if(tot>0){ for(let i=0;i<N;i++) tmp[i]/=tot; }
    seeds.push({x: subset.map(i=>tmp[i]||0), s:1.0});
  }
  // 3) greedy chroma-biased
  const tmp3=new Array(N).fill(0); if(extIdx>=0 && preferExt!=='never') tmp3[extIdx]=0.25;
  for(const i of subset){ if(i!==extIdx) tmp3[i]+= (0.75/(subset.includes(extIdx)?(subset.length-1):subset.length)); }
  seeds.push({x: subset.map(i=>tmp3[i]||0), s:1.0});
  // 4-9) random sparse
  for(let r=0;r<6;r++){
    const t=new Array(N).fill(0); const picks=[...subset].sort(()=>Math.random()-0.5).slice(0, Math.max(2, Math.min(4, subset.length)));
    let rem=1.0; picks.forEach((i,idx)=>{ const share = (idx===picks.length-1)?rem: Math.random()*rem; t[i]+=share; rem-=share; });
    seeds.push({x: subset.map(i=>t[i]||0), s: 0.95 + 0.1*Math.random()});
  }

  // run projected gradient on seeds + small line search on s
  let best={val:Infinity, dE:Infinity, lab:null, x:null, s:1.0};
  function clampS(v){ return clamp(v, 0.9, 1.1); }
  for(const sd of seeds){
    let xk = project(sd.x.slice()); let sk = clampS(sd.s);
    let step=0.25;
    for(let it=0; it<140; it++){
      const eps=1e-3, g=new Array(M).fill(0);
      const f0=objective(xk, sk).val;
      for(let j=0;j<M;j++){
        const x1=xk.slice(); x1[j]+=eps; const x1p=project(x1);
        const f1=objective(x1p, sk).val; g[j]=(f1-f0)/eps;
      }
      // gradient step on x
      let xc = xk.map((v,j)=> v - step*g[j]); xc = project(xc);
      // 1D line search on s
      let bestLoc={val:Infinity, s:sk};
      for(const tryS of [sk, clampS(sk*1.03), clampS(sk*0.97)]){
        const f = objective(xc, tryS).val;
        if(f<bestLoc.val) bestLoc={val:f, s:tryS};
      }
      // accept/reject
      const fCand = bestLoc.val;
      if(fCand <= f0){ xk=xc; sk=bestLoc.s; step*=1.06; }
      else { step*=0.5; }
    }
    const res = objective(xk, sk);
    if(res.val < best.val){ best={...res, x:xk, s:sk}; }
  }

  // Nelderâ€“Mead local polish on [x..., s]
  function nmPolish(startX, startS){
    const D = M+1; // simplex size = dim+1 (dim=M fractions + 1 scale) but we keep sum-to-1 via projection; so treat as M+1 variables with projection
    const vertices=[]; const base = startX.slice(); let s0=startS;
    function pack(vx, vs){ return {x: project(vx), s: clamp(vs,0.9,1.1)}; }
    vertices.push(pack(base, s0));
    for(let j=0;j<M;j++){
      const v=base.slice(); v[j]+=0.08; vertices.push(pack(v, s0));
    }
    vertices.push(pack(base, clamp(s0*1.02,0.9,1.1)));
    function f(v){ return objective(v.x, v.s).val; }
    let V=vertices.map(v=>({v, f:f(v)}));
    for(let it=0; it<60; it++){
      V.sort((a,b)=>a.f-b.f);
      const bestV=V[0].v, worstV=V[V.length-1].v;
      // centroid of all but worst
      const c=new Array(M).fill(0); let cs=0;
      for(let i=0;i<V.length-1;i++){ for(let j=0;j<M;j++) c[j]+=V[i].v.x[j]; cs+=V[i].v.s; }
      for(let j=0;j<M;j++) c[j]/=(V.length-1); cs/=(V.length-1);
      const reflect = pack(c.map((cj,j)=> cj + (cj - worstV.x[j])), cs + (cs - worstV.s));
      const fr = f(reflect);
      if(fr < V[V.length-2].f){
        // accept reflect
        V[V.length-1]={v:reflect, f:fr};
      } else {
        // contraction toward best
        const contr = pack(bestV.x.map((bj,j)=> (bj + worstV.x[j])/2), (bestV.s + worstV.s)/2);
        V[V.length-1]={v:contr, f:f(contr)};
      }
    }
    V.sort((a,b)=>a.f-b.f);
    return V[0];
  }
  const polished = nmPolish(best.x, best.s);
  const finalX = polished.v.x, finalS = polished.v.s;
  const finalObj = objective(finalX, finalS);

  // build components list with proper names
  const full = new Array(N).fill(0); for(let j=0;j<M;j++) full[subset[j]] = finalX[j];
  const components = full.map((v,i)=>({ name: state.colorants[i].name, pct: v*100 }))
                         .filter(c=>c.pct>0.05).sort((a,b)=>b.pct-a.pct);

  return {components, predictedLab: finalObj.lab, dE: finalObj.dE};
}

/* ------------ UI ------------ */
function el(id){ return document.getElementById(id); }
function renderNearest(list){
  const wrap=el('nearestList'); wrap.innerHTML='';
  for(const p of list){
    const row=document.createElement('a'); row.className='swatchRow linkish';
    row.innerHTML = '<div class="chip" style="background:'+ (p.hex||'#777') +'"></div>'+
      '<div><div><b>'+p.name+'</b></div>'+
      '<div class="muted small">Î”E00 '+round2(p.dE)+' Â· L*a*b* '+round2(p.L)+', '+round2(p.a)+', '+round2(p.b)+'</div></div>'+
      '<div><span class="tag">Select</span></div>';
    row.addEventListener('click', ()=>{
      el('L').value = p.L.toFixed(2);
      el('a').value = p.a.toFixed(2);
      el('b').value = p.b.toFixed(2);
      showExistingFormula(p.name);
      el('predictBtn').dataset.seed = p.name;
    });
    wrap.appendChild(row);
  }
}
function renderPrediction(result){
  const out=el('predictionOutput'), table=el('mixTable'), labPill=el('predLab'), dEPill=el('predDe'), warn=el('predWarn');
  const rows = result.components.map(c=>'<tr><td class="mono">'+c.name+'</td><td class="mono" style="text-align:right">'+round2(c.pct)+'%</td></tr>').join('');
  table.innerHTML = rows || '<tr><td colspan="2" class="muted">No components found.</td></tr>';
  labPill.textContent = 'L*a*b*: '+round2(result.predictedLab.L)+', '+round2(result.predictedLab.a)+', '+round2(result.predictedLab.b);
  dEPill.textContent = 'Î”E00: ' + round2(result.dE);
  dEPill.className = 'pill ' + (result.dE<=1.5 ? 'good' : (result.dE<=3 ? 'warn' : 'bad'));
  warn.textContent = (result.components.length>4? 'Many components may be impractical; reduce Max ingredients.' : '');
  out.style.display='block';
}

/* ------------ bootstrap ------------ */
window.addEventListener('DOMContentLoaded', async ()=>{
  const maxInks=el('maxInks'), maxInksVal=el('maxInksVal');
  maxInks.addEventListener('input', ()=> maxInksVal.textContent = String(maxInks.value));
  const maxBlack=el('maxBlack'), maxBlackVal=el('maxBlackVal');
  maxBlack.addEventListener('input', ()=> maxBlackVal.textContent = String(maxBlack.value)+'%');

  try{
    await loadAll();
  }catch(e){
    console.error(e);
    alert('Failed to load one or more JSON files. See console for details.\n'+e.message);
  }

  el('pantoneSearch').addEventListener('input', (e)=>{
    const q=(e.target.value||'').toLowerCase().trim(); if(!q) return;
    const hit = state.pantones.find(p=>(p.name||'').toLowerCase().includes(q));
    if(hit){ el('L').value=hit.L.toFixed(2); el('a').value=hit.a.toFixed(2); el('b').value=hit.b.toFixed(2); }
  });

  el('matchBtn').addEventListener('click', ()=>{
    const L = Number(el('L').value), a = Number(el('a').value), b = Number(el('b').value);
    renderNearest(findNearestPantones(L,a,b,8));
  });

  el('predictBtn').addEventListener('click', ()=>{
    const L = Number(el('L').value), a = Number(el('a').value), b = Number(el('b').value);
    const seed = el('predictBtn').dataset.seed || null;
    const opts = { maxInks: Number(el('maxInks').value), maxBlackPct: Number(el('maxBlack').value), preferExt: el('preferExt').value, seedPantone: seed };
    el('predictStatus').textContent = 'Optimisingâ€¦';
    setTimeout(()=>{ try{
      const result = predictMixForLab({L,a,b}, opts);
      renderPrediction(result);
      el('predictStatus').textContent = '';
    }catch(err){ el('predictStatus').textContent = 'Error: ' + (err && err.message ? err.message : String(err)); } }, 10);
  });
});
</script>
</body>
</html>
