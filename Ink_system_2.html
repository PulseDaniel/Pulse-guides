<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Ink Mix Predictor â€” 6v Anilox (Pantone Î”E + KM)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0f1115; --panel:#151923; --muted:#8a90a5; --text:#e9edf3; --accent:#7bd389; --warn:#f6d36b; --bad:#ff7a7a; --chipBorder:#272b34;
  }
  *{box-sizing:border-box}
  body{margin:0; font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text)}
  header{padding:18px 22px; border-bottom:1px solid #232737; background:linear-gradient(180deg,#141824,#11141d)}
  h1{margin:0; font-size:18px; letter-spacing:.3px}
  main{display:grid; gap:16px; grid-template-columns: 360px 1fr; padding:18px}
  .card{background:var(--panel); border:1px solid #232737; border-radius:14px; padding:14px}
  .row{display:flex; gap:10px; align-items:center}
  label{display:block; font-size:12px; color:var(--muted); margin-bottom:4px}
  input[type="number"], input[type="text"], select{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a2f3f; background:#0e111a; color:var(--text);
    outline:none;
  }
  input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button{appearance:none;margin:0}
  button{
    background:#1c2230; color:var(--text); border:1px solid #2a2f3f; padding:10px 12px; border-radius:10px; cursor:pointer;
  }
  button.primary{background:var(--accent); color:#0b1016; border:none; font-weight:600}
  button.ghost{background:transparent}
  .grid{display:grid; gap:10px}
  .grid.cols-2{grid-template-columns:1fr 1fr}
  .grid.cols-3{grid-template-columns:1fr 1fr 1fr}
  .muted{color:var(--muted)}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a2f3f; color:var(--muted); font-size:12px}
  .chip{width:36px; height:24px; border-radius:6px; border:1px solid var(--chipBorder)}
  .list{display:grid; gap:8px; margin-top:6px}
  .swatchRow{display:grid; grid-template-columns: 48px 1fr auto; gap:12px; align-items:center; padding:8px; border-radius:10px; border:1px solid #222738; background:#111521}
  .swatchRow:hover{border-color:#2e3448}
  .linkish{cursor:pointer; text-decoration:none; color:inherit}
  .tag{font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #2a2f3f; color:var(--muted); background:#0f1420}
  .sectionTitle{font-weight:600; margin:4px 0 8px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .flex-between{display:flex; justify-content:space-between; align-items:center}
  .bad{color:var(--bad)} .warn{color:var(--warn)} .good{color:var(--accent)}
  .table{width:100%; border-collapse:separate; border-spacing:0 6px; font-size:13px}
  .table td{padding:6px 8px; background:#0f131f; border-top:1px solid #22283a; border-bottom:1px solid #22283a}
  .table tr td:first-child{border-left:1px solid #22283a; border-top-left-radius:8px; border-bottom-left-radius:8px}
  .table tr td:last-child{border-right:1px solid #22283a; border-top-right-radius:8px; border-bottom-right-radius:8px}
  .small{font-size:12px}
  .sliderRow{display:grid; grid-template-columns:120px 1fr 56px; gap:10px; align-items:center}
  .hint{font-size:12px; color:var(--muted)}
  .hr{height:1px; background:#22283a; margin:10px 0}
  .kbd{font-size:12px; border:1px solid #2a2f3f; background:#111521; padding:2px 6px; border-radius:6px}
  .footer{padding:12px 18px; border-top:1px solid #232737; color:var(--muted); font-size:12px}
  .loading{opacity:.55; filter:saturate(.7)}
</style>
</head>
<body>
<header>
  <h1>ðŸŽ¯ Ink Mix Predictor â€” Kubelkaâ€“Munk (Calibrated: 6-volume anilox)</h1>
</header>

<main>
  <!-- LEFT: Inputs and Nearest Matches -->
  <section class="card">
    <div class="grid">
      <div>
        <label for="pantoneSearch">Pantone search (optional)</label>
        <input id="pantoneSearch" placeholder="e.g., PANTONE 186 C" />
      </div>
      <div class="grid cols-3">
        <div>
          <label for="L">L*</label>
          <input id="L" type="number" step="0.01" value="50" />
        </div>
        <div>
          <label for="a">a*</label>
          <input id="a" type="number" step="0.01" value="0" />
        </div>
        <div>
          <label for="b">b*</label>
          <input id="b" type="number" step="0.01" value="0" />
        </div>
      </div>
      <div class="row">
        <button id="matchBtn" class="primary">Find closest 8</button>
        <span class="hint">Enter LAB or pick a Pantone to prefill LAB.</span>
      </div>
    </div>

    <div class="hr"></div>

    <div id="nearestWrap">
      <div class="flex-between">
        <div class="sectionTitle">Closest Pantone (Î”E00)</div>
        <div class="pill small" id="pantoneCount">0 total</div>
      </div>
      <div class="list" id="nearestList"></div>
    </div>
  </section>

  <!-- RIGHT: Existing Formula + Predictor -->
  <section class="card">
    <div class="grid">
      <div class="sectionTitle">Existing Formula (if available)</div>
      <div id="existingFormula" class="muted small">Click a Pantone from the left to reveal stored formula.</div>

      <div class="hr"></div>

      <div class="sectionTitle">Predict a New Formula (Two-Constant KM)</div>
      <div class="grid cols-2">
        <div class="sliderRow">
          <div class="hint">Max ingredients</div>
          <input id="maxInks" type="range" min="2" max="6" step="1" value="4" />
          <div class="pill" id="maxInksVal">4</div>
        </div>
        <div class="sliderRow">
          <div class="hint">Max Black (%)</div>
          <input id="maxBlack" type="range" min="0" max="40" step="1" value="10" />
          <div class="pill" id="maxBlackVal">10%</div>
        </div>
      </div>
      <div class="grid cols-2">
        <div class="sliderRow">
          <div class="hint">Extender policy</div>
          <select id="preferExt">
            <option value="auto" selected>Auto</option>
            <option value="always">Always include</option>
            <option value="never">Never include</option>
          </select>
          <div class="pill">Calibrated tâ‚€ fitted</div>
        </div>
        <div class="row">
          <button id="predictBtn" class="primary">Suggest formula</button>
          <span id="predictStatus" class="hint"></span>
        </div>
      </div>

      <div class="hr"></div>

      <div id="predictionOutput" style="display:none">
        <div class="flex-between">
          <div class="sectionTitle">Suggested Mix</div>
          <div id="predDe" class="pill">Î”E00: â€“</div>
        </div>
        <table class="table" id="mixTable"></table>
        <div class="row">
          <div class="pill" id="predLab">L*a*b*: â€“</div>
          <div id="predWarn" class="hint"></div>
        </div>
        <div class="hint" id="calibHint"></div>
      </div>
    </div>
  </section>
</main>

<div class="footer">
  Expected files (same folder): <span class="kbd">colours.json</span> Â· <span class="kbd">DC_Formulas.json</span> Â· <span class="kbd">DC21_jan25.json</span> Â· <span class="kbd">assortment_colour_data.json</span>. |
  D50/2Â°, 45/0, gloss excluded. Filmweight locked by 6v calibration (tâ‚€ auto-fit at load).
</div>

<script>
/* ===========================
   Colour Math & KM Constants
=========================== */
const WL = Array.from({length:36},(_,i)=>380+10*i);
const CMF = {
  x:[0.001368,0.002236,0.004243,0.007650,0.014310,0.023190,0.043510,0.077630,0.134380,0.214770,0.283900,0.328500,0.348280,0.348060,0.336200,0.318700,0.290800,0.251100,0.195360,0.142100,0.095640,0.057950,0.032010,0.014700,0.004900,0.002400,0.009300,0.029100,0.063270,0.109600,0.165500,0.225750,0.290400,0.359700,0.433450,0.512050],
  y:[0.000039,0.000064,0.000120,0.000217,0.000396,0.000640,0.001210,0.002180,0.004000,0.007300,0.011600,0.016840,0.023000,0.029800,0.038000,0.048000,0.060000,0.073900,0.090980,0.112600,0.139020,0.169300,0.208020,0.258600,0.323000,0.407300,0.503000,0.608200,0.710000,0.793200,0.862000,0.914850,0.954000,0.980300,0.994950,1.000000],
  z:[0.006450,0.010550,0.020050,0.036210,0.067850,0.110200,0.207400,0.371300,0.645600,1.039050,1.385600,1.622960,1.747060,1.782600,1.772110,1.744100,1.669200,1.528100,1.287640,1.041900,0.812950,0.616200,0.465180,0.353300,0.272000,0.212300,0.158200,0.111700,0.078250,0.057250,0.042160,0.029840,0.020300,0.013400,0.008750,0.005750]
};
const D50 = [0.0341,0.3601,0.6861,1.0120,1.3382,1.6643,1.9903,2.3164,2.6424,2.9685,3.2945,3.6205,3.9466,4.2726,4.5987,4.9247,5.2508,5.5768,5.9029,6.2289,6.5550,6.8810,7.2070,7.5331,7.8591,8.1852,8.5112,8.8373,9.1633,9.4893,9.8154,10.141,10.467,10.793,11.119,11.445];
function trapz(y, step){ let s=0; for(let i=1;i<y.length;i++) s += (y[i-1]+y[i]); return s * step/2; }
const k_norm = 100 / trapz(WL.map((_,i)=>D50[i]*CMF.y[i]),10);
const whiteD50 = (()=>({
  X: k_norm*trapz(WL.map((_,i)=>D50[i]*CMF.x[i]),10),
  Y: 100,
  Z: k_norm*trapz(WL.map((_,i)=>D50[i]*CMF.z[i]),10)
}))();

function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function round2(x){ return Math.round(x*100)/100; }
function xyzFromSpectrum(R){
  const X = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.x[i]),10);
  const Y = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.y[i]),10);
  const Z = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.z[i]),10);
  return {X,Y,Z};
}
function labFromXYZ(X,Y,Z){
  const xr = X/whiteD50.X, yr = Y/whiteD50.Y, zr = Z/whiteD50.Z;
  const f = t => t>0.008856? Math.cbrt(t): (7.787*t + 16/116);
  const fx=f(xr), fy=f(yr), fz=f(zr);
  const L = 116*fy - 16;
  const a = 500*(fx-fy);
  const b = 200*(fy-fz);
  return {L,a,b};
}
function labFromSpectrum(R){ const {X,Y,Z} = xyzFromSpectrum(R); return labFromXYZ(X,Y,Z); }
function deltaE00(l1,l2){
  const {L:L1,a:a1,b:b1}=l1, {L:L2,a:a2,b:b2}=l2; const kL=1,kC=1,kH=1;
  const C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2); const Cbar=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(Cbar,7)/(Math.pow(Cbar,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2; const C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2);
  const h1p=(Math.atan2(b1,a1p)*180/Math.PI+(Math.atan2(b1,a1p)<0?360:0)); const h2p=(Math.atan2(b2,a2p)*180/Math.PI+(Math.atan2(b2,a2p)<0?360:0));
  const dLp=L2-L1, dCp=C2p-C1p; let dhp=0;
  if(C1p*C2p!==0){ dhp=h2p-h1p; if(dhp>180) dhp-=360; if(dhp<-180) dhp+=360; }
  const dHp=2*Math.sqrt(C1p*C2p)*Math.sin((dhp*Math.PI/180)/2);
  const Lbar=(L1+L2)/2, Cbarp=(C1p+C2p)/2; let hbarp=0;
  if(C1p*C2p===0) hbarp=h1p+h2p;
  else{ const diff=Math.abs(h1p-h2p); hbarp=(diff>180)?(h1p+h2p+360)/2:(h1p+h2p)/2; }
  const T=1-0.17*Math.cos((hbarp-30)*Math.PI/180)+0.24*Math.cos((2*hbarp)*Math.PI/180)+0.32*Math.cos((3*hbarp+6)*Math.PI/180)-0.20*Math.cos((4*hbarp-63)*Math.PI/180);
  const Sl=1+(0.015*Math.pow(Lbar-50,2))/Math.sqrt(20+Math.pow(Lbar-50,2)), Sc=1+0.045*Cbarp, Sh=1+0.015*Cbarp*T;
  const delTheta=30*Math.exp(-Math.pow((hbarp-275)/25,2)); const Rc=2*Math.sqrt(Math.pow(Cbarp,7)/(Math.pow(Cbarp,7)+Math.pow(25,7)));
  const Rt=-Rc*Math.sin(2*delTheta*Math.PI/180);
  return Math.sqrt(Math.pow(dLp/(kL*Sl),2)+Math.pow(dCp/(kC*Sc),2)+Math.pow(dHp/(kH*Sh),2)+Rt*(dCp/(kC*Sc))*(dHp/(kH*Sh)));
}

/* ===========================
   KM Engine â€” Two-Constant
   Locked filmweight via t0 (6v)
=========================== */
// Model: colorant i with constants per Î»: K_i(c)=k1_i c + k2_i c^2, S_i(c)=s1_i c + s2_i c^2, where c = fraction * t0.
// Mix: K=Î£K_i, S=Î£S_i. Layer reflectance over backing Rg:
// a=1+K/S, b=sqrt(a^2-1), r_inf=a-b; Ï„=exp(-2 b S * 1) ; R = r_inf + (Rgâˆ’r_inf) Ï„ / (1âˆ’Rg r_inf Ï„)

function mixReflectance(colorantSet, fractions, t0, substrateR){
  const n = WL.length;
  const K = new Array(n).fill(0), S = new Array(n).fill(0);
  for(let i=0;i<colorantSet.length;i++){
    const f = fractions[i]*t0;
    if(f<=0) continue;
    const {k1,k2,s1,s2} = colorantSet[i].consts;
    for(let j=0;j<n;j++){
      K[j] += k1[j]*f + k2[j]*f*f;
      S[j] += s1[j]*f + s2[j]*f*f;
    }
  }
  for(let j=0;j<n;j++){ if(S[j]<=1e-12) S[j]=1e-12; }
  const R = new Array(n);
  for(let j=0;j<n;j++){
    const a = 1 + K[j]/S[j];
    const b = Math.sqrt(Math.max(a*a - 1, 1e-12));
    const r_inf = a - b;
    const tau = Math.exp(-2*b*S[j]); // thickness "1" because c already carries t0
    const Rg = substrateR[j];
    const denom = 1 - Rg*r_inf*tau;
    R[j] = denom===0 ? r_inf : (r_inf + (Rg - r_inf)*tau/denom);
    R[j] = clamp(R[j], 0.0001, 0.9999);
  }
  return R;
}

/* ===========================
   Data & State
=========================== */
const state = {
  pantones: [], // {name,L,a,b,hex}
  formulas: new Map(), // Pantone -> [{ink,percent}]
  colorants: [], // [{id,name,consts:{k1,k2,s1,s2}}]
  substrateR: new Array(WL.length).fill(0.9),
  t0: 1.0, // fitted thickness scalar for 6v
  blackNames: ['black','pp60 top black','k'],
  extenderNames: ['extender','transparent','clear','base','varnish'],
  assort: null
};

function hexFromLab(L,a,b){
  // Lab(D50) -> XYZ(D50) -> Bradford to D65 -> sRGB
  const fy=(L+16)/116, fx= a/500+fy, fz= fy - b/200;
  const xr= fx**3>0.008856? fx**3: (116*fx-16)/903.3;
  const yr= L>8? fy**3: L/903.3;
  const zr= fz**3>0.008856? fz**3: (116*fz-16)/903.3;
  let X=xr*whiteD50.X, Y=yr*whiteD50.Y, Z=zr*whiteD50.Z;
  const Ma=[[0.8951,0.2664,-0.1614],[-0.7502,1.7135,0.0367],[0.0389,-0.0685,1.0296]];
  const MaI=[[0.9869929,-0.1470543,0.1599627],[0.4323053,0.5183603,0.0492912],[-0.0085287,0.0400428,0.9684867]];
  const mul=(M,v)=>[M[0][0]*v[0]+M[0][1]*v[1]+M[0][2]*v[2],M[1][0]*v[0]+M[1][1]*v[1]+M[1][2]*v[2],M[2][0]*v[0]+M[2][1]*v[1]+M[2][2]*v[2]];
  const D50w=[whiteD50.X,whiteD50.Y,whiteD50.Z], D65w=[95.047,100,108.883];
  const cW=mul(Ma,D50w), cD=mul(Ma,D65w), c=mul(Ma,[X,Y,Z]);
  const S=[cD[0]/cW[0], cD[1]/cW[1], cD[2]/cW[2]], aXYZ=mul(MaI,[c[0]*S[0],c[1]*S[1],c[2]*S[2]]);
  X=aXYZ[0]; Y=aXYZ[1]; Z=aXYZ[2];
  let r= 3.2406*X/100 + -1.5372*Y/100 + -0.4986*Z/100;
  let g=-0.9689*X/100 +  1.8758*Y/100 +  0.0415*Z/100;
  let b2= 0.0557*X/100 + -0.2040*Y/100 +  1.0570*Z/100;
  const gamma=u=>u<=0.0031308?12.92*u:(1.055*Math.pow(u,1/2.4)-0.055);
  [r,g,b2]=[r,g,b2].map(u=>gamma(clamp(u,0,1)));
  const toHex=t=>(Math.round(t*255)).toString(16).padStart(2,'0');
  return `#${toHex(r)}${toHex(g)}${toHex(b2)}`;
}

/* ===========================
   Load JSON & Fit t0 (6v)
=========================== */
async function loadAll(){
  // colours.json
  const colours = await fetch('colours.json').then(r=>r.json());
  state.pantones = colours.map(o=>({
    name: o.Name || o.name || o.Pantone || o.pantone || o.title,
    L: +o.L ?? +o.l, a: +o.a ?? +o.A, b: +o.b ?? +o.B,
    hex: o.Hex || o.hex || hexFromLab(+o.L??+o.l, +o.a??+o.A, +o.b??+o.B)
  })).filter(x=>isFinite(x.L) && isFinite(x.a) && isFinite(x.b));

  // DC_Formulas.json
  const dc = await fetch('DC_Formulas.json').then(r=>r.json());
  for(const rec of dc){
    const name = rec.Pantone || rec.Pantone_Name || rec.Name || rec.name;
    if(!name) continue;
    const entries = [];
    const keys = Object.keys(rec);
    for(const k of keys){
      const mInk = k.match(/^Ink\s*(\d+)/i);
      if(mInk){
        const idx = mInk[1];
        const inkName = (rec[k]||'').toString().trim();
        const pct = +rec['%'+(idx=== '1'?'': idx)] || +rec[(idx==='1')? '%': (idx+'%')] || NaN;
        if(inkName && isFinite(pct)) entries.push({ink: inkName, percent: pct});
      }
    }
    if(entries.length) state.formulas.set(name.trim(), entries);
  }

  // DC21_jan25.json (calibration)
  const dc21 = await fetch('DC21_jan25.json').then(r=>r.json());
  if(dc21.substrate && dc21.substrate.reflectance){
    const r = [];
    for(const wl of WL){
      const v = dc21.substrate.reflectance[wl] ?? dc21.substrate.reflectance[wl.toString()];
      r.push( (v!=null)? +v : 0.9 );
    }
    state.substrateR = r;
  }
  if(dc21.colorants){
    state.colorants = dc21.colorants.map(c=>{
      const k1 = c.km_constants?.k1 || c.k1, k2 = c.km_constants?.k2 || c.k2;
      const s1 = c.km_constants?.s1 || c.s1, s2 = c.km_constants?.s2 || c.s2;
      const arr=a=>WL.map((_,i)=> +a?.[i] || 0);
      return { id: c.id || c.code || c.name, name: c.name || c.code || c.id,
               consts: {k1:arr(k1),k2:arr(k2),s1:arr(s1),s2:arr(s2)} };
    }).filter(c=>c.consts.k1.some(v=>v!==0) && c.consts.s1.some(v=>v!==0));
  }

  // Assortment ladders (optional)
  try{ state.assort = await fetch('assortment_colour_data.json').then(r=>r.json()); }catch(_){ state.assort=null; }

  document.getElementById('pantoneCount').textContent = `${state.pantones.length} total`;

  // Fit t0 (thickness scalar) from ladders if present; else 1.0
  state.t0 = fitThicknessFromLadders(state) ?? 1.0;
  document.getElementById('calibHint')?.innerText = `Calibrated for 6v: thickness scalar tâ‚€ = ${state.t0.toFixed(3)} (auto-fit)`;
}

// Fit t0 by minimising Î”E between predicted single-ink ladders and provided Lab ladders (white backing) across inks.
function fitThicknessFromLadders(s){
  if(!s.assort || !s.colorants.length) return null;

  // build simple index: name -> colorant object
  const idxByName = new Map(s.colorants.map(c=>[c.name.toLowerCase(), c]));

  // attempt to find ladder entries shaped like:
  // { name: "DC21-XXX", ladder: [{concentration: p (0-100 or 0-1), labW: {L,a,b}} ...] }
  // Your file structure may differ; try to adapt heuristically:
  const ladders = [];
  const scan = (obj)=>{
    if(!obj) return;
    if(Array.isArray(obj)){ obj.forEach(scan); return; }
    if(typeof obj==='object'){
      // candidate leaf with fields
      const keys = Object.keys(obj);
      if(keys.some(k=>/concentration|percent|strength|load/i.test(k)) && (obj.L!=null || obj.l!=null || ('lab' in obj))){
        ladders.push(obj);
      }
      for(const v of Object.values(obj)) scan(v);
    }
  };
  scan(s.assort);

  // Group by colorant name if available
  const samples = [];
  ladders.forEach(le=>{
    const name = (le.name || le.colorant || le.Colorant || le.ink || '').toString().trim().toLowerCase();
    const cobj = idxByName.get(name);
    if(!cobj) return;
    // normalise concentration 0..1
    let conc = le.concentration ?? le.percent ?? le.strength ?? le.load;
    if(conc==null) return;
    conc = +conc; if(!isFinite(conc)) return;
    if(conc>1.0001) conc = conc/100;
    // extract Lab (prefer white backing)
    let L = +le.L || +le.l || (le.lab?.L ?? le.lab?.l);
    let a = +le.A || +le.a || (le.lab?.A ?? le.lab?.a);
    let b = +le.B || +le.b || (le.lab?.B ?? le.lab?.b);
    if(![L,a,b].every(x=>isFinite(x))) return;

    samples.push({cobj, conc: Math.max(0, Math.min(1, conc)), labW:{L,a,b}});
  });

  if(samples.length < 12) return null; // not enough to fit reliably

  // Error function: RMS Î”E across all single-ink patches
  function rmsDE(t0){
    let se=0, n=0;
    for(const s1 of samples){
      // Fractions: ink at conc, plus extender if present to make up 1. (if extender exists)
      const extIdx = indexOfExtender();
      const inks = extIdx>=0 ? [s1.cobj, state.colorants[extIdx]] : [s1.cobj];
      const fracs = extIdx>=0 ? [s1.conc, 1 - s1.conc] : [s1.conc];
      const R = mixReflectance(inks, fracs, t0, state.substrateR);
      const lab = labFromSpectrum(R);
      const dE = deltaE00(lab, s1.labW);
      se += dE*dE; n++;
    }
    return Math.sqrt(se / Math.max(1,n));
  }

  // 1D search over t0 in a plausible window
  let bestT = 1.0, bestE = Infinity;
  const grid = [];
  for(let t=0.6; t<=1.6; t+=0.02) grid.push(+t.toFixed(2));
  for(const t of grid){
    const e = rmsDE(t);
    if(e < bestE){ bestE=e; bestT=t; }
  }
  return bestT;
}

/* ===========================
   Convenience helpers
=========================== */
function indexOfBlack(){
  const idx = state.colorants.findIndex(c=> state.blackNames.some(x=> c.name.toLowerCase().includes(x)));
  return idx;
}
function indexOfExtender(){
  const idx = state.colorants.findIndex(c=> state.extenderNames.some(x=> c.name.toLowerCase().includes(x)));
  return idx;
}
function defaultInkSet(){ return state.colorants.slice(); }

/* ===========================
   Nearest Pantone
=========================== */
function findNearestPantones(L,a,b,k=8){
  const target = {L:+L,a:+a,b:+b};
  return state.pantones.map(p=>({ ...p, dE: deltaE00(target,{L:p.L,a:p.a,b:p.b}) }))
    .sort((x,y)=>x.dE-y.dE).slice(0,k);
}

/* ===========================
   Existing Formula Viewer
=========================== */
function showExistingFormula(name){
  const wrap = document.getElementById('existingFormula');
  const rec = state.formulas.get(name);
  if(!rec){ wrap.innerHTML = `<span class="muted">No stored formula for <b>${name}</b>.</span>`; return; }
  const rows = rec.map(r=>(
    `<tr><td class="mono">${r.ink}</td><td class="mono" style="text-align:right">${round2(r.percent)}%</td></tr>`
  )).join('');
  wrap.innerHTML = `
    <div class="flex-between">
      <div class="sectionTitle" style="margin:0 0 6px 0">${name}</div>
      <div class="pill small">Total: ${round2(rec.reduce((s,x)=>s+x.percent,0))}%</div>
    </div>
    <table class="table">${rows}</table>
  `;
}

/* ===========================
   Predictor (Constraints + Optimiser)
=========================== */
function predictMixForLab(targetLab, options){
  const {maxInks=4, maxBlackPct=10, preferExt='auto', seedPantone=null} = options;
  const inks = defaultInkSet();
  if(inks.length===0) throw new Error('No colorants loaded');
  const n = inks.length;

  // Seed from existing Pantone, else small greedy start (+extender if present)
  let fractions = new Array(n).fill(0);
  if(seedPantone && state.formulas.has(seedPantone)){
    const rec = state.formulas.get(seedPantone);
    let sum=0;
    for(const r of rec){
      const idx = inks.findIndex(c=> c.name.toLowerCase() === r.ink.toLowerCase());
      if(idx>=0){ fractions[idx]=Math.max(0, r.percent/100); sum += r.percent/100; }
    }
    if(sum>0) fractions = fractions.map(x=>x/sum);
  }else{
    const ext = indexOfExtender(); if(ext>=0 && preferExt!=='never') fractions[ext]=0.3;
    // greedy pick 2 chromatic inks that reduce Î”E
    function score(i){
      const test=fractions.slice(); test[i]+=0.35;
      const s=test.reduce((a,b)=>a+b,0); if(s>1) for(let j=0;j<n;j++) test[j]/=s;
      const R = mixReflectance(inks,test,state.t0,state.substrateR);
      const lab = labFromSpectrum(R);
      return -deltaE00(targetLab, lab);
    }
    const picks = inks.map((_,i)=>({i,s:score(i)})).sort((a,b)=>b.s-a.s).slice(0,3).map(x=>x.i);
    for(const i of picks) fractions[i] += (indexOfExtender()===i?0: (0.7/(picks.length-(indexOfExtender()>=0?1:0)) ));
    let s=fractions.reduce((a,b)=>a+b,0); if(s>0) for(let j=0;j<n;j++) fractions[j]/=s;
  }

  const blackIdx = indexOfBlack(), extIdx = indexOfExtender(), kMaxBlack = maxBlackPct/100;

  function project(vec){
    // non-neg + cap black
    for(let i=0;i<n;i++) vec[i]=Math.max(0, vec[i]);
    if(blackIdx>=0) vec[blackIdx] = Math.min(vec[blackIdx], kMaxBlack);
    // extender policy
    if(extIdx>=0){
      if(preferExt==='never') vec[extIdx]=0;
      if(preferExt==='always') vec[extIdx]=Math.max(vec[extIdx], 0.1);
    }
    // top-k sparsity
    const topK=[...vec].map((v,i)=>({v,i})).sort((a,b)=>b.v-a.v).slice(0,maxInks).map(x=>x.i);
    for(let i=0;i<n;i++) if(!topK.includes(i)) vec[i]=0;
    // renorm
    let sum=vec.reduce((a,b)=>a+b,0);
    if(sum<=0){ if(extIdx>=0) vec[extIdx]=1; else vec[0]=1; sum=1; }
    for(let i=0;i<n;i++) vec[i]/=sum;
    return vec;
  }

  function objective(vec){
    const R = mixReflectance(inks, vec, state.t0, state.substrateR);
    const lab = labFromSpectrum(R);
    const dE = deltaE00(targetLab, lab);
    // mild sparsity + guard against silly 5th+ components
    let pen = 0.002 * vec.reduce((s,x)=> s + Math.abs(x), 0);
    return {val:dE+pen, dE, lab};
  }

  let x=project(fractions.slice()); let best=objective(x), bestX=x.slice();
  let step=0.28;
  for(let it=0; it<150; it++){
    const eps=1e-3, g=new Array(n).fill(0);
    const f0 = objective(x).val;
    for(let i=0;i<n;i++){
      const x1=x.slice(); x1[i]+=eps; project(x1);
      const f1=objective(x1).val; g[i]=(f1-f0)/eps;
    }
    let xCand=x.map((xi,i)=>xi - step*g[i]); xCand=project(xCand);
    const fCand=objective(xCand);
    if(fCand.val <= best.val){ x=xCand; best=fCand; bestX=xCand.slice(); step*=1.05; }
    else step*=0.5;
  }

  const comp = bestX.map((v,i)=>({name: inks[i].name, idx:i, pct: v*100}))
                    .filter(c=>c.pct>0.05).sort((a,b)=>b.pct-a.pct);
  return {components: comp, predictedLab: best.lab, dE: best.dE};
}

/* ===========================
   UI Wiring
=========================== */
function el(id){ return document.getElementById(id); }

function renderNearest(list){
  const wrap=el('nearestList'); wrap.innerHTML='';
  list.forEach(p=>{
    const row=document.createElement('a'); row.className='swatchRow linkish';
    row.innerHTML=`
      <div class="chip" style="background:${p.hex}"></div>
      <div>
        <div><b>${p.name}</b></div>
        <div class="muted small">Î”E00 ${round2(p.dE)} Â· L*a*b* ${round2(p.L)}, ${round2(p.a)}, ${round2(p.b)}</div>
      </div>
      <div><span class="tag">Select</span></div>`;
    row.addEventListener('click', ()=>{
      el('L').value = p.L.toFixed(2);
      el('a').value = p.a.toFixed(2);
      el('b').value = p.b.toFixed(2);
      showExistingFormula(p.name);
      el('predictBtn').dataset.seed = p.name;
    });
    wrap.appendChild(row);
  });
}

function renderPrediction(result){
  const out=el('predictionOutput'), table=el('mixTable'), labPill=el('predLab'), dEPill=el('predDe'), warn=el('predWarn');
  const rows = result.components.map(c=>`<tr><td class="mono">${c.name}</td><td class="mono" style="text-align:right">${round2(c.pct)}%</td></tr>`).join('');
  table.innerHTML = rows || `<tr><td colspan="2" class="muted">No components found.</td></tr>`;
  labPill.textContent = `L*a*b*: ${round2(result.predictedLab.L)}, ${round2(result.predictedLab.a)}, ${round2(result.predictedLab.b)}`;
  dEPill.textContent = `Î”E00: ${round2(result.dE)}`;
  dEPill.className = 'pill'; if(result.dE<=1.5) dEPill.classList.add('good'); else if(result.dE<=3) dEPill.classList.add('warn'); else dEPill.classList.add('bad');
  warn.textContent = (result.components.length>4? 'Many components may be impractical; reduce Max ingredients.': '');
  out.style.display='block';
}

/* ===========================
   Bootstrap
=========================== */
window.addEventListener('DOMContentLoaded', async ()=>{
  const status=el('predictStatus');
  // mirrors
  const maxInks=el('maxInks'), maxInksVal=el('maxInksVal');
  maxInks.addEventListener('input', ()=> maxInksVal.textContent = maxInks.value);
  const maxBlack=el('maxBlack'), maxBlackVal=el('maxBlackVal');
  maxBlack.addEventListener('input', ()=> maxBlackVal.textContent = maxBlack.value+'%');

  await loadAll();

  // Pantone search
  el('pantoneSearch').addEventListener('input', (e)=>{
    const q=e.target.value.toLowerCase().trim(); if(!q) return;
    const hit = state.pantones.find(p=>(p.name||'').toLowerCase().includes(q));
    if(hit){ el('L').value=hit.L.toFixed(2); el('a').value=hit.a.toFixed(2); el('b').value=hit.b.toFixed(2); }
  });

  // Find nearest
  el('matchBtn').addEventListener('click', ()=>{
    const L=+el('L').value, a=+el('a').value, b=+el('b').value;
    renderNearest(findNearestPantones(L,a,b,8));
  });

  // Predict
  el('predictBtn').addEventListener('click', ()=>{
    const L=+el('L').value, a=+el('a').value, b=+el('b').value;
    const seed = el('predictBtn').dataset.seed || null;
    status.textContent='Optimisingâ€¦';
    const opts={ maxInks:+el('maxInks').value, maxBlackPct:+el('maxBlack').value, preferExt:el('preferExt').value, seedPantone:seed };
    setTimeout(()=>{ try{
      const result = predictMixForLab({L,a,b}, opts);
      renderPrediction(result);
      status.textContent='';
    }catch(e){ status.textContent='Error: '+e.message; } }, 10);
  });
});
</script>
</body>
</html>
