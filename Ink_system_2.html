<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Ink Colour Matcher</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root { --gap:12px; --fg:#111; --muted:#666; --bg:#fff; --accent:#0a84ff; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:20px; color:var(--fg); background:var(--bg); }
    h1 { margin:0 0 10px; }
    .row, .row2, .flex { display:flex; gap:var(--gap); align-items:flex-end; flex-wrap:wrap; }
    .row > div, .row2 > div { display:flex; flex-direction:column; gap:6px; }
    input[type="number"], input[type="text"] { padding:8px 10px; font-size:14px; border:1px solid #ddd; border-radius:8px; min-width:120px; }
    .btn { background:var(--accent); color:#fff; border:none; border-radius:10px; padding:10px 14px; cursor:pointer; font-weight:600; }
    .btn:disabled { opacity:0.5; cursor:not-allowed; }
    .muted { color:var(--muted); font-size:12px; }
    .panel { border:1px solid #eee; border-radius:12px; padding:14px; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap:var(--gap); }
    .formula-box { border:1px dashed #ddd; border-radius:12px; padding:12px; background:#fafafa; }
    .formula-grid { display:grid; grid-template-columns:1fr auto; gap:8px 12px; margin-top:6px; }
    .fg-ink { font-weight:600; }
    .fg-pct { text-align:right; }
    #predictMsg { min-height: 18px; display:inline-block; margin-left:10px; }
    .ok { color:#0a8f2f; }
    .err { color:#b00020; }
    .warn { color:#b18500; }
    hr { border:none; border-top:1px solid #eee; margin:16px 0; }
  </style>
</head>
<body>
  <h1>Ink Colour Matcher</h1>

  <!-- Inputs / controls -->
  <div id="controls" class="panel" style="margin-bottom:16px;">
    <div class="row">
      <div>
        <label for="LInput">Target L*</label>
        <input id="LInput" type="number" step="0.01" placeholder="e.g. 31.80">
      </div>
      <div>
        <label for="aInput">Target a*</label>
        <input id="aInput" type="number" step="0.01" placeholder="e.g. -19.40">
      </div>
      <div>
        <label for="bInput">Target b*</label>
        <input id="bInput" type="number" step="0.01" placeholder="e.g. 32.30">
      </div>
      <div style="display:flex; gap:10px; align-items:flex-end;">
        <button class="btn" id="suggestBtn">Suggest Formula</button>
        <span id="predictMsg" class="muted" aria-live="polite"></span>
      </div>
    </div>
  </div>

  <div class="grid">
    <!-- Left: your existing colour matching / list / existing formulas -->
    <div id="leftColumn" class="panel">
      <h2>Colour Matching</h2>
      <p class="muted">Your existing panels/tables render here exactly as before (JSON data still loads).</p>
      <div id="matcherArea"></div>
      <hr>
      <h3>Closest Matches</h3>
      <div id="closestList"></div>
      <hr>
      <h3>Existing Formulas</h3>
      <div id="existingFormulaList"></div>
    </div>

    <!-- Right: API-powered predictor + logging -->
    <div id="predictorBox" class="panel">
      <div id="suggestedFormula" class="formula-box" style="display:none;"></div>

      <div id="logArea" style="display:none;">
        <div class="row2" style="margin-top:8px;">
          <div>
            <label for="pantoneName">Pantone / Name</label>
            <input id="pantoneName" type="text" placeholder="e.g. PANTONE 485 C">
          </div>
          <div>
            <label for="notes">Notes (optional)</label>
            <input id="notes" type="text" placeholder="press/anilox/edits...">
          </div>
        </div>
        <div class="row" style="margin-top:8px;">
          <div><label for="mL">Measured L*</label><input id="mL" type="number" step="0.01"></div>
          <div><label for="mA">Measured a*</label><input id="mA" type="number" step="0.01"></div>
          <div><label for="mB">Measured b*</label><input id="mB" type="number" step="0.01"></div>
        </div>
        <div class="flex" style="margin-top:8px;">
          <button class="btn" id="logBtn">Log approved</button>
          <span class="muted" id="logMsg" aria-live="polite"></span>
        </div>
      </div>

      <p class="muted" style="margin-top:10px;">
        <a href="#" id="exportLink">Export newly approved rows (CSV)</a>
      </p>
    </div>
  </div>

  <script>
  (function(){
    // ====== CONFIG ======
    const API_BASE = 'https://<YOUR-RENDER-SERVICE>.onrender.com'; // <-- set yours

    // ====== UTIL ======
    const $ = (sel)=>document.querySelector(sel);
    const num = (v)=> {
      const x = parseFloat(v);
      return Number.isFinite(x) ? x : null;
    };

    // ====== LEGACY JSON LOAD (UNCHANGED PATHS, NON-FATAL) ======
    // We keep your exact filenames & relative paths. If they fail, we warn but DO NOT stop the app.
    async function safeFetchJson(url){
      try {
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
        return await r.json();
      } catch (e) {
        console.warn('Failed to load', url, e);
        return null; // non-fatal: the API predictor will still work
      }
    }

    // Make these available for your existing scripts/UI that expect them.
    // We keep the names conventional: colours, assortment, dcFormulas/basisInks.
    let colours = [];
    let assortment = [];
    let dcFormulas = [];
    let basisInks = []; // some pages use this alias

    async function loadLegacyData(){
      const c = await safeFetchJson('./colours.json');                       // your colour DB
      const a = await safeFetchJson('./assortment_colour_data.json');        // assortment/tints
      const d = await safeFetchJson('./DC_Formulas.json');                   // existing formulas

      colours   = Array.isArray(c) ? c : (c || []);
      assortment= Array.isArray(a) ? a : (a || []);
      dcFormulas= Array.isArray(d) ? d : (d || (d && d.items) || []);

      // If your older scripts expect basisInks, mirror from assortment if present
      basisInks = Array.isArray(assortment) ? assortment : [];

      // Notify UI area if you want; otherwise silent.
      if (!basisInks.length) {
        console.warn('No basis inks available – local solver disabled, API suggest will still work.');
        // DO NOT abort; keep the app alive.
      }

      // OPTIONAL: call your existing renderers if they rely on these arrays.
      renderLegacyPanels();
    }

    function renderLegacyPanels(){
      // Leave your existing rendering intact.
      // These DOM nodes are placeholders; if your page has its own renderer, it will still work.
      const m = $('#matcherArea');
      if (m && colours.length) {
        m.innerHTML = `<span class="muted">${colours.length} colours loaded.</span>`;
      }
      const efl = $('#existingFormulaList');
      if (efl && dcFormulas.length) {
        efl.innerHTML = `<span class="muted">${dcFormulas.length} existing formulas loaded.</span>`;
      }
    }

    // ====== TARGET LAB INPUTS ======
    function getTargetLab(){
      const L = num($('#LInput')?.value);
      const a = num($('#aInput')?.value);
      const b = num($('#bInput')?.value);
      if (L===null || a===null || b===null) return null;
      return { L, a, b };
    }

    // ====== API: PREDICT ======
    async function suggestFormula(){
      const t = getTargetLab();
      const msg = $('#predictMsg');
      const box = $('#suggestedFormula');
      const log = $('#logArea');

      if (!t){
        alert('Enter a valid L*, a*, b* first.');
        return;
      }
      try {
        if (msg){ msg.textContent = 'Predicting…'; msg.className = 'muted'; }
        if (box){ box.style.display='none'; box.innerHTML=''; }
        if (log){ log.style.display='none'; }
        const res = await fetch(API_BASE + '/predict', {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify({ L: t.L, a: t.a, b: t.b, lock_neighbours: true })
        });
        if (!res.ok) {
          const txt = await res.text().catch(()=>res.statusText);
          throw new Error(`API ${res.status}: ${txt}`);
        }
        const data = await res.json();
        const formula = data.formula || {};
        window._lastSuggestion = { target: t, formula };

        // Render cleanly
        const pairs = Object.entries(formula).sort((a,b)=>b[1]-a[1]);
        let html = '<h2>Suggested Formula</h2><div class="formula-grid">';
        for (const [ink, pct] of pairs) {
          html += `<div class="fg-ink">${ink}</div><div class="fg-pct">${pct.toFixed(2)}%</div>`;
        }
        html += '</div>';
        if (box){ box.innerHTML = html; box.style.display='block'; }
        if (msg){ msg.textContent = 'Done.'; msg.className = 'muted ok'; }
        if (log){ log.style.display='block'; }
      } catch (e){
        console.error(e);
        if (msg){ msg.textContent = e.message; msg.className = 'muted err'; }
      }
    }

    // ====== API: LOG APPROVED ======
    async function logApproved(){
      const sug = window._lastSuggestion;
      const msg = $('#logMsg');
      if (!sug){ alert('Predict first.'); return; }

      const payload = {
        pantone: $('#pantoneName')?.value || '',
        target_L: sug.target.L,
        target_a: sug.target.a,
        target_b: sug.target.b,
        suggested: sug.formula,
        // For now, approved == suggested; if you later add editable fields, wire them here.
        approved: sug.formula,
        measured_L: num($('#mL')?.value),
        measured_a: num($('#mA')?.value),
        measured_b: num($('#mB')?.value),
        notes: $('#notes')?.value || ''
      };
      if (msg){ msg.textContent = 'Saving…'; msg.className = 'muted'; }

      try {
        const res = await fetch(API_BASE + '/log_approved', {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          const txt = await res.text().catch(()=>res.statusText);
          throw new Error(`API ${res.status}: ${txt}`);
        }
        const j = await res.json();
        if (msg){ msg.textContent = `Saved (id ${j.id}).`; msg.className = 'muted ok'; }
      } catch (e) {
        console.error(e);
        if (msg){ msg.textContent = e.message; msg.className = 'muted err'; }
      }
    }

    // ====== API: EXPORT NEW TRAINING ROWS ======
    async function exportNewRows(e){
      e?.preventDefault?.();
      try {
        const res = await fetch(API_BASE + '/export_training');
        if (!res.ok) throw new Error(await res.text());
        const j = await res.json();
        if (!j.csv || !j.rows) { alert('No new approved rows yet.'); return; }
        const blob = new Blob([j.csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'new_training_rows.csv';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      } catch (e) {
        alert('Export failed: ' + e.message);
      }
    }

    // ====== WIRE EVENTS ======
    document.addEventListener('DOMContentLoaded', () => {
      // Load your legacy JSONs without changing file names / paths
      loadLegacyData();

      // Wire buttons without assuming exact structure
      $('#suggestBtn')?.addEventListener('click', suggestFormula);
      $('#logBtn')?.addEventListener('click', logApproved);
      $('#exportLink')?.addEventListener('click', exportNewRows);

      // Enter key runs prediction if focused in any LAB input
      for (const id of ['LInput','aInput','bInput']){
        const el = $('#'+id);
        el && el.addEventListener('keydown', (ev)=>{ if (ev.key==='Enter') suggestFormula(); });
      }
    });
  })();
  </script>
</body>
</html>
