<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pulse - Colour Bar</title>
<style>
  :root{ --gap:12px; --radius:14px; }
  *{ box-sizing:border-box; }
  body{ font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:0; padding:16px; background:#0b0c10; color:#e6e6e6; }
  h1{ font-size:1.2rem; margin:0 0 8px; }
  
  /* App bar + segmented tabs (pro app shell) */
  .appbar{
    position:sticky;
    top:0;
    z-index:60;
    max-width:1200px;
    margin:0 auto 14px;
    padding:10px 12px;
    background:#0d1016;
    border:1px solid #22252e;
    border-radius:18px;
    box-shadow:0 10px 26px rgba(0,0,0,.45);
    backdrop-filter:saturate(1.2) blur(6px);
  }
  .appbar-inner{
    display:flex;
    align-items:center;
    justify-content:flex-start;
    gap:12px;
    flex-wrap:wrap;
  }
  .app-title{
    font-weight:800;
    letter-spacing:.2px;
    color:#e6e6e6;
    display:flex;
    align-items:center;
    gap:10px;
    white-space:nowrap;
  }
  .app-title .tag{
    font-size:.8rem;
    color:#9aa4b2;
    font-weight:700;
    border:1px solid #242938;
    background:#0f1219;
    padding:6px 10px;
    border-radius:999px;
  }

  .tabs{
    display:flex;
    gap:6px;
    margin:0;
    flex-wrap:wrap;
    justify-content:flex-start;
    width:auto;
    padding:0;
    background:transparent;
    border:none;
    border-radius:0;
  }
  .tabbtn{
    cursor:pointer;
    padding:10px 14px;
    border-radius:12px;
    border:1px solid transparent;
    background:transparent;
    color:#cbd5e1;
    font-weight:800;
  }
  .tabbtn:hover{ background:rgba(255,255,255,.06); }
  .tabbtn[aria-selected="true"]{
    background:#141824;
    border-color:#2a2f3a;
    color:#e6e6e6;
  }
  @media (max-width:900px){
    .appbar-inner{ justify-content:center; }
    .app-title{ width:100%; justify-content:center; }
  }

  .tabbtn{ cursor:pointer; padding:10px 14px; border-radius:12px; border:1px solid #2a2f3a; background:#141824; color:#e6e6e6; font-weight:700; }
  .tabbtn[aria-selected="true"]{ background:#1a2133; border-color:#3a4252; }
  .app{ max-width:1200px; margin:0 auto; display:grid; gap:var(--gap); grid-template-columns:420px 1fr; align-items:start; }
  .card{ background:#111318; border:1px solid #22252e; border-radius:var(--radius); padding:16px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
  label{ display:block; font-size:.85rem; color:#98a2b3; margin-bottom:6px; }
  input, select, textarea{ width:100%; padding:10px 12px; border-radius:10px; outline:none; background:#0e1015; border:1px solid #2a2f3a; color:#e6e6e6; }
  input::placeholder{ color:#7b8496; }
  textarea{ min-height:80px; resize:vertical; }
  .row{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:var(--gap); }
  .row2{ display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); }
  .btn{ cursor:pointer; padding:10px 12px; border-radius:10px; border:1px solid #2a2f3a; background:#141824; color:#e6e6e6; font-weight:600; }
  .btn:hover{ filter:brightness(1.08); }
  table{ width:100%; border-collapse:collapse; }
  th,td{ text-align:left; padding:10px; border-bottom:1px dashed #242938; font-variant-numeric:tabular-nums; }
  th{ color:#9aa4b2; font-weight:600; }
  .result-row{ transition:background .2s; cursor:pointer; }
  .result-row:hover{ background:rgba(255,255,255,.05); }
  .swatch{ width:3.1rem; height:2.1rem; border-radius:6px; border:1px solid rgba(255,255,255,.2); }
  .pill{ font-size:.8rem; color:#98a2b3; }
  .muted{ color:#7b8496; font-size:.85rem; }
  .formula-box{ background:#0e1015; border:1px solid #2a2f3a; border-radius:10px; padding:12px; margin-top:10px; }
  .formula-box h2{ margin:0 0 8px; font-size:1rem; color:#ccc; }
  .formula-grid{ display:grid; grid-template-columns:1fr auto; column-gap:12px; row-gap:6px; align-items:center; }
  .fg-ink{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .fg-pct{ text-align:right; min-width:4ch; font-variant-numeric:tabular-nums; color:#cbd5e1; }
  .stack{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .flex{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .two-col{ display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .btn-connected{ background:#14532d; border-color:#22c55e; color:#bbf7d0; }
  @media (max-width:900px){ .app{ grid-template-columns:1fr; } .two-col{ grid-template-columns:1fr; } }

  /* Modal editor */
  .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index:50; }
  .modal{ width:min(720px, 96vw); max-height:90vh; overflow:auto; background:#10121a; border:1px solid #2a2f3a; border-radius:14px; padding:16px; }

  /* QC history modal wider */
  #cmpHistoryModal .modal{ width:min(950px, 96vw); }
  .modal h3{ margin:0 0 8px; }
  .edit-row{ display:grid; grid-template-columns: 1fr 100px 32px; gap:8px; align-items:center; }
  .pct-input{ text-align:right; font-variant-numeric:tabular-nums; }
  .rem-btn{ width:32px; height:38px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; border:1px solid #2a2f3a; background:#1a1f2b; cursor:pointer; }
  .add-row{ display:grid; grid-template-columns:1fr 120px auto; gap:8px; margin-top:8px; }
  .footer-row{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
  .note{ font-size:.85rem; color:#9aa2b3; }
  .mini{ font-size:.8rem; color:#9aa4b2; }
  .warn{ color:#fca5a5; }
  .ok{ color:#86efac; }

  /* Compare canvas wrapper */
  .canvasWrap{ margin-top:12px; background:#0f1219; border:1px solid #2a2f3a; border-radius:12px; overflow:hidden; }
  .legend{ display:flex; gap:12px; align-items:center; font-size:.9rem; color:#9aa4b2; padding:8px 10px; background:#0d1016; border-bottom:1px solid #242938; flex-wrap:wrap; }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid rgba(255,255,255,.25); }

  /* LAB 2D readout (a/b grid + L slider) */
  .labVizRow{ display:grid; grid-template-columns: 1fr 320px; gap:12px; padding:12px; align-items:start; }
  .lab3dWrap{ min-width:0; }
  @media (max-width: 980px){
    .labVizRow{ grid-template-columns: 1fr; }
    .labReadout{ width:100%; }
  }
  .labReadout{ background:#0d1016; border:1px solid #242938; border-radius:12px; padding:10px; }
  .labReadoutTitle{ font-size:0.95rem; font-weight:800; letter-spacing:.2px; }
  .labReadoutHdr{ display:flex; justify-content:space-between; align-items:baseline; gap:10px; margin-bottom:10px; }
  .labReadoutBody{ display:grid; grid-template-columns: 1fr 40px; gap:10px; align-items:stretch; }
  .abGridWrap{ position:relative; }
  #abCanvas{
    width:100%;
    aspect-ratio: 1 / 1;
    height:auto;
    display:block;
    border-radius:10px;
    border:1px solid #242938;
    background:#0f1219;
  }
  .abAxisLabel{
    position:absolute;
    font-size:12px;
    color:#9aa4b2;
    user-select:none;
    pointer-events:none;
  }
  .abAxisLabelX{ right:8px; bottom:6px; }
  .abAxisLabelY{ left:8px; top:6px; }

  .lReadoutWrap{ display:grid; grid-template-rows: 1fr auto; align-items:stretch; gap:6px; height:100%; }
  .lTrack{
    position:relative;
    width:40px;
    height:100%;
    min-height:0;
    max-height:none;
    border-radius:12px;
    border:1px solid #242938;
    background: transparent;
    overflow: visible;
  }
  .lTrack::before{
    content:'';
    position:absolute;
    inset:0;
    border-radius:12px;
    background: linear-gradient(to bottom, #ffffff, #000000);
    z-index:0;
  }
  .lTrack > *{ position:relative; z-index:2; }
  .lAxisLabel{ font-size:11px; opacity:.85; text-align:center; }
  .lMarker{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  width:10px;
  height:10px;
  border-radius:999px;
  border:2px solid rgba(0,0,0,.55);
  background:#e5e7eb;
  box-shadow: 0 0 0 1px rgba(255,255,255,.25) inset;
  pointer-events:none;
}
.lDot{ }
.lMarkerTag{
  position:absolute;
  left:50%;
  top:-24px;
  transform:translateX(-50%);
  font-size:11px;
  padding:2px 7px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(0,0,0,.35);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  color: inherit;
  line-height:1.2;
  white-space:nowrap;
  text-shadow: 0 1px 2px rgba(0,0,0,.65);
}
.lMarkerVal{
  position:absolute;
  left:50%;
  top:8px;
  transform:translateX(-50%);
  width:52px;
  text-align:center;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:11px;
  padding:2px 6px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(0,0,0,.35);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  color: inherit;
  line-height:1.2;
  white-space:nowrap;
  text-shadow: 0 1px 2px rgba(0,0,0,.65);
}
.labReadoutNums{ margin-top:10px; display:grid; gap:6px; }
  .labNumRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .labTag{
    font-size:11px;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
    white-space:nowrap;
    color:#e5e7eb;
  }
  .labNumsText{ font-size:12px; color:#e5e7eb; }
  @media (max-width: 980px){
    .labVizRow{ grid-template-columns: 1fr; }
    .lTrack{ height:260px; max-height:260px; }
  }

  /* Libraries */

  /* Libraries manager layout (Colour Sets tab) */
  .lib-manager{
    display:grid;
    grid-template-columns: 1fr 220px;
    gap:12px;
    margin-top:12px;
    align-items:stretch;
  }
  @media (max-width: 980px){
    .lib-manager{ grid-template-columns: 1fr; }
  }
  .lib-sidebar{
    border-left:1px solid #1f2430;
    padding-left:12px;
  }
  @media (max-width: 980px){
    .lib-sidebar{ border-left:none; padding-left:0; border-top:1px solid #1f2430; padding-top:12px; }
  }
  .lib-list{
    margin-top:0;
    border-top:none;
    padding-top:0;
  }
  .lib-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    padding:8px 8px;
    border:1px solid #1f2430;
    border-radius:12px;
    margin-bottom:8px;
    cursor:pointer;
    user-select:none;
  }
  .lib-item:hover{ border-color:#2a3142; background:#0f131b; }
  .lib-item.selected{ border-color:#3b82f6; box-shadow:0 0 0 1px rgba(59,130,246,.25) inset; }
  .lib-item .btn{ padding:6px 10px; }
  .lib-item-left{ min-width:0; }
  .lib-item-name{ font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:150px; }
  .lib-badge{ font-size:.75rem; color:#9aa4b2; margin-top:2px; }

  .lib-editor-pane{
    border:1px solid #1f2430;
    border-radius:16px;
    padding:12px;
    background:rgba(10,12,16,.35);
    min-height:520px;
    display:flex;
    flex-direction:column;
  }
  .lib-editor-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .lib-editor-title{
    font-size:1.05rem;
    font-weight:800;
    min-width:0;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .lib-editor-actions{ display:flex; gap:8px; align-items:center; }
  .btn.danger{ border-color:#7f1d1d; color:#fecaca; background:rgba(127,29,29,.15); }
  .btn.danger:hover{ background:rgba(127,29,29,.22); }
  .lib-colour-table-wrap{
    margin-top:12px;
    border:1px solid #1f2430;
    border-radius:14px;
    overflow:auto;
    flex:1;
    min-height:260px;
  }
  table.lib-colour-table{
    width:100%;
    border-collapse:collapse;
    font-size:.9rem;
  }
  table.lib-colour-table th, table.lib-colour-table td{
    padding:10px 10px;
    border-bottom:1px solid #1f2430;
    vertical-align:middle;
  }
  table.lib-colour-table th{
    position:sticky;
    top:0;
    background:#0b0e14;
    z-index:2;
    text-align:left;
    font-weight:800;
    color:#e5e7eb;
  }
  .lib-swatch{
    width:22px; height:22px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.18);
    box-shadow:0 6px 14px rgba(0,0,0,.35);
  }
  .lib-cell-flex{ display:flex; align-items:center; gap:10px; }
  .lib-row-input{
    width:100%;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid #1f2430;
    background:#0b0e14;
    color:#e5e7eb;
    outline:none;
  }
  .lib-row-input:focus{ border-color:#3b82f6; box-shadow:0 0 0 1px rgba(59,130,246,.25) inset; }
  .lib-row-num{ width:100px; font-variant-numeric:tabular-nums; }
  .lib-row-actions{ text-align:right; white-space:nowrap; }


  .de-pass{ color:#86efac; font-weight:800; }
  .de-fail{ color:#fca5a5; font-weight:800; }
  .de-neutral{ color:#e5e7eb; font-weight:800; }
  .wide{ max-width:1200px; margin:0 auto; }

  /* Fixed logo overlay (doesn't affect layout) */
  #pulseLogo{
    position:fixed;
    top: -16px;
    right:14px;
    display:none !important;
    z-index:1200;
    background:#ffffff;
    padding:12px 14px;
    border-radius:18px;
    box-shadow:0 10px 26px rgba(0,0,0,.45);
    pointer-events:none;

    /* Constrain image size */
    width:220px;
    height:auto;
    max-width:min(220px, calc(100vw - 28px));
    object-fit:contain;

    /* Hidden until nav-in */
    opacity:0;
    visibility:hidden;
    transform:translateY(-18px);
    transition:opacity 260ms ease, transform 260ms ease;
    will-change:opacity, transform;
  }
  body.nav-in #pulseLogo{
    visibility:visible;
    opacity:.92;
    transform:translateY(0);
  }
  @media (max-width: 520px){ #pulseLogo{ height:34px; top:10px; left:auto; } }

  .nowrap{ white-space:nowrap; }
  .hide{ display:none !important; }

  /* Simple combobox (input + always-available dropdown list)
     - Unlike <datalist>, we can keep showing ALL options even after typing.
     - Typing reorders matches to the top using a forgiving (non-exact) match. */
  .combo{ position:relative; }
  .combo-drop{
    position:absolute; left:0; right:0; top:calc(100% + 6px); z-index:60;
    max-height:260px; overflow:auto;
    background:#0e1015; border:1px solid #2a2f3a; border-radius:12px;
    box-shadow:0 10px 26px rgba(0,0,0,.45);
  }
  .combo-item{ padding:10px 12px; cursor:pointer; border-bottom:1px dashed #242938; }
  .combo-item:last-child{ border-bottom:none; }
  .combo-item:hover{ background:rgba(255,255,255,.06); }
  .combo-item .hit{ color:#e6e6e6; font-weight:700; }
  .combo-item .sub{ display:block; margin-top:2px; color:#7b8496; font-size:.8rem; }

  /* Batch (compare) inputs should not be editable */
  .batch-readonly{
    -webkit-text-fill-color: #e6e6e6;
  }
  .batch-readonly::-webkit-outer-spin-button,
  .batch-readonly::-webkit-inner-spin-button{
    -webkit-appearance: none;
    margin: 0;
  }
  .batch-readonly{
    -moz-appearance: textfield;
  }

  /* Narrower LAB inputs for clearer separation */
  .lab-input{ max-width:110px; }

  /* QC: tighten Standard/Batch LAB groups */
  #tab-compare .two-col{ gap:10px; }
  .lab-row{ grid-template-columns:repeat(3, auto); justify-content:start; column-gap:10px; }
  .lab-input{ max-width:95px; }

  /* QC: place swatches beside LAB inputs */
  .lab-with-swatch{ display:flex; align-items:flex-end; gap:10px; }
  .lab-with-swatch .swatch{ margin-bottom:2px; }
  /* QC: History button a bit larger */
  #cmpHistoryBtn{ padding:12px 16px; font-weight:700; }

  /* QC: subtle divider between Standard and Batch */
  #tab-compare .two-col{
    position: relative;
  }
  #tab-compare .two-col::after{
    content:'';
    position:absolute;
    top:0;
    bottom:0;
    left:43%;
    width:1px;
    background: linear-gradient(
      to bottom,
      transparent,
      rgba(255,255,255,0.08),
      transparent
    );
    pointer-events:none;
  }

  /* Hide divider when Standard/Batch stack vertically */
  @media (max-width: 900px){
    #tab-compare .two-col::after{ display:none; }
  }

  /* Settings tab: consistent spacing between cards */
  #tab-settings .card{ margin-top:16px; }
  #tab-settings .card:first-child{ margin-top:0; }


  /* Splash / landing */
  /* Splash vignette */
  .app-hidden{ display:none; }
  .splash{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#0b0c10;
    background:
      radial-gradient(900px 520px at 50% 44%, rgba(255,255,255,.06), transparent 60%),
      #0b0c10;
    z-index:2000;
    transition: opacity 260ms ease;
  }

  .splash-inner{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:14px;
    padding:24px;
    text-align:center;
  }
  .splash-btn{
    border:none;
    background:transparent;
    padding:0;
    cursor:pointer;
    border-radius:24px;
    outline:none;
  }
  .splash-btn:focus-visible{
    box-shadow:0 0 0 3px rgba(255,255,255,.18), 0 0 0 6px rgba(34,197,94,.15);
  }
  .splash-imgWrap{
    position:relative;
    width:min(440px, 84vw);
    aspect-ratio:1 / 1;
    display:block;
    /* Let the shutter halves slide beyond the bounds (no clipping) */
    overflow:visible;
    /* Make it feel like the logo is floating, not contained */
    border-radius:0;
    background:transparent;
    transform:translateZ(0);
  }
  .splash-img{
    width:100%;
    height:100%;
    object-fit:contain;
    display:block;
    user-select:none;
    pointer-events:none;
    /* Keep the base image hidden; shutter halves provide the visual */
    opacity:0;
  }
  .splash-half{
    position:absolute;
    inset:0;
    background-image: var(--splash-img);
    background-size:100% 100%;
    background-repeat:no-repeat;
    will-change:transform, opacity;
    border-radius:28px;
    filter:drop-shadow(0 18px 44px rgba(0,0,0,.55));
    transition:transform 570ms cubic-bezier(.2,.9,.2,1), opacity 390ms ease;
  }
  .splash-left{ clip-path:inset(0 50% 0 0); background-position:left center; }
  .splash-right{ clip-path:inset(0 0 0 50%); background-position:right center; }

  .splash-btn:hover .splash-imgWrap{ filter:brightness(1.06); }
  .splash-btn:hover .splash-img{ transform:translateY(-2px); transition:transform 220ms ease; }
  .splash-btn:active .splash-img{ transform:translateY(0px) scale(.985); }

  .splash-title{
    font-weight:900;
    letter-spacing:.12em;
    font-size:clamp(1.74rem, 3.36vw, 2.40rem);
  }
  .splash-hint{ color:#9aa4b2; font-size:1.02rem; opacity:.92; }

  .splash.exiting .splash-left{ transform:translateX(-110%); opacity:0; }
  .splash.exiting .splash-right{ transform:translateX(110%); opacity:0; }
  .splash.exiting .splash-title,
  .splash.exiting .splash-hint{
    opacity:0;
    transform:translateY(6px);
    transition:opacity 210ms ease, transform 210ms ease;
  }
  @media (prefers-reduced-motion: reduce){
    .splash-half{ transition:none; }
    .splash-img{ opacity:1; filter:drop-shadow(0 18px 44px rgba(0,0,0,.55)); }
    .splash.exiting .splash-left,
    .splash.exiting .splash-right{ transform:none; opacity:0; }
  }


    /* Smooth app reveal after splash */
  #appRoot{
    opacity:0;
    transform:translateY(6px);
    transition:opacity 250ms ease, transform 250ms ease;
  }
  body.app-ready #appRoot{
    opacity:1;
    transform:none;
  }


  /* Splash container fade */
  .splash.exiting{
    opacity:0;
    transition-delay:360ms;
  }

  /* Safeguard: appbar should not be hidden */
  .appbar{ opacity:1; transform:none; }


.out{display:flex; align-items:center; min-height:38px; padding:0 10px; border:1px solid rgba(255,255,255,0.12); border-radius:10px; background:rgba(255,255,255,0.04); color:#e6e6e6;}
.out.miniout{min-height:30px; font-size:12px;}

/* Mixing Guide: calculator layout + emphasis */
.mix-calc-card{
  padding:12px;
  margin-top:10px;
}
.mix-calc-grid{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap:12px;
  margin-top:10px;
  align-items:end;
}
.mix-inkreq-row{
  display:flex;
  gap:12px;
  margin-top:12px;
  align-items:stretch;
  flex-wrap:wrap;
}
.mix-inkreq-display{
  flex: 1 1 220px;
  border:1px solid var(--border);
  border-radius:10px;
  padding:10px 12px;
  background: rgba(255,255,255,0.02);
}
.mix-inkreq-label{
  font-size:12px;
  color: var(--muted);
  margin-bottom:6px;
}
.mix-inkreq-value{
  font-size:22px;
  font-weight:700;
  line-height:1.1;
}
.mix-inkreq-btn{
  flex: 0 0 auto;
  align-self:stretch;
  min-width: 220px;
}
.mix-swatch{
  width: 44px;
  height: 34px;
  border-radius:10px;
  border:1px solid var(--border);
  background: transparent;
}

  /* Mixing guide top inputs: allow 4-up on desktop */
  .mix-top-grid{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--gap);
    align-items: end;
  }
  /* Slightly slimmer controls in mixing guide top area */
  #tab-mix .mix-top-grid select,
  #tab-mix .mix-top-grid input{
    min-width: 0;
  }




  /* Readout layout tweaks (spacing + size) */
  .labVizRow{ grid-template-columns: 1fr 360px; align-items:start; }
  .labReadout{ padding:8px; }
  .labReadoutBody{ grid-template-columns: 1fr 44px; align-items:stretch; }

  .lReadoutWrap{ height:100%; gap:4px; justify-content:stretch; }
  .lTrack{ flex: 1 1 auto; height:auto; max-height:none; min-height:0; }

  .labReadoutNums{ margin-top:8px; }

  @media (max-width: 980px){
    .lTrack{ flex: 1 1 auto; height:auto; }
  }

</style>
</head>
<body>

  <!-- Splash / landing screen -->
  <div id="splash" class="splash" role="dialog" aria-label="Colour Bar landing screen" aria-modal="true">
    <div class="splash-inner">
      <button id="splashBtn" class="splash-btn" type="button" aria-label="Enter Colour Bar">
        <span class="splash-imgWrap" aria-hidden="true">
          <span class="splash-half splash-left"></span>
          <span class="splash-half splash-right"></span>
          <img class="splash-img" src="./ColourBarLogo.png" alt="" draggable="false">
        </span>
      </button>
      <div class="splash-title" aria-hidden="true">COLOUR BAR</div>
      <div class="splash-hint">Click the logo to enter</div>
    </div>
  </div>
  <img id="pulseLogo" src="PulseLogo.png" alt="Pulse" />


  <div id="appRoot" class="app-hidden">
  <div class="appbar">
    <div class="appbar-inner">
      <div class="app-title"><span>Colour Bar</span></div>
      <div class="tabs" role="tablist" aria-label="Modes">
    <button class="tabbtn" id="tabBtnMatch" role="tab" aria-selected="true" aria-controls="tab-match">Match &amp; Predict</button>
    <button class="tabbtn" id="tabBtnMix" role="tab" aria-selected="false" aria-controls="tab-mix">Mixing guide</button>
    <button class="tabbtn" id="tabBtnCompare" style="min-width:102px" role="tab" aria-selected="false" aria-controls="tab-compare">QC</button>
        
<button class="tabbtn" id="tabBtnSettings" role="tab" aria-selected="false" aria-controls="tab-settings">Settings</button>
</div>
    </div>
  </div>

  <!-- TAB: Match & Predict -->
  <section id="tab-match" role="tabpanel" aria-labelledby="tabBtnMatch">
    <div class="app">
      <div class="card">
        <div class="top" style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap: wrap;">
          <div>
            <h1>Ink Colour Matcher</h1>
            <div class="pill">Active library: <span id="activeLibLabel">Pantone</span></div>
          </div>
          <div style="min-width:200px;">
            <label for="librarySelect">Colour library</label>
            <select id="librarySelect"></select>
          </div>
          <div class="pill" id="refCountPill"><span id="countLabel">0</span> colours</div>
        </div>

        <div class="row" style="margin-top:12px;">
          <div><label for="L">L*</label><input id="L" type="number" step="0.01" placeholder="e.g. 52.30"></div>
          <div><label for="a">a*</label><input id="a" type="number" step="0.01" placeholder="e.g. 12.80"></div>
          <div><label for="b">b*</label><input id="b" type="number" step="0.01" placeholder="e.g. -4.10"></div>
        </div>
        <div class="flex" style="margin-top:12px; gap:8px;">
          <button class="btn" id="spectroConnectBtnMatch">Connect device</button>
          <button class="btn" id="spectroScanTargetBtn">Scan target</button>
        </div>

        <div class="row2" style="margin-top:12px;">
          <div>
            <label class="nowrap">Or select colour (from active library)</label>
            <div class="combo">
              <input id="matchColourSelect" placeholder="Type to search…" autocomplete="off">
              <div id="matchColourDrop" class="combo-drop hide" role="listbox" aria-label="Colour options"></div>
            </div>
          </div>
          <div></div>
        </div>

        <div class="flex" style="margin-top:12px;">
          <button class="btn" id="findBtn">Find closest match</button>
          <button class="btn" id="clearBtn">Clear</button>
          <span class="muted" id="statusMsg" aria-live="polite"></span>
        </div>

        <div class="formula-box" id="predictorBox">
          <h2>Suggest Formula</h2>
          <div class="row2" style="margin-bottom:8px;">
            <div>
              <label for="groupSelect">Colour group (optional)</label>
              <select id="groupSelect"><option value="">— none —</option></select>
            </div>
            <div></div>
          </div>
          <div class="flex">
            <button class="btn" id="suggestBtn">Suggest Formula</button>
            <div id="predictMsg" class="muted" style="align-self:center;"></div>
          </div>
          <div id="suggestedFormula" class="formula-box" style="display:none; margin-top:12px;"></div>
          <div class="flex" id="editRow" style="display:none; margin-top:8px;">
            <button class="btn" id="editFormulaBtn">Edit formula</button>
            <span class="mini">Adjust, add/remove inks, then save correction to training log.</span>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;">
          <h1>Closest Matches</h1>
          <div class="stack" style="align-items:center;">
            <div class="swatch" id="targetSwatch" title="Target"></div>
            <div class="muted" id="targetEcho">Target: –</div>
          </div>
        </div>
        <table>
          <thead>
            <tr><th>Colour</th><th>Swatch</th><th>L*</th><th>a*</th><th>b*</th><th>Distance</th></tr>
          </thead>
          <tbody id="resultsTbody"></tbody>
        </table>
        <div id="formulaPanel" class="formula-box" style="display:none;"></div>
      </div>
    </div>
  </section>

  <!-- TAB: Compare Colours -->
  <section id="tab-compare" role="tabpanel" aria-labelledby="tabBtnCompare" hidden>
    <div class="card" style="max-width:1200px; margin:0 auto;">
      <div class="flex" style="justify-content:space-between;">
        <div>
          <h1>Compare Colours (ΔE2000)</h1>
          <div class="pill">Using library: <span id="cmpLibLabel">Pantone</span></div>
        </div>
      </div>

      
      <div class="row2" style="margin-top:12px; align-items:end;">
        <div style="max-width:360px;">
          <label for="cmpLibrarySelect">Colour library</label>
          <select id="cmpLibrarySelect"></select>
        </div>
        <div></div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="cmpJobRefTop">Job reference</label>
          <input id="cmpJobRefTop" type="text" placeholder="e.g. JOB-12345">
        </div>
      </div>

<div class="flex" style="margin-top:8px;">
        <button class="btn" id="spectroConnectBtnCompare">Connect device</button>
        <span class="mini"></span>
      </div>

      <div class="two-col" style="margin-top:12px;">
        <div>
          <div class="row2">
            <div>
              <label for="cmpASelect" class="nowrap">Pick Standard (from active library)</label>
              <div class="combo">
                <input id="cmpASelect" placeholder="Type to search…" autocomplete="off">
                <div id="cmpADrop" class="combo-drop hide" role="listbox" aria-label="Standard options"></div>
              </div>
            </div>
            <div>
              <label class="nowrap">Or scan</label>
              <button class="btn" id="spectroScanCompareABtn">Scan Standard</button>
            </div>
          </div>
          <div class="lab-with-swatch" style="margin-top:12px;">
            <div class="row lab-row" style="margin-top:0;">
            <div><label for="AL" class="nowrap">Standard: L*</label><input id="AL" type="number" step="0.01" class="lab-input"></div>
            <div><label for="Aa" class="nowrap">Standard: a*</label><input id="Aa" type="number" step="0.01" class="lab-input"></div>
            <div><label for="Ab" class="nowrap">Standard: b*</label><input id="Ab" type="number" step="0.01" class="lab-input"></div>
          </div>
            <div class="swatch" id="swatchA"></div>
          </div>
          
        </div>
        <div>
          <div>
            <label class="nowrap" style="font-size:1rem; font-weight:700;">Batch</label>
            <div style="margin-top:6px;">
              <button class="btn" id="spectroScanCompareBBtn">Scan Batch</button>
            </div>
          </div>
          <div class="lab-with-swatch" style="margin-top:12px;">
            <div class="row lab-row" style="margin-top:0;">
            <div><label for="BL" class="nowrap">Batch: L*</label><input id="BL" type="number" step="0.01" class="lab-input"></div>
            <div><label for="Ba" class="nowrap">Batch: a*</label><input id="Ba" type="number" step="0.01" class="lab-input"></div>
            <div><label for="Bb" class="nowrap">Batch: b*</label><input id="Bb" type="number" step="0.01" class="lab-input"></div>
          </div>
            <div class="swatch" id="swatchB"></div>
          </div>
          
        </div>
      </div>

      <div class="formula-box" id="cmpResult" style="display:none; margin-top:12px;">
        <h2 style="margin-bottom:6px;">Result</h2>
        <div id="cmpNumbers" style="font-size:1.05rem;"></div>
        <div class="muted" style="margin-top:6px;">
          <small>Guideline: ΔE00 &lt; 1.0 ≈ barely perceptible • &lt; 2.0 ≈ good • 2–3.5 borderline • &gt; 3.5 poor</small>
        </div>
      
      <div class="formula-box" id="cmpSaveBox" style="margin-top:12px;">
        <h2 style="margin-bottom:6px;">Save this comparison</h2>
        <div class="row">
          <div>
            <label for="cmpJobRef">Job reference</label>
            <input id="cmpJobRef" type="text" placeholder="e.g. JOB-12345">
          </div>
<div style="align-self:end;">
            <button class="btn" id="cmpSaveBtn">Save result</button>
          </div>
        </div>
        <div class="mini" id="cmpSaveMsg" style="margin-top:6px;"></div>
      </div>

      <div class="flex" style="margin-top:10px; justify-content:flex-start;">
        <button class="btn" id="cmpHistoryBtn">History</button>
      </div>

</div>

      <div class="canvasWrap">
        <div class="legend">
          <span class="nowrap">Standard:</span><span id="legendA" class="dot"></span>
          <span style="margin-left:10px;" class="nowrap">Batch:</span><span id="legendB" class="dot"></span>
          <span style="margin-left:auto;"></span>
          <button class="btn" id="resetView">Reset view</button>
          <span style="font-size:.8rem; opacity:.8;">Drag to rotate</span>
        </div>

        <div class="labVizRow">
          <div class="lab3dWrap">
            <canvas id="labCanvas" width="1100" height="520" style="display:block; width:100%; height:auto;"></canvas>
          </div>

          <aside class="labReadout" aria-label="Readout">
<div class="labReadoutBody">
              <div class="abGridWrap">
                <canvas id="abCanvas" width="280" height="280"></canvas>
                <div class="abAxisLabel abAxisLabelY">b*</div>
                <div class="abAxisLabel abAxisLabelX">a*</div>
              </div>

              <div class="lReadoutWrap">
                <div class="lTrack" id="lTrack">
                  <div class="lMarker lDot" id="lMarkerA" title="Std"></div>
                  <div class="lMarker lDot" id="lMarkerB" title="Batch"></div>
                </div>
                <div class="lAxisLabel">L*</div>
              </div>
            </div>

            <div class="labReadoutNums">
              <div class="labNumRow">
                <span class="labTag" id="labTagA">Std</span>
                <span class="mono labNumsText" id="labNumsA">L —  a —  b —</span>
              </div>
              <div class="labNumRow">
                <span class="labTag" id="labTagB">Batch</span>
                <span class="mono labNumsText" id="labNumsB">L —  a —  b —</span>
              </div>
            </div>
          </aside>
        </div>
      </div>
    </div>
  </section>

  

  <!-- TAB: Mixing guide -->
  <section id="tab-mix" role="tabpanel" aria-labelledby="tabBtnMix" hidden>
    <div class="card" style="max-width:1200px; margin:0 auto;">
      <div class="mix-top-grid" style="margin-top:12px;">
        <div>
          <label for="mixInkRange">Ink range</label>
          <select id="mixInkRange">
            <option value="A" selected>PureTone (FPC UV PT121)</option>
            <option value="B">PureTone (STD UV PT120)</option>
            <option value="C">PureTone (Water Based)</option>
            <option value="D">PureTone DC</option>
          </select>
        </div>
        <div>
          <label for="mixAnilox">Anilox / film thickness</label>
          <select id="mixAnilox">
            <option value="4v">4v</option>
            <option value="5v">5v</option>
            <option value="6v" selected>6v</option>
            <option value="7v">7v</option>
          </select>
        </div>
        <div>
          <label class="nowrap">Pantone</label>
          <div class="combo">
            <input id="mixPantoneSelect" placeholder="Type to search…" autocomplete="off">
            <div id="mixPantoneDrop" class="combo-drop hide" role="listbox" aria-label="Pantone options"></div>
          </div>
        </div>
        <div>
          <label for="mixQtyKg">Quantity required (kg)</label>
          <input id="mixQtyKg" type="number" step="0.001" value="1">
</div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="mixDeltaE">Best match prediction (ΔE)</label>
          <div id="mixDeltaE" class="out">—</div>
        </div>
        <div>
          <div id="mixPantoneSwatch" class="mix-swatch" style="margin-top: 26px; aria-label="Selected Pantone swatch"></div>
        </div>

        <div style="grid-column: 1 / -1;">
          <div style="grid-column: 1 / -1;">
  <div class="card mix-calc-card">
    <div class="flex" style="justify-content:space-between; align-items:center; gap:10px;">
      <h2 style="margin:0; font-size:16px;">Ink requirement calculator</h2>
    </div>

    <div class="mix-calc-grid">
      <div>
        <label for="mixLinearM">Linear metres</label>
        <input id="mixLinearM" type="number" step="1" value="1000">
      </div>

      <div>
        <label for="mixWebWidth">Web width (mm)</label>
        <input id="mixWebWidth" type="number" step="1" value="1000">
      </div>

      <div>
        <label for="mixCoverage">% coverage</label>
        <input id="mixCoverage" type="number" step="0.1" value="100">
      </div>

      <div>
        <label>Square meters</label>
        <div id="mixSquareM" class="out">—</div>
      </div>

      <div>
        <label>Anilox volume</label>
        <div id="mixAniloxVol" class="out">—</div>
      </div>
    </div>

    <div class="mix-inkreq-row">
      <div class="mix-inkreq-display">
        <div class="mix-inkreq-label">Ink required</div>
        <div id="mixInkReq" class="mix-inkreq-value">—</div>
      </div>

      <button class="btn mix-inkreq-btn" id="mixCopyInkReq" type="button">Set as Quantity Required (kg)</button>
    </div>
  </div>
</div>

<div class="formula-box" style="margin-top:12px;">
        <h2>Formula</h2>
        <table>
          <thead>
            <tr><th>Ink</th><th style="text-align:right;">%</th><th style="text-align:right;">g</th></tr>
          </thead>
          <tbody id="mixFormulaTbody"></tbody>
        </table>
</div>
    </div>
  </section>

<!-- TAB: Settings -->
  <section id="tab-settings" role="tabpanel" aria-labelledby="tabBtnSettings" hidden>

    <!-- Moved here: Colour Sets (Libraries) -->
<div class="card" style="max-width:1200px; margin:0 auto;">
      <h1>Colour Sets (Libraries)</h1>
      <p class="muted">
        Upload your own colour sets. Each set becomes a selectable library
        in the <strong>Match &amp; Predict</strong> and <strong>Compare Colours</strong> tabs.
      </p>
      <p class="muted" style="margin-top:6px;">
        <strong>CSV format:</strong> first row as headers. Required columns: <code>Name</code>, <code>L</code>,
        <code>a</code>, <code>b</code> (or <code>L*</code>, <code>a*</code>, <code>b*</code>).
      </p>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="libName">Library name</label>
          <input id="libName" type="text" placeholder="e.g. Customer ACME Spot Colours">
        </div>
        <div>
          <label for="libFile">CSV file</label>
          <input id="libFile" type="file" accept=".csv,text/csv">
        </div>
      </div>

      <div class="flex" style="margin-top:12px;">
        <button class="btn" id="libAddBtn">Add library</button>
        <button class="btn" id="libTemplateBtn">Download example CSV</button>
        <span class="mini">Files stay local to this browser (saved in localStorage).</span>
      </div>

      <div class="lib-manager">
        <div class="lib-editor-pane" id="libEditorPane">
          <div class="lib-editor-header">
            <div class="lib-editor-title" id="libEditorTitle">Select a library</div>
            <div class="lib-editor-actions">
              <button class="btn" id="libExportBtn" disabled>Export CSV</button>
              <button class="btn danger" id="libDeleteBtn" disabled>Delete</button>
            </div>
          </div>

          <div class="row2" style="margin-top:12px;">
            <div>
              <label for="libColourName">Name</label>
              <input id="libColourName" type="text" placeholder="e.g. Warm Red">
            </div>
            <div class="flex" style="align-items:flex-end; justify-content:flex-end; gap:8px;">
              <button class="btn" id="libScanBtn" disabled>Scan</button>
              <button class="btn" id="libAddColourBtn" disabled>Add</button>
            </div>
          </div>

          <div class="row3" style="margin-top:10px;">
            <div>
              <label for="libColourL">L*</label>
              <input id="libColourL" type="number" step="0.01" placeholder="50.00">
            </div>
            <div>
              <label for="libColourA">a*</label>
              <input id="libColourA" type="number" step="0.01" placeholder="0.00">
            </div>
            <div>
              <label for="libColourB">b*</label>
              <input id="libColourB" type="number" step="0.01" placeholder="0.00">
            </div>
          </div>

          <div class="mini" id="libEditorHint" style="margin-top:10px;">
            Click a library on the right to view/edit.
          </div>

          <div class="lib-colour-table-wrap" id="libColourTableWrap">
            <!-- Populated in JS -->
          </div>
        </div>

        <div class="lib-sidebar">
          <div class="lib-list" id="libList">
            <!-- Populated in JS -->
          </div>
        </div>
      </div>

</div>

    <!-- Spectro capture lives ONLY on this tab -->
    <div class="card" style="max-width:1200px; margin:16px auto 0;">
      <h1>Capture Ink Curves from Spectro</h1>
      <p class="muted">
        Connect the SKZ-SY3060, measure a patch, and store the full 400–700&nbsp;nm reflectance curve along with
        the ink name and concentration for later Kubelka–Munk modelling.
      </p>

      <div class="formula-box" id="spectroBox" style="margin-top:12px;">
        <h2>Device connection &amp; capture</h2>

        <div class="row2" style="margin-bottom:8px;">
          <div>
            <label for="spectroInkName">Ink name</label>
            <input id="spectroInkName" type="text" placeholder="e.g. Red Base">
          </div>
          <div>
            <label for="spectroConcentration">Concentration %</label>
            <input id="spectroConcentration" type="number" step="0.01" placeholder="0.10">
          </div>
        </div>

        <div class="row2" style="margin-bottom:8px;">
          <div>
            <label for="spectroBacking">Backing</label>
            <select id="spectroBacking">
              <option value="white" selected>White backing</option>
              <option value="black">Black backing</option>
            </select>
          </div>
          <div>
            <label for="spectroAngle">Observer angle</label>
            <select id="spectroAngle">
              <option value="2" selected>2°</option>
              <option value="10">10°</option>
            </select>
          </div>
        </div>

        <div class="row2" style="margin-bottom:8px;">
          <div>
            <label for="spectroIlluminant">Illuminant</label>
            <select id="spectroIlluminant">
              <option value="D50" selected>D50</option>
              <option value="D65">D65</option>
              <option value="A">A</option>
            </select>
          </div>
          <div>
            <label for="spectroAperture">Aperture</label>
            <select id="spectroAperture">
              <option value="8mm" selected>8 mm</option>
              <option value="4mm">4 mm</option>
            </select>
          </div>
        </div>

        <div class="row2" style="margin-bottom:8px;">
          <div>
            <label for="spectroGeometry">Geometry</label>
            <select id="spectroGeometry">
              <option value="SCI" selected>SCI</option>
              <option value="SCE">SCE</option>
            </select>
          </div>
          <div>
            <label>Timestamp</label>
            <input id="spectroTimestampPreview" type="text" readonly class="mono" placeholder="Set when measured">
          </div>
        </div>

        <div class="flex">
          <button class="btn" id="spectroConnectBtn">Connect device</button>
          <button class="btn" id="spectroMeasureBtn">Measure &amp; store curve</button>
          <button class="btn" id="spectroExportBtn">Download CSV</button>
          <span class="mini" id="spectroStatus" style="margin-left:auto;"></span>
        </div>
        <div class="mini" style="margin-top:6px;">
          
        </div>
      </div>

      <div class="formula-box" style="margin-top:12px;">
        <h2>Stored ink curves</h2>
        <p class="mini" style="margin-bottom:6px;">
          These rows are stored locally in this browser (localStorage). You can edit the ink name, concentration and
          metadata, or delete rows. The CSV export uses these values together with the full spectral curve.
        </p>
        <div style="max-height:260px; overflow:auto; border:1px solid #1f2933; border-radius:10px;">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Swatch</th>
                <th>Ink name</th>
                <th>Conc</th>
                <th>Backing</th>
                <th>Angle</th>
                <th>Illum</th>
                <th>Aperture</th>
                <th>Geom</th>
                <th>L*</th>
                <th>a*</th>
                <th>b*</th>
                <th>Timestamp</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="inkCurvesTbody">
              <!-- Filled by JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="card wide">
      <h1>Settings</h1>
      <p class="muted">
        These settings are saved locally in this browser (simulating customer-specific preferences).
      </p>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="setDeltaEThreshold">ΔE2000 pass/fail threshold</label>
          <input id="setDeltaEThreshold" type="number" step="0.1" min="0" placeholder="2.0">
          <div class="mini" style="margin-top:6px;">Used to colour the Compare result and decide Pass/Fail.</div>
        </div>
        <div>
          <label for="setAutoSaveCompare">Auto-save compare results</label>
          <select id="setAutoSaveCompare">
            <option value="1">On</option>
            <option value="0">Off</option>
          </select>
          <div class="mini" style="margin-top:6px;">If on, each time you calculate ΔE it will be logged automatically (requires Job reference).</div>
        </div>
      </div>

      <div class="flex" style="margin-top:12px;">
        <button class="btn" id="saveSettingsBtn">Save settings</button>
        <button class="btn" id="resetSettingsBtn">Reset to defaults</button>
        <span class="mini" id="settingsStatus" style="margin-left:auto;"></span>
      </div>
    </div>


<div class="card" style="max-width:1200px; margin:16px auto 0;">
  <div class="flex" style="justify-content:space-between; align-items:center; gap:10px;">
    <h2 style="margin:0;">Training export</h2>
    <button class="btn" id="downloadTrainingCanonicalBtn">Download CSV</button>
  </div>
  <div class="mini" id="trainingExportStatus" style="margin-top:6px;"></div>
</div>
  </section>

<!-- Modal: Edit Formula -->
  <div class="modal-backdrop" id="editModal">
    <div class="modal">
      <h3>Edit formula</h3>
      <div class="mini" id="editContext"></div>
      <div id="editList" style="margin-top:8px; display:grid; gap:6px;"></div>
      <div class="add-row">
        <select id="addInkSel"></select>
        <input id="addPct" type="number" step="0.01" placeholder="% add" class="pct-input mono">
        <button class="btn" id="addInkBtn">Add ink</button>
      </div>
      <div class="two-col" style="margin-top:8px;">
        <div class="note">Total: <span id="totalPct">0.00</span>% — <span id="totalState" class="warn">needs normalising</span></div>
        <div class="flex" style="justify-content:flex-end;">
          <button class="btn" id="normaliseBtn">Normalise to 100%</button>
        </div>
      </div>
      <div style="margin-top:8px;">
        <label for="corrNote">Optional note</label>
        <textarea id="corrNote" placeholder="e.g., +1.5% black to drop L*, swapped Yellow→Orange bias, etc."></textarea>
      </div>
      <div class="footer-row">
        <button class="btn" id="cancelEdit">Cancel</button>
        <button class="btn" id="saveCorrection">Save correction</button>
      </div>
    </div>
  </div>

  <!-- Modal: QC comparison history -->
  <div class="modal-backdrop" id="cmpHistoryModal">
    <div class="modal">
      <div class="flex" style="justify-content:space-between; align-items:center; gap:8px;">
        <h3 style="margin:0;">QC history</h3>
        <button class="btn" id="cmpHistoryClose">Close</button>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="histFrom">From date</label>
          <input id="histFrom" type="date">
        </div>
        <div>
          <label for="histTo">To date</label>
          <input id="histTo" type="date">
        </div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="histJob">Job contains</label>
          <input id="histJob" type="text" placeholder="e.g. JOB-123">
        </div>
        <div>
          <label for="histStandard">Standard contains</label>
          <input id="histStandard" type="text" placeholder="e.g. 186">
        </div>
      </div>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="histLibrary">Library</label>
          <select id="histLibrary"></select>
        </div>
        <div>
          <label for="histSort">Sort</label>
          <select id="histSort">
            <option value="date_desc" selected>Newest first</option>
            <option value="date_asc">Oldest first</option>
            <option value="job_asc">Job A→Z</option>
            <option value="std_asc">Standard A→Z</option>
            <option value="de_asc">ΔE low→high</option>
            <option value="de_desc">ΔE high→low</option>
          </select>
        </div>
      </div>

      <div class="flex" style="margin-top:12px; justify-content:space-between;">
        <div class="mini" id="histCount"></div>
        <div class="flex">
          <button class="btn" id="cmpExportLogBtn">Download CSV</button>
          <button class="btn" id="cmpClearLogBtn">Clear</button>
        </div>
      </div>

      <div style="max-height:52vh; overflow:auto; border:1px solid #1f2933; border-radius:10px; margin-top:10px;">
        <table>
          <thead>
            <tr>
              <th>Date</th>
              <th>Job</th>
              <th>Standard</th>
              <th>Library</th>
              <th>Standard</th>
              <th>Batch</th>
              <th>ΔE2000</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody id="cmpLogTbody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
(function(){
'use strict';
function $(sel){ return document.querySelector(sel); }
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
function approx(a,b,eps){ if (eps==null) eps=1e-3; return Math.abs(a-b) <= eps; }

const API_BASE = 'https://ink-predict-api.onrender.com'; // <- your Render URL

// ===== Colour math =====
function labToXyz(L,a,b){
  const Yn=1, Xn=0.95047, Zn=1.08883, fy=(L+16)/116;
  const fx=f=> f>0.206893?f*f*f:(f-16/116)/7.787;
  return { X: fx((a/500)+fy)*Xn, Y: fx(fy)*Yn, Z: fx(fy-(b/200))*Zn };
}
function labToSrgb(L,a,b){
  const xyz = labToXyz(L,a,b);
  const X = xyz.X, Y = xyz.Y, Z = xyz.Z;
  let r =  3.2406*X -1.5372*Y -0.4986*Z;
  let g = -0.9689*X +1.8758*Y +0.0415*Z;
  let b2=  0.0557*X -0.2040*Y +1.0570*Z;
  const lin=[r,g,b2].map(v=> v<=0.0031308?12.92*v:1.055*Math.pow(v,1/2.4)-0.055);
  r=clamp(Math.round(lin[0]*255),0,255);
  g=clamp(Math.round(lin[1]*255),0,255);
  b2=clamp(Math.round(lin[2]*255),0,255);
  return { r, g, b: b2 };
}
function hp(x,y){ const h=Math.atan2(y,x)*180/Math.PI; return (h>=0?h:h+360); }
function deltaE2000(c1,c2){
  const L1=c1.L,a1=c1.a,b1=c1.b, L2=c2.L,a2=c2.a,b2=c2.b, d2r=Math.PI/180;
  const avgLp=(L1+L2)/2, C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2), avgC=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2, C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2), avgCp=(C1p+C2p)/2;
  const h1p=hp(a1p,b1), h2p=hp(a2p,b2), avgHp = Math.abs(h1p-h2p)>180 ? (h1p+h2p+360)/2 : (h1p+h2p)/2;
  const T = 1 - 0.17*Math.cos((avgHp-30)*d2r) + 0.24*Math.cos((2*avgHp)*d2r) + 0.32*Math.cos((3*avgHp+6)*d2r) - 0.20*Math.cos((4*avgHp-63)*d2r);
  let dHp = h2p - h1p; if (dHp>180) dHp-=360; if (dHp<-180) dHp+=360;
  const dLp = L2 - L1, dCp = C2p - C1p, dHp_rad = 2*Math.sqrt(C1p*C2p)*Math.sin((dHp*d2r)/2);
  const Sl = 1 + (0.015*Math.pow(avgLp-50,2))/Math.sqrt(20 + Math.pow(avgLp-50,2)), Sc = 1 + 0.045*avgCp;
  const Sh = 1 + 0.015*avgCp*T;
  const Rc=2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7)));
  const Rt=-Rc*Math.sin(2*(30*Math.exp(-Math.pow((avgHp-275)/25,2)))*d2r);
  return Math.sqrt(Math.pow(dLp/Sl,2) + Math.pow(dCp/Sc,2) + Math.pow(dHp_rad/Sh,2) + Rt*(dCp/Sc)*(dHp_rad/Sh));
}

// ===== State =====
let BASE_COLOURS = [];   // built-in Pantone set
let COLOURS = [];        // active library view
let FORMULAS = {};
let FORMULAS_NORM = {};
let COLOUR_TO_FORMULA = {};
let _lastSuggestion = null;
let _lastContextName = null;
let _allInks = [];


// ===== Canonical ink order for training export / logging =====
// This matches the column order used by the existing training CSV.
// If the API ever adds extra inks, they will be appended after these.
const CANONICAL_INK_ORDER = [
  'DC21-001 Extender',
  'DC21-101 Bright Red',
  'DC21-102 Rubine',
  'DC21-114 Rhodamine',
  'DC21-201 Orange',
  'DC21-304 Yellow',
  'DC21-402 Green',
  'DC21-501 Process Blue',
  'DC21-604 Violet',
  'DC21-802 Black'
];

function getCanonicalInks(){
  const apiInks = Array.isArray(_allInks) ? _allInks.slice() : [];
  if (!apiInks.length) return CANONICAL_INK_ORDER.slice();
  const apiSet = new Set(apiInks);
  const hasAllCanonical = CANONICAL_INK_ORDER.every(n=>apiSet.has(n));
  if (!hasAllCanonical) return apiInks.slice().sort();
  const extras = apiInks.filter(n=>!CANONICAL_INK_ORDER.includes(n)).slice().sort();
  return CANONICAL_INK_ORDER.concat(extras);
}

function expandFormulaToCanonical(formulaObj, canonicalInks){
  const out = {};
  (canonicalInks||[]).forEach(ink=>{
    out[ink] = 0;
  });
  const src = (formulaObj && typeof formulaObj === 'object') ? formulaObj : {};
  Object.entries(src).forEach(([k,v])=>{
    if (!Object.prototype.hasOwnProperty.call(out,k)) return; // ignore unknown inks
    const n = +v;
    out[k] = Number.isFinite(n) ? +n.toFixed(2) : 0;
  });
  return out;
}

function csvEscape(v){
  const s = (v==null) ? '' : String(v);
  if (/[",\r\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
  return s;
}

function parseCsv(text){
  const rows = [];
  let row = [];
  let field = '';
  let inQuotes = false;
  for (let i=0;i<text.length;i++){
    const c = text[i];
    if (inQuotes){
      if (c === '"'){
        if (text[i+1] === '"'){ field += '"'; i++; }
        else { inQuotes = false; }
      } else {
        field += c;
      }
    } else {
      if (c === '"'){
        inQuotes = true;
      } else if (c === ','){
        row.push(field);
        field = '';
      } else if (c === '\n'){
        row.push(field.replace(/\r$/,''));
        rows.push(row);
        row = [];
        field = '';
      } else if (c === '\r'){
        // ignore
      } else {
        field += c;
      }
    }
  }
  row.push(field.replace(/\r$/,''));
  rows.push(row);
  // drop trailing empty row if present
  if (rows.length && rows[rows.length-1].every(v=>String(v||'').trim()==='')) rows.pop();
  return rows;
}

function canonicaliseTrainingCsv(rawCsv){
  const rows = parseCsv(String(rawCsv||''));
  if (!rows.length) return '';
  const header = rows[0].map(h=>String(h||'').trim());
  const headerMap = new Map();
  header.forEach((h,i)=>{ if(h) headerMap.set(h,i); });

  const pantoneKey = headerMap.has('Pantone') ? 'Pantone' : (headerMap.has('Name') ? 'Name' : 'Pantone');
  const LKey = headerMap.has('L*') ? 'L*' : (headerMap.has('L') ? 'L' : 'L*');
  const aKey = headerMap.has('a*') ? 'a*' : (headerMap.has('a') ? 'a' : 'a*');
  const bKey = headerMap.has('b*') ? 'b*' : (headerMap.has('b') ? 'b' : 'b*');

  const canonicalInks = getCanonicalInks();
  const baseSet = new Set([pantoneKey, LKey, aKey, bKey]);
  const inksInInput = header.filter(h=>h && !baseSet.has(h));
  const extras = inksInInput.filter(n=>!canonicalInks.includes(n)).slice().sort();

  const outHeader = ['Pantone','L*','a*','b*'].concat(canonicalInks).concat(extras);
  const outLines = [outHeader.map(csvEscape).join(',')];

  function getCell(rowArr, colName){
    const idx = headerMap.get(colName);
    if (idx == null) return '';
    return (idx < rowArr.length) ? rowArr[idx] : '';
  }

  for (let r=1; r<rows.length; r++){
    const rowArr = rows[r] || [];
    const pantone = String(getCell(rowArr, pantoneKey) || '').trim();
    const L = String(getCell(rowArr, LKey) ?? '').trim();
    const a = String(getCell(rowArr, aKey) ?? '').trim();
    const b = String(getCell(rowArr, bKey) ?? '').trim();

    const outRow = [
      pantone,
      L,
      a,
      b
    ];

    canonicalInks.forEach(ink=>{
      const v = String(getCell(rowArr, ink) ?? '').trim();
      outRow.push(v === '' ? '0' : v);
    });
    extras.forEach(ink=>{
      const v = String(getCell(rowArr, ink) ?? '').trim();
      outRow.push(v === '' ? '0' : v);
    });

    outLines.push(outRow.map(csvEscape).join(','));
  }

  return outLines.join('\r\n');
}

async function downloadCanonicalTrainingCsv(){
  const btn = document.getElementById('downloadTrainingCanonicalBtn');
  const status = document.getElementById('trainingExportStatus');
  if (btn) btn.disabled = true;
  if (status) status.textContent = 'Fetching…';
  try{
    const res = await fetch(API_BASE + '/export_training');
    if (!res.ok) throw new Error(`API ${res.status}: ${await res.text()}`);
    const j = await res.json();
    const canonCsv = canonicaliseTrainingCsv(j && j.csv ? j.csv : '');
    if (!canonCsv) throw new Error('No CSV returned.');
    const blob = new Blob([canonCsv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'training_export_canonical.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    if (status) status.textContent = `Downloaded ${j && j.rows ? j.rows : ''}`.trim();
  }catch(err){
    if (status) status.textContent = 'Error: ' + (err.message || String(err));
  }finally{
    if (btn) btn.disabled = false;
  }
}

// ===== Spectro capture state =====
let spectroPort = null;
let spectroConnected = false;
const INK_CURVES_KEY = 'ink_curves_v1';
let INK_CURVES = [];

// ===== Compare logging (simulated DB via localStorage) =====
const CMP_LOG_KEY = 'compare_log_v1';
const SETTINGS_KEY = 'ink_system_settings_v1';
let CMP_LOG = [];
let SETTINGS = {
  deltaEThreshold: 2.0,
  autoSaveCompare: false,
};

function makeJobId(){
  try{
    if (crypto && typeof crypto.randomUUID === 'function') return crypto.randomUUID();
  }catch(_){}
  return String(Date.now()) + '-' + Math.floor(Math.random()*1e9).toString(36);
}

let CURRENT_JOB_ID = makeJobId();

function setJobIdUI(){ /* job id is stored internally */ }

function setJobRefUI(v){
  const a = document.getElementById('cmpJobRef');
  const b = document.getElementById('cmpJobRefTop');
  if (a && a.value !== v) a.value = v;
  if (b && b.value !== v) b.value = v;
}

function loadSettings(){
  try{
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (!raw) return;
    const j = JSON.parse(raw);
    if (j && typeof j === 'object'){
      if (Number.isFinite(+j.deltaEThreshold)) SETTINGS.deltaEThreshold = +j.deltaEThreshold;
      if (j.autoSaveCompare === true || j.autoSaveCompare === false) SETTINGS.autoSaveCompare = j.autoSaveCompare;
    }
  }catch{}
}
function saveSettings(){
  try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(SETTINGS)); }catch{}
}
function applySettingsToUI(){
  const thr = document.getElementById('setDeltaEThreshold');
  const auto = document.getElementById('setAutoSaveCompare');
  if (thr) thr.value = String(SETTINGS.deltaEThreshold);
  if (auto) auto.value = SETTINGS.autoSaveCompare ? '1' : '0';
}
function readSettingsFromUI(){
  const thr = document.getElementById('setDeltaEThreshold');
  const auto = document.getElementById('setAutoSaveCompare');
  const v = thr ? parseFloat(thr.value) : NaN;
  if (Number.isFinite(v) && v >= 0) SETTINGS.deltaEThreshold = v;
  SETTINGS.autoSaveCompare = (auto && auto.value === '1') ? true : false;
}

function loadCompareLog(){
  try{
    const raw = localStorage.getItem(CMP_LOG_KEY);
    if (!raw){ CMP_LOG = []; return; }
    const arr = JSON.parse(raw);
    CMP_LOG = Array.isArray(arr) ? arr : [];
  }catch{ CMP_LOG = []; }
}
function saveCompareLog(){
  try{ localStorage.setItem(CMP_LOG_KEY, JSON.stringify(CMP_LOG)); }catch{}
}
function fmtLab(o){
  return `L ${(+o.L).toFixed(2)} a ${(+o.a).toFixed(2)} b ${(+o.b).toFixed(2)}`;
}
function escAttr(s){
  return String(s||'')
    .replace(/&/g,'&amp;')
    .replace(/"/g,'&quot;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;');
}
function labSwatch(o){
  if(!o) return '';
  const rgb = labToSrgb(+o.L, +o.a, +o.b);
  const tip = escAttr(fmtLab(o));
  return `<div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})" title="${tip}"></div>`;
}
function isoToNice(ts){
  const d = new Date(ts);
  // local time, demo-friendly
  return d.toLocaleString(undefined, { year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });
}
function renderCompareLog(){
  const tb = document.getElementById('cmpLogTbody');
  if (!tb) return;
  tb.innerHTML = '';
  if (!CMP_LOG.length){
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="8" class="muted">No saved comparisons yet.</td>';
    tb.appendChild(tr);
    return;
  }

  const rows = filteredAndSortedCompareLog();
  const countEl = document.getElementById('histCount');
  if (countEl){
    countEl.textContent = `${rows.length} row${rows.length===1?'':'s'} shown (of ${CMP_LOG.length}).`;
  }

  rows.forEach(r=>{
    const tr = document.createElement('tr');
    const pass = Number.isFinite(+r.deltaE) ? (+r.deltaE < SETTINGS.deltaEThreshold) : null;
    const cls = (pass===true) ? 'de-pass' : (pass===false ? 'de-fail' : 'de-neutral');
    const resTxt = (pass===true) ? 'PASS' : (pass===false ? 'FAIL' : '—');
    const stdName = (r.standardName || '').replace(/</g,'&lt;');
    const libLabel = (r.libraryLabel || '').replace(/</g,'&lt;');
    tr.innerHTML = `
      <td>${isoToNice(r.ts)}</td>
      <td class="mono">${(r.jobRef||'').replace(/</g,'&lt;')}</td>
      <td class="mono">${stdName}</td>
      <td>${libLabel}</td>
      <td>${labSwatch(r.A)}</td>
      <td>${labSwatch(r.B)}</td>
      <td class="${cls}">${(+r.deltaE).toFixed(2)}</td>
      <td class="${cls}">${resTxt}</td>
    `;
    tb.appendChild(tr);
  });
}
function exportCompareLogCsv(){
  if (!CMP_LOG.length){ alert('No saved comparisons yet.'); return; }
  const header = ['Date','JobRef','StandardName','Library','A_L','A_a','A_b','B_L','B_a','B_b','DeltaE2000','Threshold','Result'];
  const lines = [header.join(',')];
  const thr = SETTINGS.deltaEThreshold;
  const rows = filteredAndSortedCompareLog(true);
  rows.forEach(r=>{
    const pass = (+r.deltaE < thr);
    lines.push([
      new Date(r.ts).toISOString(),
      String(r.jobRef||'').replaceAll(',',' '),
      String(r.standardName||'').replaceAll(',',' '),
      String(r.libraryLabel||'').replaceAll(',',' '),
      r.A.L, r.A.a, r.A.b,
      r.B.L, r.B.a, r.B.b,
      r.deltaE,
      thr,
      pass ? 'PASS' : 'FAIL'
    ].join(','));
  });
  const blob = new Blob([lines.join('\r\n')],{type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'colour_compare_log.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function getCompareAB(){
  const A={L:parseFloat(document.getElementById('AL').value), a:parseFloat(document.getElementById('Aa').value), b:parseFloat(document.getElementById('Ab').value)};
  const B={L:parseFloat(document.getElementById('BL').value), a:parseFloat(document.getElementById('Ba').value), b:parseFloat(document.getElementById('Bb').value)};
  if ([A.L,A.a,A.b,B.L,B.a,B.b].some(v=>Number.isNaN(v))) return null;
  return {A,B};
}
function saveCurrentComparison(opts){
  const ab = getCompareAB();
  if (!ab) return { ok:false, msg:'Enter valid L*a*b* for both Standard and Batch first.' };
  const jobRef = (document.getElementById('cmpJobRef')?.value || '').trim();
  if (!jobRef) return { ok:false, msg:'Please enter a Job reference before saving.' };
  const deltaE = deltaE2000({L:ab.A.L,a:ab.A.a,b:ab.A.b},{L:ab.B.L,a:ab.B.a,b:ab.B.b});
  const libOpts = libraryOptions();
  const libLabel = (libOpts.find(o=>o.id===activeLibraryId)?.label) || '';
  const standardName = (CMP_STANDARD_NAME || document.getElementById('cmpASelect')?.value || '').trim();
  const rec = {
    ts: Date.now(),
    jobRef,
    jobId: CURRENT_JOB_ID,
    standardName,
    libraryId: activeLibraryId,
    libraryLabel: libLabel,
    A: ab.A,
    B: ab.B,
    deltaE: +deltaE.toFixed(4)
  };
  CMP_LOG.push(rec);
  saveCompareLog();
  renderCompareLog();
  CURRENT_JOB_ID = makeJobId();
  setJobIdUI();
  return { ok:true, msg: (opts && opts.silent) ? '' : 'Saved.' };
}

function loadInkCurves(){
  try{
    const raw = localStorage.getItem(INK_CURVES_KEY);
    if (!raw){ INK_CURVES = []; return; }
    const arr = JSON.parse(raw);
    INK_CURVES = Array.isArray(arr) ? arr : [];
  }catch(e){
    INK_CURVES = [];
  }
}

function saveInkCurves(){
  try{
    localStorage.setItem(INK_CURVES_KEY, JSON.stringify(INK_CURVES));
  }catch(e){}
}

const LIB_KEY = 'ink_user_libraries_v1';
const LIB_BASE_ID = 'base';
const LIB_ALL_ID = 'all';
let userLibraries = []; // [{id,name,colours:[]}]
let activeLibraryId = LIB_BASE_ID;
let settingsLibraryId = LIB_BASE_ID;

// Helpers
function normaliseName(s){ return String(s||'').trim().toUpperCase().replace(/\s+/g,' '); }
function extractPmsNumber(name){
  if(!name) return null;
  const m = String(name).toUpperCase().match(/PANTONE\s*([0-9A-Z]+(?:[\- ]?[0-9A-Z]+)*)/);
  return m? m[1].replace(/\s+/g,'').replace(/^\-/,''): null;
}
function updateTargetEcho(){
  const L=parseFloat($('#L').value), a=parseFloat($('#a').value), b=parseFloat($('#b').value);
  if([L,a,b].some(v=>Number.isNaN(v))){
    $('#targetEcho').textContent='Target: –';
    $('#targetSwatch').style.background='#0000';
    return;
  }
  $('#targetEcho').textContent=`Target: L ${L.toFixed(2)} a ${a.toFixed(2)} b ${b.toFixed(2)}`;
  const rgb=labToSrgb(L,a,b);
  $('#targetSwatch').style.background=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
}

// Build formula index from DC_Formulas.json (Pantone library)
function buildFormulaIndex(){
  const rows=[]; FORMULAS_NORM={}; COLOUR_TO_FORMULA={};
  if (Array.isArray(FORMULAS)) rows.push(...FORMULAS);
  else if (FORMULAS && typeof FORMULAS==='object'){
    Object.keys(FORMULAS).forEach(k=>{
      if (Array.isArray(FORMULAS[k])) rows.push(...FORMULAS[k]);
      else if (FORMULAS[k] && typeof FORMULAS[k]==='object' && Array.isArray(FORMULAS[k].rows)) rows.push(...FORMULAS[k].rows);
    });
  }
  const byColour=new Map();
  rows.forEach(r=>{
    const cname=r.Colour||r.colour||r.Color||r.color||r.NAME||r.Name;
    if(!cname) return;
    const items=[];
    for (let i=1;i<=12;i++){
      const ink=r['Ingredient '+i]||r['Ink '+i]||r['INGREDIENT '+i]||r['ingredient '+i];
      if(!ink) continue;
      const pct=r['%'+i]||r[i+'%']||r['% '+i]||r['Percent '+i]||r['Percent'+i]||r['%']||'';
      items.push({ink,percent:pct});
    }
    const arr=byColour.get(cname)||[];
    arr.push(...items);
    byColour.set(cname,arr);
    FORMULAS_NORM[normaliseName(cname)]=arr;
  });
  (BASE_COLOURS||[]).forEach(c=>{
    const name=c.name||c.Colour||c.color||'';
    const norm=normaliseName(name);
    if (byColour.has(name)){ COLOUR_TO_FORMULA[name]=norm; return; }
    if (FORMULAS_NORM[norm]){ COLOUR_TO_FORMULA[name]=norm; return; }
    const p=extractPmsNumber(name);
    if (p){
      for (const key of byColour.keys()){
        if ((extractPmsNumber(key)||'')===p){
          COLOUR_TO_FORMULA[name]=normaliseName(key);
          break;
        }
      }
    }
  });
}

// Library handling
function saveLibraries(){
  try{
    const plain = userLibraries.map(l=>({id:l.id,name:l.name,colours:l.colours}));
    localStorage.setItem(LIB_KEY, JSON.stringify(plain));
  }catch(e){}
}
function loadLibraries(){
  try{
    const raw = localStorage.getItem(LIB_KEY);
    if (!raw) { userLibraries = []; return; }
    const arr = JSON.parse(raw);
    if (!Array.isArray(arr)) { userLibraries = []; return; }
    userLibraries = arr.map(l=>({
      id: String(l.id || (crypto && crypto.randomUUID ? crypto.randomUUID() : ('lib_'+Math.random().toString(16).slice(2)))),
      name: String(l.name || 'Unnamed'),
      colours: Array.isArray(l.colours) ? l.colours.map(co=>({
        name: String(co.name || co.Colour || co.color || 'Untitled'),
        L: Number(co.L ?? co.Lstar ?? co['L*'] ?? 0),
        a: Number(co.a ?? co.astar ?? co['a*'] ?? 0),
        b: Number(co.b ?? co.bstar ?? co['b*'] ?? 0)
      })) : []
    }));
  }catch(e){
    userLibraries = [];
  }
}
function libraryOptions(){
  const opts = [
    {id: LIB_BASE_ID, label: 'Pantone'}
  ];
  userLibraries.forEach(l => opts.push({id: l.id, label: l.name}));
  if (userLibraries.length) opts.push({id: LIB_ALL_ID, label: 'All libraries (combined)'});
  return opts;
}
function refreshLibrarySelects(){
  const opts = libraryOptions();
  const sel1 = $('#librarySelect');
  const sel2 = $('#cmpLibrarySelect');
  const build = (sel)=>{
    sel.innerHTML = '';
    opts.forEach(o=>{
      const opt = document.createElement('option');
      opt.value = o.id;
      opt.textContent = o.label;
      sel.appendChild(opt);
    });
    if (!opts.find(o=>o.id === activeLibraryId)) activeLibraryId = LIB_BASE_ID;
    sel.value = activeLibraryId;
  };
  build(sel1);
  build(sel2);
  const activeLabel = (opts.find(o=>o.id===activeLibraryId)?.label) || 'Pantone';
  $('#activeLibLabel').textContent = activeLabel;
  $('#cmpLibLabel').textContent = activeLabel;
}
function getActiveColours(){
  if (activeLibraryId === LIB_BASE_ID) return BASE_COLOURS;
  if (activeLibraryId === LIB_ALL_ID){
    let all = [...BASE_COLOURS];
    userLibraries.forEach(l => { all = all.concat(l.colours); });
    return all;
  }
  const lib = userLibraries.find(l=>l.id === activeLibraryId);
  return lib ? lib.colours : BASE_COLOURS;
}
function refreshActiveColours(){
  COLOURS = getActiveColours();
  $('#countLabel').textContent = COLOURS.length;
  $('#resultsTbody').innerHTML = '';
  $('#formulaPanel').style.display = 'none';
  refreshCompareStandardCombo();
  refreshMatchColourCombo();
}
function renderLibraryList(){
  const wrap = $('#libList');
  const items = [
    { id: LIB_BASE_ID, name: 'Pantone', colours: BASE_COLOURS, readonly:true }
  ].concat(userLibraries.map(l=>({id:l.id, name:l.name, colours:l.colours, readonly:false})));

  let out = '';
  items.forEach(l=>{
    const selected = (settingsLibraryId === l.id) ? ' selected' : '';
    const badge = l.readonly ? 'Read-only' : `${l.colours.length} colours`;
    out += `<div class="lib-item${selected}" data-lib-select="${l.id}">
      <div class="lib-item-left">
        <div class="lib-item-name">${escapeHtml(l.name)}</div>
        <div class="lib-badge">${badge}</div>
      </div>
      ${l.readonly ? '' : `<button class="btn" data-del-lib="${l.id}" title="Delete library">Delete</button>`}
    </div>`;
  });

  wrap.innerHTML = out || '<div class="muted">No libraries found.</div>';

  wrap.querySelectorAll('[data-lib-select]').forEach(el=>{
    el.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('[data-del-lib]');
      if (btn) return; // let delete handler run
      const id = el.getAttribute('data-lib-select');
      setSettingsLibrary(id);
    });
  });

  wrap.querySelectorAll('[data-del-lib]').forEach(btn=>{
    btn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      const id = btn.getAttribute('data-del-lib');
      const lib = userLibraries.find(l=>l.id === id);
      if (!lib) return;
      if (!confirm(`Delete library "${lib.name}"? This cannot be undone.`)) return;
      userLibraries = userLibraries.filter(l=>l.id !== id);
      saveLibraries();
      if (activeLibraryId === id || activeLibraryId === LIB_ALL_ID) refreshActiveColours();
      refreshLibrarySelects();
      if (settingsLibraryId === id) settingsLibraryId = LIB_BASE_ID;
      renderLibraryList();
      renderLibraryEditor();
    });
  });
}

let _libSaveTimer = null;
function scheduleSaveLibraries(){
  if (_libSaveTimer) clearTimeout(_libSaveTimer);
  _libSaveTimer = setTimeout(()=>{
    saveLibraries();
    refreshLibrarySelects();
    if (activeLibraryId === settingsLibraryId || activeLibraryId === LIB_ALL_ID) refreshActiveColours();
  }, 200);
}

function setSettingsLibrary(id){
  settingsLibraryId = id || LIB_BASE_ID;
  renderLibraryList();
  renderLibraryEditor();
}

function getSettingsLibrary(){
  if (settingsLibraryId === LIB_BASE_ID){
    return { id:LIB_BASE_ID, name:'Pantone', colours:BASE_COLOURS, readonly:true };
  }
  const lib = userLibraries.find(l=>l.id === settingsLibraryId);
  if (!lib) return { id:LIB_BASE_ID, name:'Pantone', colours:BASE_COLOURS, readonly:true };
  return { id:lib.id, name:lib.name, colours:lib.colours, readonly:false, ref:lib };
}

function renderLibraryEditor(){
  const title = $('#libEditorTitle');
  const hint = $('#libEditorHint');
  const wrap = $('#libColourTableWrap');
  const btnExport = $('#libExportBtn');
  const btnDelete = $('#libDeleteBtn');
  const btnScan = $('#libScanBtn');
  const btnAdd = $('#libAddColourBtn');

  if (!title || !wrap) return;

  const lib = getSettingsLibrary();
  title.textContent = lib.name;

  const editable = !lib.readonly;
  btnExport.disabled = lib.readonly;
  btnDelete.disabled = lib.readonly;
  btnScan.disabled = lib.readonly;
  btnAdd.disabled = lib.readonly;

  hint.textContent = editable
    ? 'Edit values directly. Changes apply app-wide.'
    : 'Select a custom library to edit.';

  const rows = lib.colours || [];
  const head = `
    <table class="lib-colour-table">
      <thead>
        <tr>
          <th style="width:44px;"></th>
          <th>Name</th>
          <th style="width:120px;">L*</th>
          <th style="width:120px;">a*</th>
          <th style="width:120px;">b*</th>
          <th style="width:90px; text-align:right;"> </th>
        </tr>
      </thead>
      <tbody>
  `;
  const body = rows.map((c, i)=>{
    const L = Number(c.L ?? 0);
    const a = Number(c.a ?? 0);
    const b = Number(c.b ?? 0);
    const css = labToRgbCssForSwatch(L,a,b);
    return `
      <tr data-lib-row="${i}">
        <td><div class="lib-swatch" style="background:${css};"></div></td>
        <td>
          <input class="lib-row-input" ${editable ? "" : "disabled"} data-lib-field="name" data-lib-idx="${i}" value="${escapeHtml(c.name||c.Name||'')}">
        </td>
        <td><input class="lib-row-input lib-row-num" type="number" ${editable ? "" : "disabled"} step="0.01" data-lib-field="L" data-lib-idx="${i}" value="${Number.isFinite(L)?L.toFixed(2):'0.00'}"></td>
        <td><input class="lib-row-input lib-row-num" type="number" ${editable ? "" : "disabled"} step="0.01" data-lib-field="a" data-lib-idx="${i}" value="${Number.isFinite(a)?a.toFixed(2):'0.00'}"></td>
        <td><input class="lib-row-input lib-row-num" type="number" ${editable ? "" : "disabled"} step="0.01" data-lib-field="b" data-lib-idx="${i}" value="${Number.isFinite(b)?b.toFixed(2):'0.00'}"></td>
        <td class="lib-row-actions"><button class="btn" ${editable ? "" : "disabled"} data-lib-del-col="${i}">Remove</button></td>
      </tr>
    `;
  }).join('');

  wrap.innerHTML = head + body + '</tbody></table>';

  if (editable){
  // Wire edits
  wrap.querySelectorAll('[data-lib-field]').forEach(inp=>{
    inp.addEventListener('input', ()=>{
      const idx = Number(inp.getAttribute('data-lib-idx'));
      const field = inp.getAttribute('data-lib-field');
      if (!Number.isFinite(idx) || idx < 0 || idx >= rows.length) return;
      const val = inp.value;
      if (field === 'name'){
        rows[idx].name = val;
      }else{
        const num = parseFloat(val);
        rows[idx][field] = Number.isFinite(num) ? num : 0;
      }
      // update swatch immediately
      const tr = inp.closest('tr');
      if (tr){
        const c = rows[idx];
        const sw = tr.querySelector('.lib-swatch');
        if (sw){
          sw.style.background = labToRgbCssForSwatch(Number(c.L||0), Number(c.a||0), Number(c.b||0));
        }
      }
      scheduleSaveLibraries();
    });
  });

  wrap.querySelectorAll('[data-lib-del-col]').forEach(btn=>{
    btn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      const idx = Number(btn.getAttribute('data-lib-del-col'));
      if (!Number.isFinite(idx) || idx < 0 || idx >= rows.length) return;
      rows.splice(idx, 1);
      scheduleSaveLibraries();
      renderLibraryEditor();
    });
  });
  }
}


// parse CSV into colours
function parseCsvColours(text){
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length);
  if (!lines.length) return [];
  const header = lines[0].split(',').map(h=>h.trim().toLowerCase());
  const idxName = header.findIndex(h=>['name','colour','color'].includes(h));
  const idxL = header.findIndex(h=>['l','l*','lstar'].includes(h));
  const idxA = header.findIndex(h=>['a','a*','astar'].includes(h));
  const idxB = header.findIndex(h=>['b','b*','bstar'].includes(h));
  if (idxName<0 || idxL<0 || idxA<0 || idxB<0) throw new Error('CSV must have columns: Name, L, a, b');
  const out = [];
  for (let i=1;i<lines.length;i++){
    const parts = lines[i].split(',').map(x=>x.trim());
    if (parts.length <= Math.max(idxName,idxL,idxA,idxB)) continue;
    const name = parts[idxName] || `Row ${i+1}`;
    const L = parseFloat(parts[idxL]);
    const a = parseFloat(parts[idxA]);
    const b = parseFloat(parts[idxB]);
    if ([L,a,b].some(v=>Number.isNaN(v))) continue;
    out.push({name, L, a, b});
  }
  return out;
}

// ===== Matching / PMS / formulas =====
function getTargetLab(){
  const L=parseFloat($('#L').value), a=parseFloat($('#a').value), b=parseFloat($('#b').value);
  if([L,a,b].some(v=>Number.isNaN(v))) return null;
  return {L,a,b};
}

function findClosest(){
  const target=getTargetLab();
  if(!target){
    alert('Enter a valid colour first.');
    return;
  }
  const rows=COLOURS.map(c=>({
    raw:c,
    name:c.name||c.Colour||c.color||'—',
    L:c.L,
    a:c.a,
    b:c.b,
    de:deltaE2000({L:c.L,a:c.a,b:c.b},target)
  })).sort((a,b)=>a.de-b.de).slice(0,8);
  const tbody=$('#resultsTbody');
  tbody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.className='result-row';
    const rgb=labToSrgb(r.L,r.a,r.b);
    tr.innerHTML=`<td>${r.name}</td>
      <td><div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div></td>
      <td>${r.L.toFixed(2)}</td><td>${r.a.toFixed(2)}</td><td>${r.b.toFixed(2)}</td>
      <td>${r.de.toFixed(2)}</td>`;
    tr.addEventListener('click',()=>{
      $('#L').value=r.L;
      $('#a').value=r.a;
      $('#b').value=r.b;
      updateTargetEcho();
      showFormulaFor(r.name);
      _lastContextName = r.name;
    });
    tbody.appendChild(tr);
  });
}
function showFormulaFor(colourName){
  const panel=$('#formulaPanel');
  let list=null;
  const bound=COLOUR_TO_FORMULA[colourName];
  if(bound) list=FORMULAS_NORM[bound];
  if(!list) list=FORMULAS_NORM[normaliseName(colourName)];
  if(!list){
    const want=extractPmsNumber(colourName);
    if(want){
      for (const key in FORMULAS_NORM){
        if ((extractPmsNumber(key)||'')===want){
          list=FORMULAS_NORM[key];
          break;
        }
      }
    }
  }
  if(!list||!list.length){
    panel.style.display='none';
    return;
  }
  let html=`<h2>Existing Formula: ${colourName}</h2><div class="formula-grid">`;
  list.forEach(item=>{
    const name=item.ink||item.Ink||'Ink';
    const pct=item.percent!==''?(item.percent+'%'):'';
    html+=`<div class="fg-ink">${name}</div><div class="fg-pct">${pct}</div>`;
  });
  html+='</div>';
  panel.innerHTML=html;
  panel.style.display='block';
}
function findByPms(){
  const qRaw=($('#pms').value||'').trim().toUpperCase();
  if(!qRaw){
    alert('Enter a PMS number');
    return;
  }
  const q=qRaw.replace(/^PANTONE\s*/,'');
  const hits=COLOURS.filter(c=>{
    const p=extractPmsNumber(c.name||c.Colour||c.color||'');
    return p && p.includes(q);
  });
  const tbody=$('#resultsTbody');
  tbody.innerHTML='';
  if(!hits.length){
    alert('No PMS match found');
    return;
  }
  hits.slice(0,8).forEach(c=>{
    const rgb=labToSrgb(c.L,c.a,c.b);
    const tr=document.createElement('tr');
    tr.className='result-row';
    tr.innerHTML=`<td>${(c.name||c.Colour||c.color||'—')}</td>
      <td><div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div></td>
      <td>${(+c.L).toFixed(2)}</td><td>${(+c.a).toFixed(2)}</td><td>${(+c.b).toFixed(2)}</td><td>—</td>`;
    tr.addEventListener('click',()=>{
      $('#L').value=c.L;
      $('#a').value=c.a;
      $('#b').value=c.b;
      updateTargetEcho();
      showFormulaFor(c.name||c.Colour||c.color||'');
      _lastContextName = c.name||c.Colour||c.color||'';
    });
    tbody.appendChild(tr);
  });
  const c0=hits[0];
  $('#L').value=c0.L;
  $('#a').value=c0.a;
  $('#b').value=c0.b;
  updateTargetEcho();
  _lastContextName = c0.name||c0.Colour||c0.color||'';
}

// Predictor / groups
async function loadGroups(){
  try{
    const r=await fetch(API_BASE+'/groups');
    const j=await r.json();
    const sel=$('#groupSelect');
    (j.groups||[]).forEach(g=>{
      const opt=document.createElement('option');
      opt.value=g;
      opt.textContent=g;
      sel.appendChild(opt);
    });
  }catch(e){}
}
async function loadInks(){
  try{
    const r=await fetch(API_BASE+'/inks');
    const j=await r.json();
    _allInks=(j.inks||[]).slice().sort();
  }catch(e){
    _allInks=[];
  }
}
function formulaPairs(formula){
  return Object.entries(formula||{})
    .filter(([_,v])=>+v>0)
    .sort((a,b)=>b[1]-a[1]);
}

async function suggestFormula(){
  const btn=$('#suggestBtn');
  const msg=$('#predictMsg');
  const box=$('#suggestedFormula');
  const t=getTargetLab();
  if(!t){
    alert('Enter a valid L*a*b* first.');
    return;
  }

  btn.disabled=true;
  msg.textContent='Predicting…';
  box.style.display='none';
  box.innerHTML='';
  $('#editRow').style.display='none';

  try{
    const group=($('#groupSelect').value||'');
    const body={L:t.L,a:t.a,b:t.b,lock_neighbours:true};
    if(group) body.group=group;
    const res=await fetch(API_BASE+'/predict',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify(body)
    });
    if(!res.ok){
      throw new Error(`API ${res.status}: ${await res.text()}`);
    }
    const data=await res.json();
    const formula = (data && typeof data.formula === 'object') ? data.formula : {};
    const pairs=formulaPairs(formula);

    let html='<h2>Suggested Formula</h2><div class="formula-grid" id="suggestedFormulaGrid">';
    if (pairs.length === 0) {
      html += '<div class="fg-ink">—</div><div class="fg-pct">0.00%</div>';
    } else {
      for (const [ink,pct] of pairs){
        html+=`<div class="fg-ink">${ink}</div><div class="fg-pct">${(+pct).toFixed(2)}%</div>`;
      }
    }
    html+='</div>';
    box.innerHTML=html;
    box.style.display='block';
    msg.textContent='';

    _lastSuggestion={ target:t, formula, group: (group||null) };
    $('#editRow').style.display='flex';
  }catch(err){
    msg.textContent=String(err.message||err);
    $('#editRow').style.display='none';
  } finally {
    btn.disabled=false;
  }
}

// ===== Edit modal / logging =====
const modal = $('#editModal');
const editList = $('#editList');
let working = []; // [{ink, pct}]
function contextLine(){
  const t = _lastSuggestion && _lastSuggestion.target;
  if (!t) return '';
  const name = _lastContextName ? ` · ${_lastContextName}` : '';
  return `Target: L=${t.L.toFixed(2)} a=${t.a.toFixed(2)} b=${t.b.toFixed(2)}${name}`;
}
function openEdit(){
  if(!_lastSuggestion || !(_lastSuggestion.formula)) {
    alert('No suggestion to edit yet.');
    return;
  }
  working = formulaPairs(_lastSuggestion.formula).map(([ink,p])=>({ink,pct:+(+p).toFixed(2)}));
  renderEditList();
  const sel = $('#addInkSel');
  sel.innerHTML = '';
  _allInks.forEach(name=>{
    const opt=document.createElement('option');
    opt.value=name;
    opt.textContent=name;
    sel.appendChild(opt);
  });
  $('#addPct').value = '';
  $('#corrNote').value = '';
  $('#editContext').textContent = contextLine();
  modal.style.display='flex';
  updateTotals();
}
function closeEdit(){ modal.style.display='none'; }
function renderEditList(){
  editList.innerHTML = '';
  working.forEach((row, idx)=>{
    const wrap = document.createElement('div');
    wrap.className='edit-row';
    const nameInput = document.createElement('input');
    nameInput.value=row.ink;
    nameInput.readOnly=true;
    nameInput.className='mono';
    const pctInput = document.createElement('input');
    pctInput.type='number';
    pctInput.step='0.01';
    pctInput.value=Number(row.pct).toFixed(2);
    pctInput.className='pct-input mono';
    pctInput.addEventListener('input',()=>{
      row.pct = +pctInput.value;
      updateTotals();
    });
    const del = document.createElement('button');
    del.className='rem-btn';
    del.innerHTML='✕';
    del.title='Remove';
    del.addEventListener('click',()=>{
      working.splice(idx,1);
      renderEditList();
      updateTotals();
    });
    wrap.appendChild(nameInput);
    wrap.appendChild(pctInput);
    wrap.appendChild(del);
    editList.appendChild(wrap);
  });
}
function updateTotals(){
  const total = working.reduce((s,r)=> s + (+r.pct||0), 0);
  $('#totalPct').textContent = total.toFixed(2);
  const good = approx(total,100,0.01);
  $('#totalState').textContent = good ? 'normalised' : 'needs normalising';
  $('#totalState').className = good ? 'ok' : 'warn';
}
function normalise(){
  const sum = working.reduce((s,r)=> s + (+r.pct||0), 0) || 1;
  working.forEach(r=> { r.pct = +(r.pct * 100 / sum).toFixed(2); });
  renderEditList();
  updateTotals();
}
function addInk(){
  const name = $('#addInkSel').value;
  let pct = +($('#addPct').value||0);
  if(!name || !(pct>0)) return;
  const found = working.find(r=> r.ink === name);
  if(found) found.pct = +(found.pct + pct).toFixed(2);
  else working.push({ink:name, pct:+pct.toFixed(2)});
  $('#addPct').value='';
  renderEditList();
  updateTotals();
}
async function saveCorrection(){
  if(!_lastSuggestion) return;

  const sum = working.reduce((s,r)=> s + (+r.pct||0), 0);
  if (!approx(sum,100,0.02)) normalise();

  const correctedSparse = {};
  working.forEach(r=>{
    if ((+r.pct)>0) correctedSparse[r.ink] = +(+r.pct).toFixed(2);
  });

  const canonicalInks = getCanonicalInks();
  const originalFull = expandFormulaToCanonical(_lastSuggestion.formula || {}, canonicalInks);
  const correctedFull = expandFormulaToCanonical(correctedSparse, canonicalInks);

  const payload = {
    target: _lastSuggestion.target,
    group: _lastSuggestion.group || null,
    original: originalFull,
    corrected: correctedFull,
    inks_order: canonicalInks, // helps server keep consistent column order
    context_name: _lastContextName || null,
    note: ($('#corrNote').value||'').trim() || null,
    measured: null
  };

  try{
    const res = await fetch(API_BASE + '/log_correction', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      throw new Error(`API ${res.status}: ${await res.text()}`);
    }
    alert('Saved correction. It will be available for the next training cycle.');
    closeEdit();
  }catch(err){
    alert('Error saving correction: ' + (err.message||err));
  }
}

// ===== Spectro (Web Serial) integration & ink curve table =====
function setSpectroConnectedUI(connected){
  spectroConnected = !!connected;
  const ids = ['spectroConnectBtn','spectroConnectBtnMatch','spectroConnectBtnCompare'];
  ids.forEach(id=>{
    const btn = document.getElementById(id);
    if (!btn) return;
    if (connected){
      btn.textContent = 'Connected';
      btn.classList.add('btn-connected');
    } else {
      btn.textContent = 'Connect device';
      btn.classList.remove('btn-connected');
    }
  });
  const statusEl = document.getElementById('spectroStatus');
  if (statusEl){
    if (connected && !statusEl.textContent) statusEl.textContent = 'Connected.';
    if (!connected && statusEl.textContent === 'Connected.') statusEl.textContent = '';
  }
}

async function spectroEnsureSupported(){
  if (!('serial' in navigator)){
    throw new Error('Web Serial not supported. Use Chrome/Edge over HTTPS.');
  }
}

async function spectroConnect(){
  const statusEl = document.getElementById('spectroStatus');
  try{
    await spectroEnsureSupported();
  }catch(err){
    if (statusEl) statusEl.textContent = err.message || String(err);
    throw err;
  }

  if (spectroPort && spectroPort.readable && spectroPort.writable){
    setSpectroConnectedUI(true);
    if (statusEl) statusEl.textContent = 'Already connected.';
    return spectroPort;
  }

  try{
    if (statusEl) statusEl.textContent = 'Select device…';
    const port = await navigator.serial.requestPort();
    await port.open({
      baudRate: 115200,
      dataBits: 8,
      stopBits: 1,
      parity: 'none',
      flowControl: 'none'
    });
    spectroPort = port;
    setSpectroConnectedUI(true);
    if (statusEl) statusEl.textContent = 'Connected.';

    if (navigator.serial && typeof navigator.serial.addEventListener === 'function'){
      navigator.serial.addEventListener('disconnect', (event)=>{
        if (event.target === spectroPort){
          spectroPort = null;
          setSpectroConnectedUI(false);
          const s = document.getElementById('spectroStatus');
          if (s) s.textContent = 'Device disconnected.';
        }
      });
    }

    return port;
  }catch(err){
    if (statusEl) statusEl.textContent = 'Connect failed: ' + (err.message || err);
    setSpectroConnectedUI(false);
    throw err;
  }
}

async function spectroMeasureOnce(){
  const statusEl = document.getElementById('spectroStatus');
  if (!spectroPort){
    await spectroConnect();
  }
  const port = spectroPort;
  if (!port || !port.readable || !port.writable){
    setSpectroConnectedUI(false);
    throw new Error('Port is not open.');
  }

  if (statusEl) statusEl.textContent = 'Measuring…';

  const encoder = new TextEncoder();
  const writer = port.writable.getWriter();
  await writer.write(encoder.encode('SA_001_measureData\r\n'));
  writer.releaseLock();

  const reader = port.readable.getReader();
  const decoder = new TextDecoder();
  let textResp = '';

  try{
    while (true){
      const result = await reader.read();
      const value = result.value;
      const done = result.done;
      if (done) break;
      if (value){
        textResp += decoder.decode(value, { stream:true });
        if (textResp.includes('Data transmission has been successfully completed.')) break;
      }
    }
  } finally {
    reader.releaseLock();
  }

  if (statusEl) statusEl.textContent = 'Measurement received.';
  return textResp;
}

function parseSpectroMeasurement(textResp){
  const lines = textResp.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  let L = null, a = null, b = null;
  const spectrum = {};

  for (let i=0;i<lines.length;i++){
    const line = lines[i];
    if (line.startsWith('CIE-Lab')){
      if (i+1 < lines.length){
        const parts = lines[i+1].split(/\s+/).filter(Boolean);
        if (parts.length >= 3){
          L = parseFloat(parts[0]);
          a = parseFloat(parts[1]);
          b = parseFloat(parts[2]);
        }
      }
    } else if (line.startsWith('Spectral reflectance')){
      for (let j=i+1;j<lines.length;j++){
        const l2 = lines[j];
        if (l2.startsWith('Data transmission')) break;
        const m = l2.match(/^(\d{3})nm:(.+)%/);
        if (m){
          const wl = parseInt(m[1],10);
          const val = parseFloat(m[2]);
          if (!Number.isNaN(wl) && !Number.isNaN(val)){
            spectrum[wl] = val;
          }
        }
      }
    }
  }

  return { L, a, b, spectrum, raw:textResp };
}

// Lab -> RGB for swatches (rough D65 conversion)
function labToRgbCssForSwatch(L, a, b){
  const refX = 95.047;
  const refY = 100.0;
  const refZ = 108.883;

  let y = (L + 16) / 116;
  let x = a / 500 + y;
  let z = y - b / 200;

  const eps = 0.008856;
  const kappa = 903.3;

  function fInv(t){
    const t3 = t*t*t;
    return t3 > eps ? t3 : (116 * t - 16) / kappa;
  }

  x = refX * fInv(x);
  y = refY * fInv(y);
  z = refZ * fInv(z);

  x /= 100;
  y /= 100;
  z /= 100;

  let r =  3.2406 * x - 1.5372 * y - 0.4986 * z;
  let g = -0.9689 * x + 1.8758 * y + 0.0415 * z;
  let b2 = 0.0557 * x - 0.2040 * y + 1.0570 * z;

  function gammaCorrect(c){
    if (c <= 0.0031308) return 12.92 * c;
    return 1.055 * Math.pow(c, 1/2.4) - 0.055;
  }

  function clamp01(v){ return Math.min(1, Math.max(0, v)); }

  r = gammaCorrect(r);
  g = gammaCorrect(g);
  b2 = gammaCorrect(b2);

  r = Math.round(clamp01(r) * 255);
  g = Math.round(clamp01(g) * 255);
  b2 = Math.round(clamp01(b2) * 255);

  return `rgb(${r}, ${g}, ${b2})`;
}

function addInkCurveRecord(inkName, concentration, backing, angle, illuminant, aperture, geometry, meas){
  const now = new Date();
  const rec = {
    inkName: String(inkName || '').trim(),
    concentration: Number(concentration),
    backing: backing || 'white',
    angle: angle || '2',
    illuminant: illuminant || 'D50',
    aperture: aperture || '8mm',
    geometry: geometry || 'SCI',
    L: meas.L,
    a: meas.a,
    b: meas.b,
    spectrum: meas.spectrum,
    ts: now.getTime(),
    timestampISO: now.toISOString()
  };
  INK_CURVES.push(rec);
  saveInkCurves();
  renderInkCurvesTable();
  return rec;
}

function formatTimestamp(rec){
  if (rec.timestampISO){
    return rec.timestampISO;
  }
  if (rec.ts){
    try{
      return new Date(rec.ts).toISOString();
    }catch(e){
      return '';
    }
  }
  return '';
}

function renderInkCurvesTable(){
  const tbody = document.getElementById('inkCurvesTbody');
  if (!tbody) return;
  tbody.innerHTML = '';

  INK_CURVES.forEach((rec, idx)=>{
    const tr = document.createElement('tr');

    const tdIndex = document.createElement('td');
    tdIndex.textContent = String(idx+1);
    tr.appendChild(tdIndex);

    const tdSwatch = document.createElement('td');
    const swatch = document.createElement('div');
    swatch.style.width = '32px';
    swatch.style.height = '16px';
    swatch.style.borderRadius = '4px';
    swatch.style.border = '1px solid #1f2933';
    if (Number.isFinite(rec.L) && Number.isFinite(rec.a) && Number.isFinite(rec.b)){
      swatch.style.backgroundColor = labToRgbCssForSwatch(rec.L, rec.a, rec.b);
    } else {
      swatch.style.backgroundColor = 'transparent';
    }
    tdSwatch.appendChild(swatch);
    tr.appendChild(tdSwatch);

    const tdName = document.createElement('td');
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = rec.inkName || '';
    nameInput.className = 'mono';
    nameInput.addEventListener('change', ()=>{
      rec.inkName = nameInput.value.trim();
      saveInkCurves();
    });
    tdName.appendChild(nameInput);
    tr.appendChild(tdName);

    const tdConc = document.createElement('td');
    const concInput = document.createElement('input');
    concInput.type = 'number';
    concInput.step = '0.01';
    concInput.value = Number(rec.concentration || 0).toString();
    concInput.className = 'mono';
    concInput.addEventListener('change', ()=>{
      const v = parseFloat(concInput.value);
      rec.concentration = (v>0 ? v : 0);
      saveInkCurves();
    });
    tdConc.appendChild(concInput);
    tr.appendChild(tdConc);

    const tdBacking = document.createElement('td');
    const backingSel = document.createElement('select');
    backingSel.innerHTML = '<option value="white">White</option><option value="black">Black</option>';
    backingSel.value = rec.backing || 'white';
    backingSel.addEventListener('change', ()=>{
      rec.backing = backingSel.value;
      saveInkCurves();
    });
    tdBacking.appendChild(backingSel);
    tr.appendChild(tdBacking);

    const tdAngle = document.createElement('td');
    const angleSel = document.createElement('select');
    angleSel.innerHTML = '<option value="2">2°</option><option value="10">10°</option>';
    angleSel.value = rec.angle || '2';
    angleSel.addEventListener('change', ()=>{
      rec.angle = angleSel.value;
      saveInkCurves();
    });
    tdAngle.appendChild(angleSel);
    tr.appendChild(tdAngle);

    const tdIll = document.createElement('td');
    const illSel = document.createElement('select');
    illSel.innerHTML = '<option value="D50">D50</option><option value="D65">D65</option><option value="A">A</option>';
    illSel.value = rec.illuminant || 'D50';
    illSel.addEventListener('change', ()=>{
      rec.illuminant = illSel.value;
      saveInkCurves();
    });
    tdIll.appendChild(illSel);
    tr.appendChild(tdIll);

    const tdAperture = document.createElement('td');
    const apSel = document.createElement('select');
    apSel.innerHTML = '<option value="8mm">8 mm</option><option value="4mm">4 mm</option>';
    apSel.value = rec.aperture || '8mm';
    apSel.addEventListener('change', ()=>{
      rec.aperture = apSel.value;
      saveInkCurves();
    });
    tdAperture.appendChild(apSel);
    tr.appendChild(tdAperture);

    const tdGeom = document.createElement('td');
    const geomSel = document.createElement('select');
    geomSel.innerHTML = '<option value="SCI">SCI</option><option value="SCE">SCE</option>';
    geomSel.value = rec.geometry || 'SCI';
    geomSel.addEventListener('change', ()=>{
      rec.geometry = geomSel.value;
      saveInkCurves();
    });
    tdGeom.appendChild(geomSel);
    tr.appendChild(tdGeom);

    const tdL = document.createElement('td');
    tdL.textContent = Number.isFinite(rec.L) ? rec.L.toFixed(2) : '—';
    tr.appendChild(tdL);

    const tdA = document.createElement('td');
    tdA.textContent = Number.isFinite(rec.a) ? rec.a.toFixed(2) : '—';
    tr.appendChild(tdA);

    const tdB = document.createElement('td');
    tdB.textContent = Number.isFinite(rec.b) ? rec.b.toFixed(2) : '—';
    tr.appendChild(tdB);

    const tdTs = document.createElement('td');
    const tsInput = document.createElement('input');
    tsInput.type = 'text';
    tsInput.className = 'mono';
    tsInput.value = formatTimestamp(rec);
    tsInput.addEventListener('change', ()=>{
      const v = tsInput.value.trim();
      rec.timestampISO = v || null;
      saveInkCurves();
    });
    tdTs.appendChild(tsInput);
    tr.appendChild(tdTs);

    const tdActions = document.createElement('td');
    const delBtn = document.createElement('button');
    delBtn.className = 'btn';
    delBtn.textContent = 'Delete';
    delBtn.addEventListener('click', ()=>{
      if (!confirm('Delete this measurement?')) return;
      INK_CURVES.splice(idx,1);
      saveInkCurves();
      renderInkCurvesTable();
    });
    tdActions.appendChild(delBtn);
    tr.appendChild(tdActions);

    tbody.appendChild(tr);
  });
}

function downloadInkCurvesCsv(){
  if (!INK_CURVES.length){
    alert('No measurements stored yet.');
    return;
  }
  const wavelengths = [];
  for (let wl=400; wl<=700; wl+=10) wavelengths.push(wl);

  const header = [
    'InkName',
    'Concentration',
    'Backing',
    'Angle',
    'Illuminant',
    'Aperture',
    'Geometry',
    'TimestampISO',
    'L',
    'a',
    'b'
  ].concat(wavelengths.map(wl=>'R'+wl));

  const lines = [header.join(',')];

  INK_CURVES.forEach(rec=>{
    const row = [
      rec.inkName || '',
      rec.concentration != null ? rec.concentration : '',
      rec.backing || '',
      rec.angle || '',
      rec.illuminant || '',
      rec.aperture || '',
      rec.geometry || '',
      formatTimestamp(rec),
      rec.L != null ? rec.L : '',
      rec.a != null ? rec.a : '',
      rec.b != null ? rec.b : ''
    ];
    wavelengths.forEach(wl=>{
      const v = rec.spectrum && Object.prototype.hasOwnProperty.call(rec.spectrum,wl)
        ? rec.spectrum[wl]
        : '';
      row.push(v);
    });
    lines.push(row.join(','));
  });

  const blob = new Blob([lines.join('\r\n')],{type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ink_curves.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ===== Compare tab logic + 3D viz =====
function setSwatchFromFields(prefix){
  const L=parseFloat($('#'+prefix+'L').value);
  const a=parseFloat($('#'+prefix+'a').value);
  const b=parseFloat($('#'+prefix+'b').value);
  if ([L,a,b].some(v=>Number.isNaN(v))) return;
  const rgb=labToSrgb(L,a,b);
  $('#swatch'+prefix).style.background=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
  const legend = prefix === 'A' ? $('#legendA') : $('#legendB');
  legend.style.background = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
}
function computeCompareDE(){
  const a={L:parseFloat($('#AL').value),a:parseFloat($('#Aa').value),b:parseFloat($('#Ab').value)};
  const b={L:parseFloat($('#BL').value),a:parseFloat($('#Ba').value),b:parseFloat($('#Bb').value)};
  if ([a.L,a.a,a.b,b.L,b.a,b.b].some(v=>Number.isNaN(v))){
    $('#cmpNumbers').innerHTML=''; $('#cmpResult').style.display='none'; requestLabDraw(); return;
  }
  const de=deltaE2000(a,b), dL=(b.L-a.L), da=(b.a-a.a), db=(b.b-a.b);
  const thr = (SETTINGS && Number.isFinite(SETTINGS.deltaEThreshold)) ? SETTINGS.deltaEThreshold : 2.0;
  const pass = de < thr;
  const cls = pass ? 'de-pass' : 'de-fail';
  const resTxt = pass ? 'PASS' : 'FAIL';

  $('#cmpNumbers').innerHTML=
    `<div class="two-col">
      <div><strong>ΔE2000:</strong> <span class="${cls}">${de.toFixed(2)}</span> <span class="${cls}" style="margin-left:8px;">${resTxt}</span></div>
      <div><strong>ΔL:</strong> ${dL.toFixed(2)} &nbsp; <strong>Δa:</strong> ${da.toFixed(2)} &nbsp; <strong>Δb:</strong> ${db.toFixed(2)} &nbsp; <span class="mini">(threshold: ${thr.toFixed(1)})</span></div>
    </div>`;
  $('#cmpResult').style.display='block';
  requestLabDraw();

  // Optional auto-save (demo-friendly)
  if (SETTINGS && SETTINGS.autoSaveCompare){
    const jobRef = ($('#cmpJobRef').value||'').trim();
    if (jobRef){
      saveCurrentComparison({silent:true});
    }
  }
}
document.addEventListener('input',(e)=>{
  if (e.target && e.target.tagName==='INPUT' && e.target.type==='number'){
    const id=e.target.id||'';
    if (/^(AL|Aa|Ab)$/.test(id)) { setSwatchFromFields('A'); computeCompareDE(); }
    if (/^(BL|Ba|Bb)$/.test(id)) { setSwatchFromFields('B'); computeCompareDE(); }
  }
});


// Batch inputs are editable in this build (manual entry supported).
;

// 3D LAB sphere with coloured panes
const canvas=$('#labCanvas');
const ctx=canvas.getContext('2d');

// 2D readout widgets (a*/b* plane + L* slider)
const LAB_AB_GRID_L = 50; // Fixed L* used for the a*/b* colour field (edit this value)
const abCanvas = document.getElementById('abCanvas');
const abCtx = abCanvas ? abCanvas.getContext('2d') : null;
const lTrack = document.getElementById('lTrack');
const lMarkerA = document.getElementById('lMarkerA');
const lMarkerB = document.getElementById('lMarkerB');
const labNumsA = document.getElementById('labNumsA');
const labNumsB = document.getElementById('labNumsB');
const labTagA = document.getElementById('labTagA');
const labTagB = document.getElementById('labTagB');

function formatLabLine(L,a,b){
  if (![L,a,b].every(Number.isFinite)) return 'L —  a —  b —';
  return `L ${L.toFixed(2)}  a ${a.toFixed(2)}  b ${b.toFixed(2)}`;
}
function setLMarker(marker, L, rgb){
  if (!lTrack || !marker) return NaN;
  if (!Number.isFinite(L)){
    marker.style.display = 'none';
    marker.dataset.y = '';
    return NaN;
  }
  marker.style.display = 'block';
  const pad = 6;
  const h = lTrack.clientHeight || 260;
  const y = pad + (1 - clamp(L/100, 0, 1)) * Math.max(1, (h - pad*2));
  marker.style.top = `${y}px`;

  const col = rgb ? `rgb(${rgb.r},${rgb.g},${rgb.b})` : '#e5e7eb';
  marker.style.background = col;
  marker.style.boxShadow = `0 0 0 2px rgba(0,0,0,.55), 0 0 0 1px rgba(255,255,255,.28) inset`;

  marker.dataset.y = String(y);
  return y;
}
function positionLMarkers(yA, yB){
  const aOk = Number.isFinite(yA);
  const bOk = Number.isFinite(yB);
  if (aOk && bOk && Math.abs(yA - yB) < 14){
    lMarkerA.style.left = '38%';
    lMarkerB.style.left = '62%';
  } else {
    if (lMarkerA) lMarkerA.style.left = '50%';
    if (lMarkerB) lMarkerB.style.left = '50%';
  }
}
function ensureAbCanvasPixels(){
  if (!abCanvas || !abCtx) return null;
  const dpr = window.devicePixelRatio || 1;
  const cssW = Math.max(1, abCanvas.clientWidth || 280);
  const cssH = Math.max(1, abCanvas.clientHeight || cssW);
  const w = Math.round(cssW * dpr);
  const h = Math.round(cssH * dpr);
  if (abCanvas.width !== w || abCanvas.height !== h){
    abCanvas.width = w;
    abCanvas.height = h;
  }
  // draw in CSS pixels
  abCtx.setTransform(dpr,0,0,dpr,0,0);
  return { cssW, cssH };
}
let _abFieldCacheKey = null;
const _abFieldCanvas = document.createElement('canvas');
const _abFieldCtx = _abFieldCanvas.getContext('2d', { willReadFrequently: true });

function drawAbFieldBackground(L, w, h){
  if (!abCtx) return;
  const planeL = clamp(Number.isFinite(L) ? L : 50, 0, 100);
  // Render to a square offscreen canvas at a moderate fixed resolution for speed.
  const res = 260; // good balance of quality/perf; scaled to the visible grid
  const key = `${res}@${Math.round(planeL*2)/2}`;
  if (_abFieldCacheKey !== key){
    _abFieldCacheKey = key;
    _abFieldCanvas.width = res;
    _abFieldCanvas.height = res;
    const img = _abFieldCtx.createImageData(res, res);
    const data = img.data;
    const range = 128;
    for (let y=0; y<res; y++){
      const b = range - (y/(res-1)) * (2*range);
      for (let x=0; x<res; x++){
        const a = -range + (x/(res-1)) * (2*range);
        const rgb = labToSrgb(planeL, a, b);
        const i = (y*res + x) * 4;
        data[i+0] = rgb.r;
        data[i+1] = rgb.g;
        data[i+2] = rgb.b;
        data[i+3] = 255;
      }
    }
    _abFieldCtx.putImageData(img, 0, 0);
  }

  abCtx.save();
  // Subtle darken to keep grid lines/labels readable
  abCtx.globalAlpha = 0.92;
  abCtx.drawImage(_abFieldCanvas, 0, 0, w, h);
  abCtx.globalAlpha = 1;
  abCtx.fillStyle = 'rgba(0,0,0,0.18)';
  abCtx.fillRect(0,0,w,h);
  abCtx.restore();
}

function drawAbGrid(A, B){
  if (!abCanvas || !abCtx) return;
  const dims = ensureAbCanvasPixels();
  if (!dims) return;
  const { cssW:w, cssH:h } = dims;

  abCtx.clearRect(0,0,w,h);

  // Colour field in a*/b* at a fixed L*
  const Lplane = LAB_AB_GRID_L;
  drawAbFieldBackground(Lplane, w, h);

// Border glow
  abCtx.strokeStyle = 'rgba(255,255,255,0.10)';
  abCtx.lineWidth = 1;
  abCtx.strokeRect(0.5,0.5,w-1,h-1);

  const range = 128;
  const toX = (a)=> ( (a + range) / (2*range) ) * w;
  const toY = (b)=> ( (range - b) / (2*range) ) * h;

  // Grid lines every 32
  abCtx.strokeStyle = 'rgba(255,255,255,0.08)';
  abCtx.lineWidth = 1;
  for (let v=-128; v<=128; v+=32){
    const x = toX(v);
    abCtx.beginPath(); abCtx.moveTo(x,0); abCtx.lineTo(x,h); abCtx.stroke();

    const y = toY(v);
    abCtx.beginPath(); abCtx.moveTo(0,y); abCtx.lineTo(w,y); abCtx.stroke();
  }

  // Axes
  abCtx.strokeStyle = 'rgba(255,255,255,0.35)';
  abCtx.lineWidth = 1.5;
  const x0 = toX(0);
  const y0 = toY(0);
  abCtx.beginPath(); abCtx.moveTo(x0,0); abCtx.lineTo(x0,h); abCtx.stroke();
  abCtx.beginPath(); abCtx.moveTo(0,y0); abCtx.lineTo(w,y0); abCtx.stroke();

  function drawPtDot(pt){
    if (!pt || ![pt.a, pt.b].every(Number.isFinite)) return null;
    const rgb = labToSrgb(pt.L, pt.a, pt.b);
    const x = toX(pt.a), y = toY(pt.b);

    abCtx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
    abCtx.strokeStyle = 'rgba(0,0,0,0.60)';
    abCtx.lineWidth = 2;
    abCtx.beginPath();
    abCtx.arc(x,y,6,0,Math.PI*2);
    abCtx.fill();
    abCtx.stroke();
    return { x, y, rgb };
  }

  function drawPtLabel(text, x, y, side, dy){
    const w = abCanvas.clientWidth || 280;
    const h = abCanvas.clientHeight || 280;

    let dx = side === 'left' ? -10 : 10;

    // Avoid clipping at edges
    if (side === 'left' && x < 38){ side = 'right'; dx = 10; }
    if (side === 'right' && x > w - 38){ side = 'left'; dx = -10; }

    abCtx.save();
    abCtx.fillStyle = '#e5e7eb';
    abCtx.font = '12px ui-sans-serif, system-ui';
    abCtx.textBaseline = 'middle';
    abCtx.textAlign = side === 'left' ? 'right' : 'left';
    abCtx.shadowColor = 'rgba(0,0,0,.85)';
    abCtx.shadowBlur = 6;
    abCtx.shadowOffsetY = 1;
    abCtx.fillText(text, x + dx, y + dy);
    abCtx.restore();
  }

  const pA = drawPtDot(A);
  const pB = drawPtDot(B);

  let dyA = -12, dyB = -12;
  if (pA && pB){
    const d = Math.hypot(pA.x - pB.x, pA.y - pB.y);
    if (d < 14){ dyA = -18; dyB = 10; }
  }

  if (pA) drawPtLabel('Std', pA.x, pA.y, 'left', dyA);
  if (pB) drawPtLabel('Batch', pB.x, pB.y, 'right', dyB);
}
function updateLabReadout(){
  const A = { L: parseFloat(document.getElementById('AL')?.value), a: parseFloat(document.getElementById('Aa')?.value), b: parseFloat(document.getElementById('Ab')?.value) };
  const B = { L: parseFloat(document.getElementById('BL')?.value), a: parseFloat(document.getElementById('Ba')?.value), b: parseFloat(document.getElementById('Bb')?.value) };

  const aOk = [A.L,A.a,A.b].every(Number.isFinite);
  const bOk = [B.L,B.a,B.b].every(Number.isFinite);

  if (labNumsA) labNumsA.textContent = formatLabLine(A.L,A.a,A.b);
  if (labNumsB) labNumsB.textContent = formatLabLine(B.L,B.a,B.b);

  // Colour the tags to match swatches (so the readout legend stays obvious)
  if (labTagA && aOk){
    const rgb = labToSrgb(A.L,A.a,A.b);
    labTagA.style.borderColor = `rgba(${rgb.r},${rgb.g},${rgb.b},0.55)`;
    labTagA.style.boxShadow = `0 0 0 1px rgba(${rgb.r},${rgb.g},${rgb.b},0.25) inset`;
  }
  if (labTagB && bOk){
    const rgb = labToSrgb(B.L,B.a,B.b);
    labTagB.style.borderColor = `rgba(${rgb.r},${rgb.g},${rgb.b},0.55)`;
    labTagB.style.boxShadow = `0 0 0 1px rgba(${rgb.r},${rgb.g},${rgb.b},0.25) inset`;
  }

  const rgbA = aOk ? labToSrgb(A.L,A.a,A.b) : null;
  const rgbB = bOk ? labToSrgb(B.L,B.a,B.b) : null;
  const yA = setLMarker(lMarkerA, aOk ? A.L : NaN, rgbA);
  const yB = setLMarker(lMarkerB, bOk ? B.L : NaN, rgbB);
  positionLMarkers(yA, yB);

  drawAbGrid(aOk ? A : null, bOk ? B : null);
}
window.addEventListener('resize', ()=>{ updateLabReadout(); }, { passive:true });
const DEFAULT_VIEW={rx:-0.6, ry:0.8, s:220};
let rotX=DEFAULT_VIEW.rx, rotY=DEFAULT_VIEW.ry, scale3d=DEFAULT_VIEW.s;
let dragging=false,lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{
  dragging=true;
  lastX=e.clientX;
  lastY=e.clientY;
});
window.addEventListener('mouseup',()=>{ dragging=false; });
window.addEventListener('mousemove',e=>{
  if(!dragging) return;
  const dx=(e.clientX-lastX);
  const dy=(e.clientY-lastY);
  lastX=e.clientX;
  lastY=e.clientY;
  rotY -= dx*0.005;
  rotX -= dy*0.005;
  requestLabDraw();
});
canvas.addEventListener('wheel', e=>{
  // Leave wheel scrolling to the page; no zooming on the orb view.
}, {passive:true});
$('#resetView').addEventListener('click', ()=>{
  rotX=DEFAULT_VIEW.rx;
  rotY=DEFAULT_VIEW.ry;
  scale3d=DEFAULT_VIEW.s;
  requestLabDraw();
});

function normLab(L,a,b){
  return { x:(a/128), y:((L-50)/50), z:(b/128) };
}
function rot3(p){
  const cX=Math.cos(rotX), sX=Math.sin(rotX), cY=Math.cos(rotY), sY=Math.sin(rotY);
  let y=p.y*cX - p.z*sX;
  let z=p.y*sX + p.z*cX;
  let x=p.x*cY + z*sY;
  z = -p.x*sY + z*cY;
  return {x,y,z};
}
function proj(p){
  const d=3;
  const z=p.z+3.5;
  const k=d/(z);
  return {u:canvas.width/2 + p.x*scale3d*k, v:canvas.height/2 - p.y*scale3d*k, k:k, z:p.z};
}

function drawSpherePanes(){
  const R=1.08, M=24, P=18, baseAlpha=0.20;
  const thetas=[...Array(M)].map((_,i)=>-Math.PI + i*(2*Math.PI/(M-1)));
  const phis=[...Array(P)].map((_,j)=>-Math.PI/2 + j*((Math.PI)/(P-1)));
  function objPoint(phi,theta){
    return { x0:R*Math.cos(phi)*Math.cos(theta), y0:R*Math.sin(phi), z0:R*Math.cos(phi)*Math.sin(theta) };
  }
  function toScreen(o){
    const pr=rot3({x:o.x0,y:o.y0,z:o.z0});
    const sc=proj(pr);
    return {u:sc.u,v:sc.v,z:pr.z,k:sc.k};
  }
  function rgbaFromObj(o,a){
    const L=o.y0*50+50, A=o.x0*128, B=o.z0*128;
    const rgb=labToSrgb(L,A,B);
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
  }
  const quads=[];
  for(let j=0,idx=0;j<P-1;j++){
    for(let i=0;i<M-1;i++,idx++){
      const o00=objPoint(phis[j],thetas[i]), o10=objPoint(phis[j],thetas[i+1]);
      const o01=objPoint(phis[j+1],thetas[i]), o11=objPoint(phis[j+1],thetas[i+1]);
      const ux=o10.x0-o00.x0, uy=o10.y0-o00.y0, uz=o10.z0-o00.z0;
      const vx=o01.x0-o00.x0, vy=o01.y0-o00.y0, vz=o01.z0-o00.z0;
      const nx=uy*vz-uz*vy, ny=uz*vx-ux*vz, nz=ux*vy-uy*vx;
      const nRot=rot3({x:nx,y:ny,z:nz});
      const nLen=Math.hypot(nRot.x,nRot.y,nRot.z)||1e-9;
      const nzCam=nRot.z/nLen;
      if (nzCam < -0.15) continue;
      const vis = (nzCam<=0)?0: (nzCam>=0.1?1:(nzCam/0.1));
      const alpha=baseAlpha*(0.15+0.85*vis);
      const s00=toScreen(o00), s10=toScreen(o10), s01=toScreen(o01), s11=toScreen(o11);
      const avgZ=(s00.z+s10.z+s01.z+s11.z)/4;
      const oMid={
        x0:(o00.x0+o10.x0+o01.x0+o11.x0)/4,
        y0:(o00.y0+o10.y0+o01.y0+o11.y0)/4,
        z0:(o00.z0+o10.z0+o01.z0+o11.z0)/4
      };
      const col=rgbaFromObj(oMid,alpha);
      const stableZ = avgZ + ((i*37 + j*101) % 113) * 1e-6;
      quads.push({stableZ, col, pts:[s00,s10,s11,s01]});
    }
  }
  quads.sort((a,b)=> a.stableZ - b.stableZ);
  ctx.save();
  ctx.lineWidth=0.6;
  for(const q of quads){
    ctx.fillStyle=q.col;
    ctx.strokeStyle='rgba(255,255,255,0.05)';
    ctx.beginPath();
    ctx.moveTo(q.pts[0].u,q.pts[0].v);
    for(let k=1;k<q.pts.length;k++) ctx.lineTo(q.pts[k].u,q.pts[k].v);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();
}
function drawSphere(){
  const R=1.1, MER=28, PAR=20, STEP=Math.PI/64;
  function tint(x0,y0,z0,a){
    const L=y0*50+50,A=x0*128,B=z0*128;
    const rgb=labToSrgb(L,A,B);
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
  }
  const c=proj(rot3({x:0,y:0,z:0})), edge=proj(rot3({x:R,y:0,z:0}));
  const rad=Math.hypot(edge.u-c.u, edge.v-c.v);
  ctx.strokeStyle='rgba(255,255,255,0.28)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(c.u,c.v,rad,0,Math.PI*2);
  ctx.stroke();
  for(let i=0;i<MER;i++){
    const th=-Math.PI + i*(2*Math.PI/(MER-1));
    let first=true,lastObj=null,lastScr=null;
    for(let t=-Math.PI/2;t<=Math.PI/2;t+=STEP){
      const x0=R*Math.cos(t)*Math.cos(th), y0=R*Math.sin(t), z0=R*Math.cos(t)*Math.sin(th);
      const p=rot3({x:x0,y:y0,z:z0}), q=proj(p);
      if(!first){
        const mx0=(lastObj.x+x0)/2,my0=(lastObj.y+y0)/2,mz0=(lastObj.z+z0)/2;
        ctx.strokeStyle=tint(mx0,my0,mz0,0.22);
        ctx.lineWidth=1.6;
        ctx.beginPath();
        ctx.moveTo(lastScr.u,lastScr.v);
        ctx.lineTo(q.u,q.v);
        ctx.stroke();
      }
      first=false;
      lastObj={x:x0,y:y0,z:z0};
      lastScr=q;
    }
  }
  for(let j=0;j<PAR;j++){
    const ph=-Math.PI/2 + j*(Math.PI/(PAR-1));
    let first=true,lastObj2=null,lastScr2=null;
    for(let t=-Math.PI;t<=Math.PI;t+=STEP){
      const x0=R*Math.cos(ph)*Math.cos(t), y0=R*Math.sin(ph), z0=R*Math.cos(ph)*Math.sin(t);
      const p=rot3({x:x0,y:y0,z:z0}), q=proj(p);
      if(!first){
        const mx0=(lastObj2.x+x0)/2,my0=(lastObj2.y+y0)/2,mz0=(lastObj2.z+z0)/2;
        ctx.strokeStyle=tint(mx0,my0,mz0,0.22);
        ctx.lineWidth=1.6;
        ctx.beginPath();
        ctx.moveTo(lastScr2.u,lastScr2.v);
        ctx.lineTo(q.u,q.v);
        ctx.stroke();
      }
      first=false;
      lastObj2={x:x0,y:y0,z:z0};
      lastScr2=q;
    }
  }
}
function drawPointLab(L,a,b,label){
  const p=proj(rot3(normLab(L,a,b)));
  const rgb=labToSrgb(L,a,b);
  const col=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
  ctx.fillStyle=col;
  ctx.strokeStyle='rgba(0,0,0,0.55)';
  ctx.beginPath();
  ctx.arc(p.u,p.v,6*p.k,0,Math.PI*2);
  ctx.fill();
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.fillStyle='#e5e7eb';
  ctx.font='12px ui-sans-serif, system-ui';
  ctx.fillText(label, p.u+8, p.v-8);
  return p;
}
function drawLineLab(A,B){
  const p1=proj(rot3(normLab(A.L,A.a,A.b)));
  const p2=proj(rot3(normLab(B.L,B.a,B.b)));
  ctx.strokeStyle='rgba(255,255,255,0.6)';
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(p1.u,p1.v);
  ctx.lineTo(p2.u,p2.v);
  ctx.stroke();
}
function drawAxes(){
  const axes=[
    {from:{L:50,a:-128,b:0},to:{L:50,a:128,b:0},label:'+a*'},
    {from:{L:0,a:0,b:0},to:{L:100,a:0,b:0},label:'L*'},
    {from:{L:50,a:0,b:-128},to:{L:50,a:0,b:128},label:'+b*'}
  ];
  ctx.lineWidth=2.2;
  ctx.strokeStyle='rgba(255,255,255,0.9)';
  ctx.fillStyle='#e5e7eb';
  ctx.font='12px ui-sans-serif, system-ui';
  axes.forEach(ax=>{
    const p1=proj(rot3(normLab(ax.from.L,ax.from.a,ax.from.b)));
    const p2=proj(rot3(normLab(ax.to.L,ax.to.a,ax.to.b)));
    ctx.beginPath();
    ctx.moveTo(p1.u,p1.v);
    ctx.lineTo(p2.u,p2.v);
    ctx.stroke();
    const T=6;
    for(let i=1;i<T;i++){
      const t=i/T;
      const L=ax.from.L+(ax.to.L-ax.from.L)*t;
      const a=ax.from.a+(ax.to.a-ax.from.a)*t;
      const b=ax.from.b+(ax.to.b-ax.from.b)*t;
      const p=proj(rot3(normLab(L,a,b)));
      const dirX=(p2.u-p1.u), dirV=(p2.v-p1.v);
      const len=Math.hypot(dirX,dirV)||1;
      const nx=-dirV/len, ny=dirX/len;
      const tick=6*p.k;
      ctx.beginPath();
      ctx.moveTo(p.u-nx*tick,p.v-ny*tick);
      ctx.lineTo(p.u+nx*tick,p.v+ny*tick);
      ctx.stroke();
    }
    ctx.fillText(ax.label, p2.u+6, p2.v-6);
  });
}
function drawLabScene(){
  const a={L:parseFloat($('#AL').value), a:parseFloat($('#Aa').value), b:parseFloat($('#Ab').value)};
  const b={L:parseFloat($('#BL').value), a:parseFloat($('#Ba').value), b:parseFloat($('#Bb').value)};
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#0f1219';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawSpherePanes();
  drawSphere();
  drawAxes();
  const aValid=[a.L,a.a,a.b].every(Number.isFinite);
  const bValid=[b.L,b.a,b.b].every(Number.isFinite);
  if (aValid && bValid){
    drawLineLab(a,b);
    drawPointLab(a.L,a.a,a.b,'Std');
    drawPointLab(b.L,b.a,b.b,'Batch');
    const de=deltaE2000(a,b);
    ctx.fillStyle='#e5e7eb';
    ctx.font='13px ui-sans-serif, system-ui';
    ctx.fillText('ΔE2000: '+de.toFixed(2), 12, 18);
  } else {
    ctx.fillStyle='#e5e7eb';
    ctx.font='13px ui-sans-serif, system-ui';
    ctx.fillText('Enter L*a*b* for both Standard and Batch to render.', 12, 18);
  }
}
let rafId=null;
function requestLabDraw(){
  if(rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(()=>{
    rafId=null;
    drawLabScene();
    updateLabReadout();
  });
}

// Spectro UI wiring (all tabs)
const spectroConnectBtnLib = document.getElementById('spectroConnectBtn');
const spectroConnectBtnMatch = document.getElementById('spectroConnectBtnMatch');
const spectroConnectBtnCompare = document.getElementById('spectroConnectBtnCompare');
const spectroMeasureBtn = document.getElementById('spectroMeasureBtn');
const spectroExportBtn = document.getElementById('spectroExportBtn');
const spectroScanTargetBtn = document.getElementById('spectroScanTargetBtn');
const spectroScanCompareABtn = document.getElementById('spectroScanCompareABtn');
const spectroScanCompareBBtn = document.getElementById('spectroScanCompareBBtn');

[spectroConnectBtnLib, spectroConnectBtnMatch, spectroConnectBtnCompare].forEach(btn=>{
  if (!btn) return;
  btn.addEventListener('click', async ()=>{
    try{
      await spectroConnect();
    }catch(_e){}
  });
});

if (spectroMeasureBtn){
  spectroMeasureBtn.addEventListener('click', async ()=>{
    const inkName = (document.getElementById('spectroInkName').value || '').trim();
    const concStr = (document.getElementById('spectroConcentration').value || '').trim();
    const backing = (document.getElementById('spectroBacking').value || 'white');
    const angle = (document.getElementById('spectroAngle').value || '2');
    const illuminant = (document.getElementById('spectroIlluminant').value || 'D50');
    const aperture = (document.getElementById('spectroAperture').value || '8mm');
    const geometry = (document.getElementById('spectroGeometry').value || 'SCI');

    if (!inkName){
      alert('Please enter an ink name.');
      return;
    }
    const concentration = parseFloat(concStr);
    if (!(concentration > 0)){
      alert('Please enter a valid concentration (e.g. 0.10 for 10%).');
      return;
    }
    try{
      await spectroConnect();
      const raw = await spectroMeasureOnce();
      const meas = parseSpectroMeasurement(raw);
      if ([meas.L,meas.a,meas.b].some(v=>!Number.isFinite(v))){
        alert('Got a response but could not parse L*a*b*. Check console.');
        console.log('Raw spectro text:', raw);
        return;
      }
      const rec = addInkCurveRecord(inkName, concentration, backing, angle, illuminant, aperture, geometry, meas);

      const tsPreview = document.getElementById('spectroTimestampPreview');
      if (tsPreview){
        tsPreview.value = rec.timestampISO || '';
      }

      const LInput = document.getElementById('L');
      const aInput = document.getElementById('a');
      const bInput = document.getElementById('b');
      if (LInput && aInput && bInput){
        LInput.value = rec.L;
        aInput.value = rec.a;
        bInput.value = rec.b;
        updateTargetEcho();
      }
      const s = document.getElementById('spectroStatus');
      if (s) s.textContent = `Saved: ${rec.inkName} @ ${rec.concentration} (${INK_CURVES.length} total)`;
    }catch(err){
      const s = document.getElementById('spectroStatus');
      if (s) s.textContent = 'Error: ' + (err.message || err);
    }
  });
}

if (spectroExportBtn){
  spectroExportBtn.addEventListener('click', downloadInkCurvesCsv);
}

if (spectroScanTargetBtn){
  spectroScanTargetBtn.addEventListener('click', async ()=>{
    try{
      await spectroConnect();
      const raw = await spectroMeasureOnce();
      const meas = parseSpectroMeasurement(raw);
      if ([meas.L,meas.a,meas.b].some(v=>!Number.isFinite(v))){
        alert('Got a response but could not parse L*a*b*. Check console.');
        console.log('Raw spectro text:', raw);
        return;
      }
      const LInput = document.getElementById('L');
      const aInput = document.getElementById('a');
      const bInput = document.getElementById('b');
      if (LInput && aInput && bInput){
        LInput.value = meas.L;
        aInput.value = meas.a;
        bInput.value = meas.b;
        updateTargetEcho();
      }
    }catch(err){
      const s = document.getElementById('spectroStatus');
      if (s) s.textContent = 'Error: ' + (err.message || err);
    }
  });
}

if (spectroScanCompareABtn){
  spectroScanCompareABtn.addEventListener('click', async ()=>{
    try{
      await spectroConnect();
      const raw = await spectroMeasureOnce();
      const meas = parseSpectroMeasurement(raw);
      if ([meas.L,meas.a,meas.b].some(v=>!Number.isFinite(v))){
        alert('Got a response but could not parse L*a*b*. Check console.');
        console.log('Raw spectro text:', raw);
        return;
      }
      const AL = document.getElementById('AL');
      const Aa = document.getElementById('Aa');
      const Ab = document.getElementById('Ab');
      if (AL && Aa && Ab){
        AL.value = meas.L;
        Aa.value = meas.a;
        Ab.value = meas.b;
        setSwatchFromFields('A');
        computeCompareDE();
      }
    }catch(err){
      const s = document.getElementById('spectroStatus');
      if (s) s.textContent = 'Error: ' + (err.message || err);
    }
  });
}

if (spectroScanCompareBBtn){
  spectroScanCompareBBtn.addEventListener('click', async ()=>{
    try{
      await spectroConnect();
      const raw = await spectroMeasureOnce();
      const meas = parseSpectroMeasurement(raw);
      if ([meas.L,meas.a,meas.b].some(v=>!Number.isFinite(v))){
        alert('Got a response but could not parse L*a*b*. Check console.');
        console.log('Raw spectro text:', raw);
        return;
      }
      const BL = document.getElementById('BL');
      const Ba = document.getElementById('Ba');
      const Bb = document.getElementById('Bb');
      if (BL && Ba && Bb){
        BL.value = meas.L;
        Ba.value = meas.a;
        Bb.value = meas.b;
        setSwatchFromFields('B');
        computeCompareDE();
      }
    }catch(err){
      const s = document.getElementById('spectroStatus');
      if (s) s.textContent = 'Error: ' + (err.message || err);
    }
  });
}

// ===== QC combobox (Standard) + History =====
let CMP_STANDARD_NAME = '';

function normText(s){
  return String(s||'')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g,' ')
    .trim();
}
function tokensOf(s){
  const t = normText(s);
  return t ? t.split(/\s+/).filter(Boolean) : [];
}

// Forgiving match:
// - split query into tokens
// - "match" if all tokens appear somewhere in name
// - score boosts earlier occurrences, more token matches, shorter names
function scoreName(name, query){
  const n = normText(name);
  const qTokens = tokensOf(query);
  if (!qTokens.length) return { score:0, match:true, hit:'' };
  let posSum = 0;
  for (const tok of qTokens){
    const idx = n.indexOf(tok);
    if (idx < 0) return { score:-1e9, match:false, hit:'' };
    posSum += idx;
  }
  // Higher is better
  const score = (qTokens.length*10000) - (posSum*10) - (n.length);
  return { score, match:true, hit:qTokens[0] };
}

function bestColourByQuery(query){
  const q = (query||'').trim();
  if (!q) return null;
  // exact first
  const exact = COLOURS.find(x => (x.name||x.Colour||x.color||'') === q);
  if (exact) return exact;
  // forgiving match
  let best = null;
  let bestScore = -1e18;
  COLOURS.forEach(c=>{
    const name = (c.name||c.Colour||c.color||'').trim();
    if (!name) return;
    const s = scoreName(name, q);
    if (!s.match) return;
    if (s.score > bestScore){ bestScore = s.score; best = c; }
  });
  return best;
}

function loadCompareByQuery(which, query){
  const c = bestColourByQuery(query);
  if (!c) return false;
  const nm = (c.name||c.Colour||c.color||'').trim();
  if (which === 'A') CMP_STANDARD_NAME = nm;
  if (which === 'A'){
    $('#AL').value = c.L; $('#Aa').value = c.a; $('#Ab').value = c.b;
    setSwatchFromFields('A');
  } else {
    $('#BL').value = c.L; $('#Ba').value = c.a; $('#Bb').value = c.b;
    setSwatchFromFields('B');
  }
  computeCompareDE();
  return true;
}

function closeCombo(drop){
  if (!drop) return;
  drop.classList.add('hide');
}

function refreshCompareStandardCombo(){
  const input = document.getElementById('cmpASelect');
  const drop = document.getElementById('cmpADrop');
  if (!input || !drop) return;

  const allNames = COLOURS
    .map(c => (c.name||c.Colour||c.color||'').trim())
    .filter(Boolean);

  const render = (q)=>{
    const query = (q||'').trim();
    const scored = allNames.map(name=>({ name, ...scoreName(name, query) }));
    // Show ALL options: matches first (sorted), then non-matches alphabetically
    const matches = scored.filter(x=>x.match).sort((a,b)=> b.score-a.score || a.name.localeCompare(b.name));
    const rest = scored.filter(x=>!x.match).sort((a,b)=> a.name.localeCompare(b.name));
    const merged = matches.concat(rest);

    // Build DOM
    drop.innerHTML = '';
    const frag = document.createDocumentFragment();
    merged.forEach(x=>{
      const div = document.createElement('div');
      div.className = 'combo-item';
      // lightweight highlight for first token only (keeps it readable)
      const t = tokensOf(query)[0];
      if (t){
        const idx = normText(x.name).indexOf(t);
        if (idx >= 0){
          // Don't try to map indices back to original string; just bold the whole name when it matches.
          div.innerHTML = `<span class="hit">${x.name.replace(/</g,'&lt;')}</span>`;
        } else {
          div.textContent = x.name;
        }
      } else {
        div.textContent = x.name;
      }
      div.addEventListener('mousedown', (e)=>{
        // mousedown to avoid blur closing before click
        e.preventDefault();
        input.value = x.name;
        CMP_STANDARD_NAME = x.name;
        loadCompareByQuery('A', x.name);
        closeCombo(drop);
      });
      frag.appendChild(div);
    });
    drop.appendChild(frag);
  };

  // Initial fill (alphabetical)
  render('');

  const open = ()=>{ drop.classList.remove('hide'); };

  input.addEventListener('focus', ()=>{ render(input.value); open(); });
  input.addEventListener('click', ()=>{ render(input.value); open(); });
  input.addEventListener('input', ()=>{ render(input.value); open(); });
  input.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape'){ closeCombo(drop); return; }
    if (e.key === 'Enter'){
      // Auto-load best match (forgiving)
      const q = input.value;
      const best = bestColourByQuery(q);
      if (best){
        const nm = (best.name||best.Colour||best.color||'').trim();
        input.value = nm;
        CMP_STANDARD_NAME = nm;
        loadCompareByQuery('A', nm);
      }
      closeCombo(drop);
    }
  });
  input.addEventListener('blur', ()=>{
    // Delay so list mousedown can run
    setTimeout(()=> closeCombo(drop), 120);
  });

  // Clicking elsewhere closes
  document.addEventListener('mousedown', (e)=>{
    if (!drop || drop.classList.contains('hide')) return;
    const within = drop.contains(e.target) || input.contains(e.target);
    if (!within) closeCombo(drop);
  });
}function refreshMatchColourCombo(){
  const input = document.getElementById('matchColourSelect');
  const drop = document.getElementById('matchColourDrop');
  if (!input || !drop) return;

  const allNames = COLOURS
    .map(c => (c.name||c.Colour||c.color||'').trim())
    .filter(Boolean);

  const render = (q)=>{
    const query = (q||'').trim();
    const scored = allNames.map(name=>({ name, ...scoreName(name, query) }));
    const matches = scored.filter(x=>x.match).sort((a,b)=> b.score-a.score || a.name.localeCompare(b.name));
    const rest = scored.filter(x=>!x.match).sort((a,b)=> a.name.localeCompare(b.name));
    const merged = matches.concat(rest);

    drop.innerHTML = '';
    const frag = document.createDocumentFragment();
    merged.forEach(x=>{
      const div = document.createElement('div');
      div.className = 'combo-item';
      const t = tokensOf(query)[0];
      if (t){
        const idx = normText(x.name).indexOf(t);
        if (idx >= 0){
          div.innerHTML = `<span class="hit">${x.name.replace(/</g,'&lt;')}</span>`;
        } else {
          div.textContent = x.name;
        }
      } else {
        div.textContent = x.name;
      }

      div.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        input.value = x.name;

        const c = bestColourByQuery(x.name);
        if (c){
          document.getElementById('L').value = c.L;
          document.getElementById('a').value = c.a;
          document.getElementById('b').value = c.b;
          updateTargetEcho();
          showFormulaFor(x.name);
          _lastContextName = x.name;
          // Mirror selection into Mixing Guide
          mixSetPantoneFromOutside(x.name);
        }
        closeCombo(drop);
      });

      frag.appendChild(div);
    });
    drop.appendChild(frag);
  };

  render('');

  const open = ()=>{ drop.classList.remove('hide'); };

  input.addEventListener('focus', ()=>{ render(input.value); open(); });
  input.addEventListener('click', ()=>{ render(input.value); open(); });
  input.addEventListener('input', ()=>{ render(input.value); open(); });
  input.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape'){ closeCombo(drop); return; }
    if (e.key === 'Enter'){
      const best = bestColourByQuery(input.value);
      if (best){
        const nm = (best.name||best.Colour||best.color||'').trim();
        input.value = nm;
        document.getElementById('L').value = best.L;
        document.getElementById('a').value = best.a;
        document.getElementById('b').value = best.b;
        updateTargetEcho();
        showFormulaFor(nm);
        _lastContextName = nm;
        // Mirror selection into Mixing Guide
        mixSetPantoneFromOutside(nm);
      }
      closeCombo(drop);
    }
  });
  input.addEventListener('blur', ()=>{
    setTimeout(()=> closeCombo(drop), 120);
  });

  document.addEventListener('mousedown', (e)=>{
    if (!drop || drop.classList.contains('hide')) return;
    const within = drop.contains(e.target) || input.contains(e.target);
    if (!within) closeCombo(drop);
  });
}

function isoDateOnly(ts){
  try{ return new Date(ts).toISOString().slice(0,10); }catch(e){ return ''; }
}
function filteredAndSortedCompareLog(forExport){
  const from = document.getElementById('histFrom')?.value || '';
  const to = document.getElementById('histTo')?.value || '';
  const jobQ = (document.getElementById('histJob')?.value || '').trim().toLowerCase();
  const stdQ = (document.getElementById('histStandard')?.value || '').trim().toLowerCase();
  const lib = document.getElementById('histLibrary')?.value || '';
  const sort = document.getElementById('histSort')?.value || 'date_desc';

  let rows = CMP_LOG.slice();
  rows = rows.filter(r=>{
    if (from && isoDateOnly(r.ts) < from) return false;
    if (to && isoDateOnly(r.ts) > to) return false;
    if (jobQ && !String(r.jobRef||'').toLowerCase().includes(jobQ)) return false;
    if (stdQ && !String(r.standardName||'').toLowerCase().includes(stdQ)) return false;
    if (lib && String(r.libraryId||'') !== lib) return false;
    return true;
  });

  const by = {
    date_desc: (a,b)=>(b.ts||0)-(a.ts||0),
    date_asc:  (a,b)=>(a.ts||0)-(b.ts||0),
    job_asc:   (a,b)=>String(a.jobRef||'').localeCompare(String(b.jobRef||'')),
    std_asc:   (a,b)=>String(a.standardName||'').localeCompare(String(b.standardName||'')),
    de_asc:    (a,b)=>(+a.deltaE)-(+b.deltaE),
    de_desc:   (a,b)=>(+b.deltaE)-(+a.deltaE)
  };
  rows.sort(by[sort] || by.date_desc);
  return rows;
}


// ===== Mixing guide (reads Combined mixing guide workbook) =====
let MIX_GUIDE = null; // { sheets:{[sheetName]: {rows:[...], byPantone:Map}}, ready:boolean }
let MIX_ACTIVE_PANTONE = '';

// Sync helper: when a Pantone is selected in the Mixing Guide, mirror it back into Match & Predict.
function matchSetPantoneFromOutside(name){
  const nm = (name||'').trim();
  if (!nm) return;

  const matchInput = document.getElementById('matchColourSelect');
  if (matchInput) matchInput.value = nm;

  // If the library has this Pantone, also populate L*a*b* and refresh the suggestion display.
  try{
    const c = bestColourByQuery(nm);
    if (c){
      const L = document.getElementById('L');
      const a = document.getElementById('a');
      const b = document.getElementById('b');
      if (L) L.value = c.L;
      if (a) a.value = c.a;
      if (b) b.value = c.b;
      updateTargetEcho();
      showFormulaFor(nm);
      _lastContextName = nm;
    }
  }catch(e){ /* non-fatal */ }
}

function mixNormalisePantoneName(s){
  return String(s||'').trim().toUpperCase().replace(/\s+/g,' ');
}

function mixSheetName(range, anilox){
  return String(range||'A') + String(anilox||'6v');
}

function mixParseWorkbook(wb){
  const sheets = {};
  (wb.SheetNames||[]).forEach(name=>{
    if (!/^[A-D][4-7]v$/.test(name)) return;
    const ws = wb.Sheets[name];
    if (!ws) return;
    const rows = XLSX.utils.sheet_to_json(ws, {header:1, raw:true, defval:null});
    const out = [];
    for (let i=0;i<rows.length;i++){
      const r = rows[i];
      const pantone = (r && r[0]) ? String(r[0]).trim() : '';
      if (!pantone) continue;
      // expected: A=pantone, then (ink,%) pairs across cols 1..10, then ΔE around col 11
      const ingredients = [];
      for (let c=1; c<=10; c+=2){
        const ink = r[c];
        const pct = r[c+1];
        if (!ink) continue;
        const inkName = String(ink).trim();
        const pctNum = typeof pct === 'number' ? pct : parseFloat(pct);
        if (!inkName) continue;
        if (!(pctNum >= 0)) continue;
        if (pctNum === 0) continue;
        ingredients.push({ ink: inkName, pct: +pctNum });
      }
      const deCell = r[11];
      const deltaE = typeof deCell === 'number' ? deCell : parseFloat(deCell);
      out.push({
        pantone: pantone,
        pantoneNorm: mixNormalisePantoneName(pantone),
        ingredients,
        deltaE: Number.isFinite(deltaE) ? +deltaE : null
      });
    }
    const byPantone = new Map();
    out.forEach(rec=>{
      if (!byPantone.has(rec.pantoneNorm)) byPantone.set(rec.pantoneNorm, rec);
    });
    sheets[name] = { rows: out, byPantone };
  });

  return { sheets, ready: true };
}

async function mixLoadWorkbookFromUrl(url){
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Could not fetch workbook (${res.status})`);
  const buf = await res.arrayBuffer();
  return XLSX.read(buf, {type:'array', cellDates:false, cellText:false});
}

async function mixLoadWorkbookFromFile(file){
  const buf = await file.arrayBuffer();
  return XLSX.read(buf, {type:'array', cellDates:false, cellText:false});
}

function mixSetStatus(msg, cls){
  const el = document.getElementById('mixGuideStatus');
  if (!el) return;
  el.textContent = msg || '';
  el.className = 'mini ' + (cls||'');
}

function mixGetActiveTable(){
  const range = document.getElementById('mixInkRange')?.value || 'A';
  const anilox = document.getElementById('mixAnilox')?.value || '6v';
  const sheet = mixSheetName(range, anilox);
  if (!MIX_GUIDE || !MIX_GUIDE.sheets || !MIX_GUIDE.sheets[sheet]) return { sheet, table:null };
  return { sheet, table: MIX_GUIDE.sheets[sheet] };
}

function mixParseAniloxVolume(aniloxStr){
  // Excel uses LEFT(F3,1) where F3 is like "6v"
  const m = String(aniloxStr||'').trim().match(/^\s*(\d+(?:\.\d+)?)/);
  return m ? parseFloat(m[1]) : NaN;
}

function mixUpdateInkCalc(){
  // Tray volume is assumed to be 0 (removed from UI)
  const tray = 0;

  const linear = parseFloat(document.getElementById('mixLinearM')?.value || '0');
  const width = parseFloat(document.getElementById('mixWebWidth')?.value || '0');
  const cov = parseFloat(document.getElementById('mixCoverage')?.value || '0');
  const aniloxStr = document.getElementById('mixAnilox')?.value || '';
  const aniloxVol = mixParseAniloxVolume(aniloxStr);

  const sq = (Number.isFinite(linear) ? linear : 0) * (Number.isFinite(width) ? width : 0) / 1000;
  const sqEl = document.getElementById('mixSquareM');
  if (sqEl) sqEl.textContent = Number.isFinite(sq) ? sq.toFixed(2) : '—';

  const anEl = document.getElementById('mixAniloxVol');
  if (anEl) anEl.textContent = Number.isFinite(aniloxVol) ? String(aniloxVol) : '—';

  // Excel logic (with Tray forced to 0):
  // Ink Required = 3 * ((SqM * %Coverage)/100) * (Anilox/10000) + Tray
  const covSafe = Number.isFinite(cov) ? cov : 0;
  const anSafe = Number.isFinite(aniloxVol) ? aniloxVol : 0;
  const inkReq = 3 * (((sq * covSafe) / 100) * (anSafe / 10000)) + tray;

  const inkEl = document.getElementById('mixInkReq');
  if (inkEl){
    if (Number.isFinite(inkReq)){
      inkEl.textContent = inkReq.toFixed(3);
      inkEl.dataset.value = String(inkReq);
    } else {
      inkEl.textContent = '—';
      inkEl.dataset.value = '';
    }
  }
}



function mixRenderFormula(){
  const qtyKg = parseFloat(document.getElementById('mixQtyKg')?.value || '1');
  const tbody = document.getElementById('mixFormulaTbody');
  const deEl = document.getElementById('mixDeltaE');
  const sheetEl = document.getElementById('mixSheetUsed');

  if (sheetEl){
    const { sheet } = mixGetActiveTable();
    sheetEl.textContent = sheet || '—';
  }

  if (!tbody) return;
  tbody.innerHTML = '';

  const { table } = mixGetActiveTable();
  if (!table){
    if (deEl) deEl.textContent = '—';
    mixSetStatus('Guide not loaded yet. If it doesn’t load automatically, choose the .xlsm file above.', 'warn');
    return;
  }

  const key = mixNormalisePantoneName(MIX_ACTIVE_PANTONE);
  const rec = table.byPantone.get(key);
  if (!rec){
    if (deEl) deEl.textContent = '—';
    mixSetStatus('Pick a Pantone from the list.', 'mini');
    return;
  }

  if (deEl){
    deEl.textContent = (rec.deltaE==null) ? '—' : rec.deltaE.toFixed(2);
  }

  const q = (Number.isFinite(qtyKg) && qtyKg > 0) ? qtyKg : 0;
  const frag = document.createDocumentFragment();

  rec.ingredients.forEach(row=>{
    const grams = row.pct * q * 10; // (% * kg * 1000 / 100)
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.ink.replace(/</g,'&lt;')}</td>
      <td style="text-align:right;">${row.pct.toFixed(3).replace(/\.?0+$/,'')}</td>
      <td style="text-align:right;">${(Math.round(grams*10)/10).toFixed(1)}</td>
    `;
    frag.appendChild(tr);
  });

  tbody.appendChild(frag);
  mixSetStatus('', 'ok');
  mixUpdateSwatch();
}

function mixUpdateSwatch(){
  const sw = document.getElementById('mixPantoneSwatch');
  if (!sw) return;
  const name = (document.getElementById('mixPantoneSelect')?.value || MIX_ACTIVE_PANTONE || '').trim();
  if (!name){
    sw.style.background = 'transparent';
    return;
  }
  // Pull Lab from the active colour library (Match & Predict data), if available
  const c = (typeof bestColourByQuery === 'function') ? bestColourByQuery(name) : null;
  if (c && Number.isFinite(+c.L) && Number.isFinite(+c.a) && Number.isFinite(+c.b) && typeof labToRgbCssForSwatch === 'function'){
    sw.style.background = labToRgbCssForSwatch(+c.L, +c.a, +c.b);
  } else {
    sw.style.background = 'transparent';
  }
}

function mixRefreshPantoneCombo(){
  const input = document.getElementById('mixPantoneSelect');
  const drop = document.getElementById('mixPantoneDrop');
  if (!input || !drop) return;

  const { table } = mixGetActiveTable();
  const allNames = table ? table.rows.map(r=>r.pantone).filter(Boolean) : [];

  const render = (q)=>{
    const query = (q||'').trim();
    const scored = allNames.map(name=>({ name, ...scoreName(name, query) }));
    const matches = scored.filter(x=>x.match).sort((a,b)=> b.score-a.score || a.name.localeCompare(b.name));
    const rest = scored.filter(x=>!x.match).sort((a,b)=> a.name.localeCompare(b.name));
    const merged = matches.concat(rest);

    drop.innerHTML = '';
    const frag = document.createDocumentFragment();
    merged.forEach(x=>{
      const div = document.createElement('div');
      div.className = 'combo-item';
      const t = tokensOf(query)[0];
      if (t){
        const idx = normText(x.name).indexOf(t);
        if (idx >= 0){
          div.innerHTML = `<span class="hit">${x.name.replace(/</g,'&lt;')}</span>`;
        } else {
          div.textContent = x.name;
        }
      } else {
        div.textContent = x.name;
      }

      div.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        input.value = x.name;
        MIX_ACTIVE_PANTONE = x.name;
        mixRenderFormula();
        
        mixUpdateSwatch();
// Mirror selection back into Match & Predict
        matchSetPantoneFromOutside(x.name);
        closeCombo(drop);
      });

      frag.appendChild(div);
    });
    drop.appendChild(frag);
  };

  render('');

  const open = ()=>{ drop.classList.remove('hide'); };

  input.addEventListener('focus', ()=>{ render(input.value); open(); });
  input.addEventListener('click', ()=>{ render(input.value); open(); });
  input.addEventListener('input', ()=>{ render(input.value); open(); });
  input.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape'){ closeCombo(drop); return; }
    if (e.key === 'Enter'){
      const best = allNames.length ? (allNames.find(n=>mixNormalisePantoneName(n)===mixNormalisePantoneName(input.value)) || allNames[0]) : '';
      if (best){
        input.value = best;
        MIX_ACTIVE_PANTONE = best;
        mixRenderFormula();
        // Mirror selection back into Match & Predict
        matchSetPantoneFromOutside(best);
      }
      closeCombo(drop);
    }
  });
  input.addEventListener('blur', ()=>{
    setTimeout(()=> closeCombo(drop), 120);
  });

  document.addEventListener('mousedown', (e)=>{
    if (!drop || drop.classList.contains('hide')) return;
    const within = drop.contains(e.target) || input.contains(e.target);
    if (!within) closeCombo(drop);
  });
}


// Sync: when a Pantone is selected elsewhere (Match & Predict), mirror it here.
let MIX_PENDING_PANTONE = '';
function mixSetPantoneFromOutside(name){
  const nm = (name||'').trim();
  if (!nm) return;
  const input = document.getElementById('mixPantoneSelect');
  if (!input){
    MIX_PENDING_PANTONE = nm;
    return;
  }
  input.value = nm;

  // If the guide isn't loaded yet, remember it and apply after load.
  if (!(MIX_GUIDE && MIX_GUIDE.ready)){
    MIX_PENDING_PANTONE = nm;
    return;
  }
  MIX_ACTIVE_PANTONE = nm;
  mixRenderFormula();

  mixUpdateSwatch();
}

async function mixInit(){
  const fileEl = document.getElementById('mixGuideFile');
  const rangeEl = document.getElementById('mixInkRange');
  const aniloxEl = document.getElementById('mixAnilox');
  const qtyEl = document.getElementById('mixQtyKg');
  const trayEl = null; // Tray volume assumed 0
  const linEl = document.getElementById('mixLinearM');
  const webEl = document.getElementById('mixWebWidth');
  const covEl = document.getElementById('mixCoverage');
  const copyEl = document.getElementById('mixCopyInkReq');

  if (rangeEl) rangeEl.addEventListener('change', ()=>{
    mixRefreshPantoneCombo();
    mixUpdateInkCalc();
    mixRenderFormula();
  });
  if (aniloxEl) aniloxEl.addEventListener('change', ()=>{
    mixRefreshPantoneCombo();
    mixUpdateInkCalc();
    mixRenderFormula();
  });
  if (qtyEl) qtyEl.addEventListener('input', mixRenderFormula);

  const inkInputs = [trayEl, linEl, webEl, covEl];
  inkInputs.forEach(el=>{
    if (!el) return;
    el.addEventListener('input', ()=>{ mixUpdateInkCalc(); mixRenderFormula(); });
  });


  if (copyEl) copyEl.addEventListener('click', ()=>{
    const inkReqNum = parseFloat(document.getElementById('mixInkReq')?.dataset?.value || '');
    if (!Number.isFinite(inkReqNum)) return;
    const qtyEl2 = document.getElementById('mixQtyKg');
    if (qtyEl2){ qtyEl2.value = inkReqNum.toFixed(3); }
    mixRenderFormula();
  });

  if (fileEl){
    fileEl.addEventListener('change', async ()=>{
      const f = fileEl.files && fileEl.files[0];
      if (!f) return;
      try{
        mixSetStatus('Loading workbook…');
        const wb = await mixLoadWorkbookFromFile(f);
        MIX_GUIDE = mixParseWorkbook(wb);
        mixSetStatus('Workbook loaded.', 'ok');
        if (MIX_PENDING_PANTONE) { mixSetPantoneFromOutside(MIX_PENDING_PANTONE); MIX_PENDING_PANTONE=''; }
        mixRefreshPantoneCombo();
        mixUpdateInkCalc();
        mixRenderFormula();
      }catch(err){
        mixSetStatus('Could not read workbook: ' + (err.message||err), 'warn');
      }
    });
  }

  // Auto-load from same folder (GitHub / local)
  try{
    if (!window.XLSX) throw new Error('XLSX library not available.');
    mixSetStatus('Loading workbook…');
    const fname = "Combined mixing guide v4 '25 update.xlsm";
    const wb = await mixLoadWorkbookFromUrl(encodeURI('./'+fname));
    MIX_GUIDE = mixParseWorkbook(wb);
    mixSetStatus('Workbook loaded.', 'ok');
    if (MIX_PENDING_PANTONE) { mixSetPantoneFromOutside(MIX_PENDING_PANTONE); MIX_PENDING_PANTONE=''; }
  }catch(err){
    mixSetStatus('Auto-load failed (use file picker above).', 'warn');
  }

  mixRefreshPantoneCombo();
  mixUpdateInkCalc();
  mixRenderFormula();
}

// Kick off once DOM is ready (after existing wiring)
document.addEventListener('DOMContentLoaded', ()=>{
  try{ mixInit(); }catch(e){}
});

// Tabs switching
const tabBtnMatch=$('#tabBtnMatch');
const tabBtnCompare=$('#tabBtnCompare');
const tabBtnMix=$('#tabBtnMix');
const tabBtnSettings=$('#tabBtnSettings');

const tabMatch=$('#tab-match');
const tabCompare=$('#tab-compare');
const tabMix=$('#tab-mix');
const tabSettings=$('#tab-settings');

function showTab(which){
  tabMatch.hidden = which!=='match';
  tabCompare.hidden = which!=='compare';
  tabMix.hidden = which!=='mix';
  tabSettings.hidden = which!=='settings';

  tabBtnMatch.setAttribute('aria-selected', which==='match' ? 'true':'false');
  tabBtnCompare.setAttribute('aria-selected', which==='compare' ? 'true':'false');
  if (tabBtnMix) tabBtnMix.setAttribute('aria-selected', which==='mix' ? 'true':'false');
  tabBtnSettings.setAttribute('aria-selected', which==='settings' ? 'true':'false');

  if (which === 'compare') requestLabDraw();
}

tabBtnMatch.addEventListener('click',()=>showTab('match'));
tabBtnCompare.addEventListener('click',()=>showTab('compare'));
if (tabBtnMix) tabBtnMix.addEventListener('click',()=>showTab('mix'));
if (tabBtnSettings) tabBtnSettings.addEventListener('click',()=>showTab('settings'));
// Wire up
$('#findBtn').addEventListener('click', findClosest);
$('#clearBtn').addEventListener('click', ()=>{
  $('#L').value='';
  $('#a').value='';
  $('#b').value='';
  updateTargetEcho();
  $('#resultsTbody').innerHTML='';
  $('#formulaPanel').style.display='none';
  $('#suggestedFormula').style.display='none';
  $('#predictMsg').textContent='';
  $('#editRow').style.display='none';
});
$('#suggestBtn').addEventListener('click', suggestFormula);
['L','a','b'].forEach(id=>$('#'+id).addEventListener('input', updateTargetEcho));

$('#editFormulaBtn').addEventListener('click', openEdit);
$('#cancelEdit').addEventListener('click', closeEdit);
$('#normaliseBtn').addEventListener('click', normalise);
$('#addInkBtn').addEventListener('click', addInk);
$('#addPct').addEventListener('keydown', e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    addInk();
  }
});
$('#saveCorrection').addEventListener('click', saveCorrection);

$('#downloadTrainingCanonicalBtn').addEventListener('click', downloadCanonicalTrainingCsv);

// Library UI events
$('#librarySelect').addEventListener('change', (e)=>{
  activeLibraryId = e.target.value || LIB_BASE_ID;
  refreshLibrarySelects();
  refreshActiveColours();
});
$('#cmpLibrarySelect').addEventListener('change', (e)=>{
  activeLibraryId = e.target.value || LIB_BASE_ID;
  refreshLibrarySelects();
  refreshActiveColours();
});
$('#libAddBtn').addEventListener('click', ()=>{
  const name = ($('#libName').value||'').trim();
  const file = $('#libFile').files[0];
  if (!name){
    alert('Please enter a library name.');
    return;
  }
  if (!file){
    alert('Please choose a CSV file.');
    return;
  }
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const colours = parseCsvColours(reader.result);
      if (!colours.length){
        alert('No valid rows found (L/a/b empty?).');
        return;
      }
      const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('lib_'+Math.random().toString(16).slice(2));
      const lib = { id:id, name:name, colours:colours };
      userLibraries.push(lib);
      saveLibraries();
      $('#libName').value='';
      $('#libFile').value='';
      setSettingsLibrary(id);
      renderLibraryList();
      renderLibraryEditor();
      refreshLibrarySelects();
    }catch(err){
      alert('Error parsing CSV: ' + (err.message||err));
    }
  };
  reader.onerror = ()=> alert('Error reading file.');
  reader.readAsText(file);
});

// Download example CSV
$('#libTemplateBtn').addEventListener('click', ()=>{
  const csv = [
    'Name,L,a,b',
    'Custom Red 1,50.00,70.00,50.00',
    'Custom Green 1,55.00,-40.00,40.00',
    'Custom Blue 1,45.00,20.00,-50.00',
    'Warm Grey-ish,70.00,2.00,5.00'
  ].join('\r\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'colour_library_template.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});


// Library editor actions (Settings → Colour Sets)
$('#libExportBtn')?.addEventListener('click', ()=>{
  const lib = getSettingsLibrary();
  if (lib.readonly) return;
  const rows = lib.colours || [];
  const csv = ['Name,L,a,b'].concat(rows.map(c=>{
    const name = (c.name||c.Name||'').replace(/"/g,'""');
    const L = Number(c.L||0).toFixed(2);
    const a = Number(c.a||0).toFixed(2);
    const b = Number(c.b||0).toFixed(2);
    return `"${name}",${L},${a},${b}`;
  })).join('\r\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const aEl = document.createElement('a');
  aEl.href = url;
  aEl.download = (lib.name||'library').replace(/[^\w\-]+/g,'_') + '.csv';
  document.body.appendChild(aEl);
  aEl.click();
  aEl.remove();
  URL.revokeObjectURL(url);
});

$('#libDeleteBtn')?.addEventListener('click', ()=>{
  const lib = getSettingsLibrary();
  if (lib.readonly) return;
  if (!confirm(`Delete library "${lib.name}"? This cannot be undone.`)) return;
  userLibraries = userLibraries.filter(l=>l.id !== lib.id);
  saveLibraries();
  if (activeLibraryId === lib.id || activeLibraryId === LIB_ALL_ID) refreshActiveColours();
  refreshLibrarySelects();
  setSettingsLibrary(LIB_BASE_ID);
});

$('#libScanBtn')?.addEventListener('click', async ()=>{
  const lib = getSettingsLibrary();
  if (lib.readonly) return;
  try{
    const m = await spectroMeasureOnce();
    if (!m) return;
    $('#libColourL').value = Number(m.L||0).toFixed(2);
    $('#libColourA').value = Number(m.a||0).toFixed(2);
    $('#libColourB').value = Number(m.b||0).toFixed(2);
    if (!($('#libColourName').value||'').trim()){
      const t = new Date();
      $('#libColourName').value = `Scan ${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,'0')}-${String(t.getDate()).padStart(2,'0')} ${String(t.getHours()).padStart(2,'0')}${String(t.getMinutes()).padStart(2,'0')}`;
    }
  }catch(e){
    alert('Scan failed: ' + (e.message||e));
  }
});

$('#libAddColourBtn')?.addEventListener('click', ()=>{
  const lib = getSettingsLibrary();
  if (lib.readonly) return;

  const name = ($('#libColourName').value||'').trim();
  const L = parseFloat($('#libColourL').value);
  const a = parseFloat($('#libColourA').value);
  const b = parseFloat($('#libColourB').value);

  if (!name){
    alert('Please enter a colour name.');
    return;
  }
  if (![L,a,b].every(Number.isFinite)){
    alert('Please enter valid L*, a*, b* values.');
    return;
  }

  lib.ref.colours.push({ name:name, L:L, a:a, b:b });
  scheduleSaveLibraries();
  $('#libColourName').value='';
  $('#libColourL').value='';
  $('#libColourA').value='';
  $('#libColourB').value='';
  renderLibraryEditor();
});


// Compare tab quick-load
// (We use a custom combobox so typing does not hide options like <datalist> does.)
function loadCompareByName(which, name){
  return loadCompareByQuery(which, name);
}

// Keep the hidden standard load button functional (if you ever unhide it)
const _cmpALoadBtn = document.getElementById('cmpALoad');
if (_cmpALoadBtn){
  _cmpALoadBtn.addEventListener('click', ()=> loadCompareByQuery('A', document.getElementById('cmpASelect')?.value || ''));
}

// Compare save/log UI
const cmpSaveBtn = document.getElementById('cmpSaveBtn');
if (cmpSaveBtn){
  cmpSaveBtn.addEventListener('click', ()=>{
    const out = saveCurrentComparison();
    const msg = document.getElementById('cmpSaveMsg');
    if (msg){
      msg.textContent = out.msg || '';
      msg.className = out.ok ? 'mini ok' : 'mini warn';
    }
  });
}

// Job ref/id UI sync for Compare tab
const cmpJobRefTopEl = document.getElementById('cmpJobRefTop');
const cmpJobRefEl = document.getElementById('cmpJobRef');
if (cmpJobRefTopEl){
  cmpJobRefTopEl.addEventListener('input', ()=> setJobRefUI(cmpJobRefTopEl.value));
}
if (cmpJobRefEl){
  cmpJobRefEl.addEventListener('input', ()=> setJobRefUI(cmpJobRefEl.value));
}

setJobIdUI();

const cmpClearLogBtn = document.getElementById('cmpClearLogBtn');
if (cmpClearLogBtn){
  cmpClearLogBtn.addEventListener('click', ()=>{
    if (!confirm('Clear all saved comparisons?')) return;
    CMP_LOG = [];
    saveCompareLog();
    renderCompareLog();
  });
}
const cmpExportLogBtn = document.getElementById('cmpExportLogBtn');
if (cmpExportLogBtn){
  cmpExportLogBtn.addEventListener('click', exportCompareLogCsv);
}

// History modal
(function wireHistoryModal(){
  const btn = document.getElementById('cmpHistoryBtn');
  const modal = document.getElementById('cmpHistoryModal');
  const closeBtn = document.getElementById('cmpHistoryClose');
  if (!btn || !modal) return;

  const rebuildLibraryFilter = ()=>{
    const sel = document.getElementById('histLibrary');
    if (!sel) return;
    const opts = libraryOptions();
    sel.innerHTML = '';
    const any = document.createElement('option');
    any.value = '';
    any.textContent = '— any —';
    sel.appendChild(any);
    opts.forEach(o=>{
      const opt = document.createElement('option');
      opt.value = o.id;
      opt.textContent = o.label;
      sel.appendChild(opt);
    });
  };

  const open = ()=>{
    rebuildLibraryFilter();
    modal.style.display = 'flex';
    renderCompareLog();
  };
  const close = ()=> { modal.style.display = 'none'; };

  btn.addEventListener('click', open);
  if (closeBtn) closeBtn.addEventListener('click', close);
  modal.addEventListener('mousedown', (e)=>{ if (e.target === modal) close(); });

  // Live filter
  ['histFrom','histTo','histJob','histStandard','histLibrary','histSort'].forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', ()=> renderCompareLog());
    el.addEventListener('change', ()=> renderCompareLog());
  });
})();

// Settings UI
const saveSettingsBtn = document.getElementById('saveSettingsBtn');
if (saveSettingsBtn){
  saveSettingsBtn.addEventListener('click', ()=>{
    readSettingsFromUI();
    saveSettings();
    renderCompareLog();
    computeCompareDE();
    const s = document.getElementById('settingsStatus');
    if (s) s.textContent = 'Saved.';
    setTimeout(()=>{ const s2=document.getElementById('settingsStatus'); if (s2) s2.textContent=''; }, 1500);
  });
}
const resetSettingsBtn = document.getElementById('resetSettingsBtn');
if (resetSettingsBtn){
  resetSettingsBtn.addEventListener('click', ()=>{
    SETTINGS = { deltaEThreshold: 2.0, autoSaveCompare: false };
    saveSettings();
    applySettingsToUI();
    renderCompareLog();
    computeCompareDE();
    const s = document.getElementById('settingsStatus');
    if (s) s.textContent = 'Reset to defaults.';
    setTimeout(()=>{ const s2=document.getElementById('settingsStatus'); if (s2) s2.textContent=''; }, 1500);
  });
}
// Data load
Promise.all([
  fetch('colours.json').then(r=>r.json()),
  fetch('DC_Formulas.json').then(r=>r.json())
]).then(tuple=>{
  BASE_COLOURS=tuple[0].map(c=>({
    name:c.name||c.Colour||c.color||'',
    L:c.L,
    a:c.a,
    b:c.b
  }));
  COLOURS = BASE_COLOURS.slice();
  FORMULAS=tuple[1];
  buildFormulaIndex();
  loadLibraries();
  refreshLibrarySelects();
  refreshActiveColours();
  renderLibraryList();
  renderLibraryEditor();
}).catch(err=>{
  alert('Error loading JSON: '+err);
});

loadGroups();
loadInks();
loadInkCurves();
loadSettings();
applySettingsToUI();
loadCompareLog();
renderCompareLog();

renderInkCurvesTable();
updateTargetEcho();
requestLabDraw();

// Self-test
try{
  const c={L:50,a:0,b:0};
  console.assert(approx(deltaE2000(c,c),0),'ΔE00 identity');
  const c1={L:60,a:10,b:-5}, c2={L:55,a:-3,b:9};
  console.assert(approx(deltaE2000(c1,c2),deltaE2000(c2,c1),1e-9),'ΔE00 symmetry');
}catch(e){
  console.warn('Self-tests failed:', e);
}

})();

// ===== Splash / landing behaviour =====
(function(){
  const splash = document.getElementById('splash');
  const appRoot = document.getElementById('appRoot');
  const btn = document.getElementById('splashBtn');
  if (!splash || !appRoot || !btn) return;

  const img = btn.querySelector('.splash-img');
  const wrap = splash.querySelector('.splash-imgWrap');
  if (wrap && img) wrap.style.setProperty('--splash-img', `url("${img.src}")`);

  const enter = ()=>{
    if (splash.classList.contains('exiting')) return;
    splash.classList.add('exiting');

    const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const done = ()=>{
      // Reveal app immediately (kept invisible until we add app-ready)
      appRoot.classList.remove('app-hidden');

      // Start app fade-in when the splash begins fading out (matches the text fade timing feel)
      window.setTimeout(()=> document.body.classList.add('app-ready'), 360);

      // Slide the nav in after the app has faded up
      window.setTimeout(()=> document.body.classList.add('nav-in'), 640);

      // Remove splash after shutter + fade complete
      window.setTimeout(()=> splash.remove(), 720);
    };

    if (reduced){ done(); return; }
    window.setTimeout(done, 590);
  };

  btn.addEventListener('click', enter);
  btn.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      enter();
    }
  });
})();

</script>
  </div>

</body>
</html>
