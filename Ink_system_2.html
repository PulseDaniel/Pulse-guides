<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ink Colour Matcher + Predictor</title>
<style>
  :root{ --gap:12px; --radius:14px; }
  *{ box-sizing:border-box; }
  body{ font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; margin:0; padding:16px; background:#0b0c10; color:#e6e6e6; }
  h1{ font-size:1.2rem; margin:0 0 8px; }
  .tabs{ display:flex; gap:8px; margin:0 0 12px; flex-wrap:wrap; }
  .tabbtn{ cursor:pointer; padding:10px 14px; border-radius:12px; border:1px solid #2a2f3a; background:#141824; color:#e6e6e6; font-weight:700; }
  .tabbtn[aria-selected="true"]{ background:#1a2133; border-color:#3a4252; }
  .app{ max-width:1200px; margin:0 auto; display:grid; gap:var(--gap); grid-template-columns:420px 1fr; align-items:start; }
  .card{ background:#111318; border:1px solid #22252e; border-radius:var(--radius); padding:16px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
  label{ display:block; font-size:.85rem; color:#98a2b3; margin-bottom:6px; }
  input, select, textarea{ width:100%; padding:10px 12px; border-radius:10px; outline:none; background:#0e1015; border:1px solid #2a2f3a; color:#e6e6e6; }
  input::placeholder{ color:#7b8496; }
  textarea{ min-height:80px; resize:vertical; }
  .row{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:var(--gap); }
  .row2{ display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); }
  .btn{ cursor:pointer; padding:10px 12px; border-radius:10px; border:1px solid #2a2f3a; background:#141824; color:#e6e6e6; font-weight:600; }
  .btn:hover{ filter:brightness(1.08); }
  table{ width:100%; border-collapse:collapse; }
  th,td{ text-align:left; padding:10px; border-bottom:1px dashed #242938; font-variant-numeric:tabular-nums; }
  th{ color:#9aa4b2; font-weight:600; }
  .result-row{ transition:background .2s; cursor:pointer; }
  .result-row:hover{ background:rgba(255,255,255,.05); }
  .swatch{ width:3.1rem; height:2.1rem; border-radius:6px; border:1px solid rgba(255,255,255,.2); }
  .pill{ font-size:.8rem; color:#98a2b3; }
  .muted{ color:#7b8496; font-size:.85rem; }
  .formula-box{ background:#0e1015; border:1px solid #2a2f3a; border-radius:10px; padding:12px; margin-top:16px; }
  .formula-box h2{ margin:0 0 8px; font-size:1rem; color:#ccc; }
  .formula-grid{ display:grid; grid-template-columns:1fr auto; column-gap:12px; row-gap:6px; align-items:center; }
  .fg-ink{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .fg-pct{ text-align:right; min-width:4ch; font-variant-numeric:tabular-nums; color:#cbd5e1; }
  .stack{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .flex{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .two-col{ display:grid; grid-template-columns:1fr 1fr; gap:var(--gap); }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  @media (max-width:900px){ .app{ grid-template-columns:1fr; } .two-col{ grid-template-columns:1fr; } }

  /* Modal editor */
  .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.5); display:none; align-items:center; justify-content:center; z-index:50; }
  .modal{ width:min(720px, 96vw); max-height:90vh; overflow:auto; background:#10121a; border:1px solid #2a2f3a; border-radius:14px; padding:16px; }
  .modal h3{ margin:0 0 8px; }
  .edit-row{ display:grid; grid-template-columns: 1fr 100px 32px; gap:8px; align-items:center; }
  .pct-input{ text-align:right; font-variant-numeric:tabular-nums; }
  .rem-btn{ width:32px; height:38px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; border:1px solid #2a2f3a; background:#1a1f2b; cursor:pointer; }
  .add-row{ display:grid; grid-template-columns:1fr 120px auto; gap:8px; margin-top:8px; }
  .footer-row{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap; }
  .note{ font-size:.85rem; color:#9aa4b2; }
  .mini{ font-size:.8rem; color:#9aa4b2; }
  .warn{ color:#fca5a5; }
  .ok{ color:#86efac; }

  /* Compare canvas wrapper */
  .canvasWrap{ margin-top:12px; background:#0f1219; border:1px solid #2a2f3a; border-radius:12px; overflow:hidden; }
  .legend{ display:flex; gap:12px; align-items:center; font-size:.9rem; color:#9aa4b2; padding:8px 10px; background:#0d1016; border-bottom:1px solid #242938; flex-wrap:wrap; }
  .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid rgba(255,255,255,.25); }

  /* Libraries */
  .lib-list{ margin-top:8px; border-top:1px dashed #2a2f3a; padding-top:8px; }
  .lib-item{ display:flex; justify-content:space-between; align-items:center; padding:4px 0; font-size:.9rem; }
  .lib-item-name{ font-weight:600; }
  .lib-badge{ font-size:.75rem; color:#9aa4b2; }
</style>
</head>
<body>

  <div class="tabs" role="tablist" aria-label="Modes">
    <button class="tabbtn" id="tabBtnMatch" role="tab" aria-selected="true" aria-controls="tab-match">Match & Predict</button>
    <button class="tabbtn" id="tabBtnCompare" role="tab" aria-selected="false" aria-controls="tab-compare">Compare Colours</button>
    <button class="tabbtn" id="tabBtnLibraries" role="tab" aria-selected="false" aria-controls="tab-libraries">Colour Sets</button>
  </div>

  <!-- TAB: Match & Predict -->
  <section id="tab-match" role="tabpanel" aria-labelledby="tabBtnMatch">
    <div class="app">
      <div class="card">
        <div class="top" style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap: wrap;">
          <div>
            <h1>Ink Colour Matcher</h1>
            <div class="pill">Active library: <span id="activeLibLabel">Pantone (base)</span></div>
          </div>
          <div style="min-width:200px;">
            <label for="librarySelect">Colour library</label>
            <select id="librarySelect"></select>
          </div>
          <div class="pill" id="refCountPill"><span id="countLabel">0</span> colours</div>
        </div>

        <div class="row" style="margin-top:12px;">
          <div><label for="L">L*</label><input id="L" type="number" step="0.01" placeholder="e.g. 52.30"></div>
          <div><label for="a">a*</label><input id="a" type="number" step="0.01" placeholder="e.g. 12.80"></div>
          <div><label for="b">b*</label><input id="b" type="number" step="0.01" placeholder="e.g. -4.10"></div>
        </div>

        <div class="row2" style="margin-top:12px;">
          <div>
            <label for="pms">Search by PMS (number only)</label>
            <input id="pms" type="text" placeholder="e.g. 186 or 3005"/>
          </div>
          <div style="align-self:end;">
            <button class="btn" id="pmsBtn">Find PMS</button>
          </div>
        </div>

        <div class="flex" style="margin-top:12px;">
          <button class="btn" id="findBtn">Find closest match</button>
          <button class="btn" id="clearBtn">Clear</button>
          <span class="muted" id="statusMsg" aria-live="polite"></span>
        </div>

        <div class="formula-box" id="predictorBox">
          <h2>Suggest Formula</h2>
          <div class="row2" style="margin-bottom:8px;">
            <div>
              <label for="groupSelect">Colour group (optional)</label>
              <select id="groupSelect"><option value="">— none —</option></select>
            </div>
            <div></div>
          </div>
          <div class="flex">
            <button class="btn" id="suggestBtn">Suggest Formula</button>
            <div id="predictMsg" class="muted" style="align-self:center;"></div>
          </div>
          <div id="suggestedFormula" class="formula-box" style="display:none; margin-top:12px;"></div>
          <div class="flex" id="editRow" style="display:none; margin-top:8px;">
            <button class="btn" id="editFormulaBtn">Edit formula</button>
            <span class="mini">Adjust, add/remove inks, then save correction to training log.</span>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;">
          <h1>Closest Matches</h1>
          <div class="stack" style="align-items:center;">
            <div class="swatch" id="targetSwatch" title="Target"></div>
            <div class="muted" id="targetEcho">Target: –</div>
          </div>
        </div>
        <table>
          <thead>
            <tr><th>Colour</th><th>Swatch</th><th>L*</th><th>a*</th><th>b*</th><th>Distance</th></tr>
          </thead>
          <tbody id="resultsTbody"></tbody>
        </table>
        <div id="formulaPanel" class="formula-box" style="display:none;"></div>
      </div>
    </div>
  </section>

  <!-- TAB: Compare Colours -->
  <section id="tab-compare" role="tabpanel" aria-labelledby="tabBtnCompare" hidden>
    <div class="card" style="max-width:1200px; margin:0 auto;">
      <div class="flex" style="justify-content:space-between;">
        <div>
          <h1>Compare Colours (ΔE2000)</h1>
          <div class="pill">Using library: <span id="cmpLibLabel">Pantone (base)</span></div>
        </div>
        <div style="min-width:220px;">
          <label for="cmpLibrarySelect">Colour library</label>
          <select id="cmpLibrarySelect"></select>
        </div>
      </div>

      <div class="two-col" style="margin-top:12px;">
        <div>
          <div class="row2">
            <div>
              <label for="cmpASelect">Pick colour A (from active library)</label>
              <input list="cmpListA" id="cmpASelect" placeholder="Type to search…">
              <datalist id="cmpListA"></datalist>
            </div>
            <div style="align-self:end;"><button class="btn" id="cmpALoad">Load A</button></div>
          </div>
          <div class="row" style="margin-top:8px;">
            <div><label for="AL">A: L*</label><input id="AL" type="number" step="0.01"></div>
            <div><label for="Aa">A: a*</label><input id="Aa" type="number" step="0.01"></div>
            <div><label for="Ab">A: b*</label><input id="Ab" type="number" step="0.01"></div>
          </div>
          <div class="flex" style="margin-top:8px;"><div class="swatch" id="swatchA"></div></div>
        </div>
        <div>
          <div class="row2">
            <div>
              <label for="cmpBSelect">Pick colour B (from active library)</label>
              <input list="cmpListB" id="cmpBSelect" placeholder="Type to search…">
              <datalist id="cmpListB"></datalist>
            </div>
            <div style="align-self:end;"><button class="btn" id="cmpBLoad">Load B</button></div>
          </div>
          <div class="row" style="margin-top:8px;">
            <div><label for="BL">B: L*</label><input id="BL" type="number" step="0.01"></div>
            <div><label for="Ba">B: a*</label><input id="Ba" type="number" step="0.01"></div>
            <div><label for="Bb">B: b*</label><input id="Bb" type="number" step="0.01"></div>
          </div>
          <div class="flex" style="margin-top:8px;"><div class="swatch" id="swatchB"></div><button class="btn" id="swapAB">Swap A↔B</button></div>
        </div>
      </div>

      <div class="formula-box" id="cmpResult" style="display:none; margin-top:12px;">
        <h2 style="margin-bottom:6px;">Result</h2>
        <div id="cmpNumbers" style="font-size:1.05rem;"></div>
        <div class="muted" style="margin-top:6px;">
          <small>Guideline: ΔE00 &lt; 1.0 ≈ barely perceptible • &lt; 2.0 ≈ good • 2–3.5 borderline • &gt; 3.5 poor</small>
        </div>
      </div>

      <div class="canvasWrap">
        <div class="legend">
          <span>A:</span><span id="legendA" class="dot"></span>
          <span style="margin-left:10px;">B:</span><span id="legendB" class="dot"></span>
          <span style="margin-left:auto;"></span>
          <button class="btn" id="resetView">Reset view</button>
          <span style="font-size:.8rem; opacity:.8;">Drag to rotate • Scroll to zoom</span>
        </div>
        <canvas id="labCanvas" width="1100" height="520" style="display:block; width:100%; height:auto;"></canvas>
      </div>
    </div>
  </section>

  <!-- TAB: Colour Sets (libraries) -->
  <section id="tab-libraries" role="tabpanel" aria-labelledby="tabBtnLibraries" hidden>
    <div class="card" style="max-width:900px; margin:0 auto;">
      <h1>Colour Sets (Libraries)</h1>
      <p class="muted">
        Upload your own colour sets (in addition to the built-in Pantone set). Each set becomes a selectable library
        in the <strong>Match &amp; Predict</strong> and <strong>Compare Colours</strong> tabs.
      </p>
      <p class="muted" style="margin-top:6px;">
        <strong>CSV format:</strong> first row as headers. Required columns: <code>Name</code>, <code>L</code>,
        <code>a</code>, <code>b</code> (or <code>L*</code>, <code>a*</code>, <code>b*</code>).
      </p>

      <div class="row2" style="margin-top:12px;">
        <div>
          <label for="libName">Library name</label>
          <input id="libName" type="text" placeholder="e.g. Customer ACME Spot Colours">
        </div>
        <div>
          <label for="libFile">CSV file</label>
          <input id="libFile" type="file" accept=".csv,text/csv">
        </div>
      </div>

      <div class="flex" style="margin-top:12px;">
        <button class="btn" id="libAddBtn">Add library</button>
        <button class="btn" id="libTemplateBtn">Download example CSV</button>
        <span class="mini">Files stay local to this browser (saved in localStorage).</span>
      </div>

      <div class="lib-list" id="libList">
        <!-- Populated in JS -->
      </div>
    </div>
  </section>

  <!-- Modal: Edit Formula -->
  <div class="modal-backdrop" id="editModal">
    <div class="modal">
      <h3>Edit formula</h3>
      <div class="mini" id="editContext"></div>
      <div id="editList" style="margin-top:8px; display:grid; gap:6px;"></div>
      <div class="add-row">
        <select id="addInkSel"></select>
        <input id="addPct" type="number" step="0.01" placeholder="% add" class="pct-input mono">
        <button class="btn" id="addInkBtn">Add ink</button>
      </div>
      <div class="two-col" style="margin-top:8px;">
        <div class="note">Total: <span id="totalPct">0.00</span>% — <span id="totalState" class="warn">needs normalising</span></div>
        <div class="flex" style="justify-content:flex-end;">
          <button class="btn" id="normaliseBtn">Normalise to 100%</button>
        </div>
      </div>
      <div style="margin-top:8px;">
        <label for="corrNote">Optional note</label>
        <textarea id="corrNote" placeholder="e.g., +1.5% black to drop L*, swapped Yellow→Orange bias, etc."></textarea>
      </div>
      <div class="footer-row">
        <button class="btn" id="cancelEdit">Cancel</button>
        <button class="btn" id="saveCorrection">Save correction</button>
      </div>
    </div>
  </div>

<script>
(function(){
'use strict';
function $(sel){ return document.querySelector(sel); }
function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
function approx(a,b,eps){ if (eps==null) eps=1e-3; return Math.abs(a-b) <= eps; }

const API_BASE = 'https://ink-predict-api.onrender.com'; // <- your Render URL

// ===== Colour math =====
function labToXyz(L,a,b){
  const Yn=1, Xn=0.95047, Zn=1.08883, fy=(L+16)/116;
  const fx=f=> f>0.206893?f*f*f:(f-16/116)/7.787;
  return { X: fx((a/500)+fy)*Xn, Y: fx(fy)*Yn, Z: fx(fy-(b/200))*Zn };
}
function labToSrgb(L,a,b){
  const {X,Y,Z}=labToXyz(L,a,b);
  let r =  3.2406*X -1.5372*Y -0.4986*Z;
  let g = -0.9689*X +1.8758*Y +0.0415*Z;
  let b2=  0.0557*X -0.2040*Y +1.0570*Z;
  const lin=[r,g,b2].map(v=> v<=0.0031308?12.92*v:1.055*Math.pow(v,1/2.4)-0.055);
  r=clamp(Math.round(lin[0]*255),0,255);
  g=clamp(Math.round(lin[1]*255),0,255);
  b2=clamp(Math.round(lin[2]*255),0,255);
  return { r, g, b: b2 };
}
function hp(x,y){ const h=Math.atan2(y,x)*180/Math.PI; return (h>=0?h:h+360); }
function deltaE2000(c1,c2){
  const L1=c1.L,a1=c1.a,b1=c1.b, L2=c2.L,a2=c2.a,b2=c2.b, d2r=Math.PI/180;
  const avgLp=(L1+L2)/2, C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2), avgC=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2, C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2), avgCp=(C1p+C2p)/2;
  const h1p=hp(a1p,b1), h2p=hp(a2p,b2), avgHp = Math.abs(h1p-h2p)>180 ? (h1p+h2p+360)/2 : (h1p+h2p)/2;
  const T = 1 - 0.17*Math.cos((avgHp-30)*d2r) + 0.24*Math.cos((2*avgHp)*d2r) + 0.32*Math.cos((3*avgHp+6)*d2r) - 0.20*Math.cos((4*avgHp-63)*d2r);
  let dHp = h2p - h1p; if (dHp>180) dHp-=360; if (dHp<-180) dHp+=360;
  const dLp = L2 - L1, dCp = C2p - C1p, dHp_rad = 2*Math.sqrt(C1p*C2p)*Math.sin((dHp*d2r)/2);
  const Sl = 1 + (0.015*Math.pow(avgLp-50,2))/Math.sqrt(20 + Math.pow(avgLp-50,2)), Sc = 1 + 0.045*avgCp;
  const Sh = 1 + 0.015*avgCp*T;
  const Rc=2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7)));
  const Rt=-Rc*Math.sin(2*(30*Math.exp(-Math.pow((avgHp-275)/25,2)))*d2r);
  return Math.sqrt(Math.pow(dLp/Sl,2) + Math.pow(dCp/Sc,2) + Math.pow(dHp_rad/Sh,2) + Rt*(dCp/Sc)*(dHp_rad/Sh));
}

// ===== State =====
let BASE_COLOURS = [];   // built-in Pantone set
let COLOURS = [];        // active library view
let FORMULAS = {};
let FORMULAS_NORM = {};
let COLOUR_TO_FORMULA = {};
let _lastSuggestion = null;
let _lastContextName = null;
let _allInks = [];

const LIB_KEY = 'ink_user_libraries_v1';
const LIB_BASE_ID = 'base';
const LIB_ALL_ID = 'all';
let userLibraries = []; // [{id,name,colours:[]}]
let activeLibraryId = LIB_BASE_ID;

// Helpers
function normaliseName(s){ return String(s||'').trim().toUpperCase().replace(/\s+/g,' '); }
function extractPmsNumber(name){ if(!name) return null; const m = String(name).toUpperCase().match(/PANTONE\s*([0-9A-Z]+(?:[\- ]?[0-9A-Z]+)*)/); return m? m[1].replace(/\s+/g,'').replace(/^\-/,''): null; }
function updateTargetEcho(){
  const L=parseFloat($('#L').value), a=parseFloat($('#a').value), b=parseFloat($('#b').value);
  if([L,a,b].some(v=>Number.isNaN(v))){ $('#targetEcho').textContent='Target: –'; $('#targetSwatch').style.background='#0000'; return; }
  $('#targetEcho').textContent=`Target: L ${L.toFixed(2)} a ${a.toFixed(2)} b ${b.toFixed(2)}`;
  const rgb=labToSrgb(L,a,b); $('#targetSwatch').style.background=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
}

// Build formula index from DC_Formulas.json (Pantone library)
function buildFormulaIndex(){
  const rows=[]; FORMULAS_NORM={}; COLOUR_TO_FORMULA={};
  if (Array.isArray(FORMULAS)) rows.push(...FORMULAS);
  else if (FORMULAS && typeof FORMULAS==='object'){
    Object.keys(FORMULAS).forEach(k=>{
      if (Array.isArray(FORMULAS[k])) rows.push(...FORMULAS[k]);
      else if (FORMULAS[k] && typeof FORMULAS[k]==='object' && Array.isArray(FORMULAS[k].rows)) rows.push(...FORMULAS[k].rows);
    });
  }
  const byColour=new Map();
  rows.forEach(r=>{
    const cname=r.Colour||r.colour||r.Color||r.color||r.NAME||r.Name; if(!cname) return;
    const items=[]; for (let i=1;i<=12;i++){ const ink=r['Ingredient '+i]||r['Ink '+i]||r['INGREDIENT '+i]||r['ingredient '+i]; if(!ink) continue; const pct=r['%'+i]||r[i+'%']||r['% '+i]||r['Percent '+i]||r['Percent'+i]||r['%']||''; items.push({ink,percent:pct}); }
    const arr=byColour.get(cname)||[]; arr.push(...items); byColour.set(cname,arr); FORMULAS_NORM[normaliseName(cname)]=arr;
  });
  (BASE_COLOURS||[]).forEach(c=>{
    const name=c.name||c.Colour||c.color||'', norm=normaliseName(name);
    if (byColour.has(name)) { COLOUR_TO_FORMULA[name]=norm; return; }
    if (FORMULAS_NORM[norm]) { COLOUR_TO_FORMULA[name]=norm; return; }
    const p=extractPmsNumber(name);
    if (p){ for (const key of byColour.keys()){ if ((extractPmsNumber(key)||'')===p){ COLOUR_TO_FORMULA[name]=normaliseName(key); break; } } }
  });
}

// Library handling
function saveLibraries(){
  try{
    const plain = userLibraries.map(l=>({id:l.id,name:l.name,colours:l.colours}));
    localStorage.setItem(LIB_KEY, JSON.stringify(plain));
  }catch{}
}
function loadLibraries(){
  try{
    const raw = localStorage.getItem(LIB_KEY);
    if (!raw) { userLibraries = []; return; }
    const arr = JSON.parse(raw);
    if (!Array.isArray(arr)) { userLibraries = []; return; }
    userLibraries = arr.map(l=>({
      id: String(l.id || crypto.randomUUID()),
      name: String(l.name || 'Unnamed'),
      colours: Array.isArray(l.colours) ? l.colours.map(co=>({
        name: String(co.name || co.Colour || co.color || 'Untitled'),
        L: Number(co.L ?? co.Lstar ?? co['L*'] ?? 0),
        a: Number(co.a ?? co.astar ?? co['a*'] ?? 0),
        b: Number(co.b ?? co.bstar ?? co['b*'] ?? 0),
      })) : []
    }));
  }catch{ userLibraries = []; }
}
function libraryOptions(){
  const opts = [
    {id: LIB_BASE_ID, label: 'Pantone (base)'},
  ];
  userLibraries.forEach(l => opts.push({id: l.id, label: l.name}));
  if (userLibraries.length) opts.push({id: LIB_ALL_ID, label: 'All libraries (combined)'});
  return opts;
}
function refreshLibrarySelects(){
  const opts = libraryOptions();
  const sel1 = $('#librarySelect');
  const sel2 = $('#cmpLibrarySelect');
  const build = (sel)=>{
    sel.innerHTML = '';
    opts.forEach(o=>{
      const opt = document.createElement('option');
      opt.value = o.id; opt.textContent = o.label; sel.appendChild(opt);
    });
    if (!opts.find(o=>o.id === activeLibraryId)) activeLibraryId = LIB_BASE_ID;
    sel.value = activeLibraryId;
  };
  build(sel1); build(sel2);
  const activeLabel = (opts.find(o=>o.id===activeLibraryId)?.label) || 'Pantone (base)';
  $('#activeLibLabel').textContent = activeLabel;
  $('#cmpLibLabel').textContent = activeLabel;
}
function getActiveColours(){
  if (activeLibraryId === LIB_BASE_ID) return BASE_COLOURS;
  if (activeLibraryId === LIB_ALL_ID){
    let all = [...BASE_COLOURS];
    userLibraries.forEach(l => { all = all.concat(l.colours); });
    return all;
  }
  const lib = userLibraries.find(l=>l.id === activeLibraryId);
  return lib ? lib.colours : BASE_COLOURS;
}
function refreshActiveColours(){
  COLOURS = getActiveColours();
  $('#countLabel').textContent = COLOURS.length;
  $('#resultsTbody').innerHTML = '';
  $('#formulaPanel').style.display = 'none';
  refreshCompareDatalists();
}
function renderLibraryList(){
  const wrap = $('#libList');
  if (!userLibraries.length){
    wrap.innerHTML = '<div class="muted">No custom libraries yet. Add one above.</div>';
    return;
  }
  let html = '<h3 style="margin-top:8px;">Your libraries</h3>';
  userLibraries.forEach(l=>{
    html += `<div class="lib-item">
      <div>
        <div class="lib-item-name">${l.name}</div>
        <div class="lib-badge">${l.colours.length} colours</div>
      </div>
      <button class="btn" data-del-lib="${l.id}">Delete</button>
    </div>`;
  });
  wrap.innerHTML = html;
  wrap.querySelectorAll('[data-del-lib]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.getAttribute('data-del-lib');
      userLibraries = userLibraries.filter(l=>l.id !== id);
      saveLibraries();
      refreshLibrarySelects();
      refreshActiveColours();
      renderLibraryList();
    });
  });
}

// parse CSV into colours
function parseCsvColours(text){
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length);
  if (!lines.length) return [];
  const header = lines[0].split(',').map(h=>h.trim().toLowerCase());
  const idxName = header.findIndex(h=>['name','colour','color'].includes(h));
  const idxL = header.findIndex(h=>['l','l*','lstar'].includes(h));
  const idxA = header.findIndex(h=>['a','a*','astar'].includes(h));
  const idxB = header.findIndex(h=>['b','b*','bstar'].includes(h));
  if (idxName<0 || idxL<0 || idxA<0 || idxB<0) throw new Error('CSV must have columns: Name, L, a, b');
  const out = [];
  for (let i=1;i<lines.length;i++){
    const parts = lines[i].split(',').map(x=>x.trim());
    if (parts.length <= Math.max(idxName,idxL,idxA,idxB)) continue;
    const name = parts[idxName] || `Row ${i+1}`;
    const L = parseFloat(parts[idxL]), a = parseFloat(parts[idxA]), b = parseFloat(parts[idxB]);
    if ([L,a,b].some(v=>Number.isNaN(v))) continue;
    out.push({name, L, a, b});
  }
  return out;
}

// ===== Matching / PMS / formulas =====
function getTargetLab(){ const L=parseFloat($('#L').value), a=parseFloat($('#a').value), b=parseFloat($('#b').value); if([L,a,b].some(v=>Number.isNaN(v))) return null; return {L,a,b}; }

function findClosest(){
  const target=getTargetLab(); if(!target){ alert('Enter a valid colour first.'); return; }
  const rows=COLOURS.map(c=>({raw:c,name:c.name||c.Colour||c.color||'—',L:c.L,a:c.a,b:c.b,de:deltaE2000({L:c.L,a:c.a,b:c.b},target)})).sort((a,b)=>a.de-b.de).slice(0,8);
  const tbody=$('#resultsTbody'); tbody.innerHTML='';
  rows.forEach(r=>{
    const tr=document.createElement('tr'); tr.className='result-row';
    const rgb=labToSrgb(r.L,r.a,r.b);
    tr.innerHTML=`<td>${r.name}</td>
      <td><div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div></td>
      <td>${r.L.toFixed(2)}</td><td>${r.a.toFixed(2)}</td><td>${r.b.toFixed(2)}</td>
      <td>${r.de.toFixed(2)}</td>`;
    tr.addEventListener('click',()=>{
      $('#L').value=r.L; $('#a').value=r.a; $('#b').value=r.b; updateTargetEcho(); showFormulaFor(r.name); _lastContextName = r.name;
    });
    tbody.appendChild(tr);
  });
}
function showFormulaFor(colourName){
  const panel=$('#formulaPanel'); let list=null; const bound=COLOUR_TO_FORMULA[colourName];
  if(bound) list=FORMULAS_NORM[bound]; if(!list) list=FORMULAS_NORM[normaliseName(colourName)];
  if(!list){ const want=extractPmsNumber(colourName); if(want){ for (const key in FORMULAS_NORM){ if ((extractPmsNumber(key)||'')===want){ list=FORMULAS_NORM[key]; break; } } } }
  if(!list||!list.length){ panel.style.display='none'; return; }
  let html=`<h2>Existing Formula: ${colourName}</h2><div class="formula-grid">`;
  list.forEach(item=>{ const name=item.ink||item.Ink||'Ink'; const pct=item.percent!==''?(item.percent+'%'):''; html+=`<div class="fg-ink">${name}</div><div class="fg-pct">${pct}</div>`; });
  html+='</div>'; panel.innerHTML=html; panel.style.display='block';
}
function findByPms(){
  const qRaw=($('#pms').value||'').trim().toUpperCase(); if(!qRaw){ alert('Enter a PMS number'); return; }
  const q=qRaw.replace(/^PANTONE\s*/,''); const hits=COLOURS.filter(c=>{ const p=extractPmsNumber(c.name||c.Colour||c.color||''); return p && p.includes(q); });
  const tbody=$('#resultsTbody'); tbody.innerHTML=''; if(!hits.length){ alert('No PMS match found'); return; }
  hits.slice(0,8).forEach(c=>{
    const rgb=labToSrgb(c.L,c.a,c.b); const tr=document.createElement('tr'); tr.className='result-row';
    tr.innerHTML=`<td>${(c.name||c.Colour||c.color||'—')}</td>
      <td><div class="swatch" style="background: rgb(${rgb.r},${rgb.g},${rgb.b})"></div></td>
      <td>${(+c.L).toFixed(2)}</td><td>${(+c.a).toFixed(2)}</td><td>${(+c.b).toFixed(2)}</td><td>—</td>`;
    tr.addEventListener('click',()=>{ $('#L').value=c.L; $('#a').value=c.a; $('#b').value=c.b; updateTargetEcho(); showFormulaFor(c.name||c.Colour||c.color||''); _lastContextName = c.name||c.Colour||c.color||''; });
    tbody.appendChild(tr);
  });
  const c0=hits[0]; $('#L').value=c0.L; $('#a').value=c0.a; $('#b').value=c0.b; updateTargetEcho(); _lastContextName = c0.name||c0.Colour||c0.color||'';
}

// Predictor / groups
async function loadGroups(){
  try{
    const r=await fetch(API_BASE+'/groups'); const j=await r.json();
    const sel=$('#groupSelect'); (j.groups||[]).forEach(g=>{ const opt=document.createElement('option'); opt.value=g; opt.textContent=g; sel.appendChild(opt); });
  }catch{}
}
async function loadInks(){
  try{ const r=await fetch(API_BASE+'/inks'); const j=await r.json(); _allInks=(j.inks||[]).slice().sort(); }catch{ _allInks=[]; }
}
function formulaPairs(formula){ return Object.entries(formula||{}).filter(([_,v])=>+v>0).sort((a,b)=>b[1]-a[1]); }

async function suggestFormula(){
  const btn=$('#suggestBtn'), msg=$('#predictMsg'), box=$('#suggestedFormula');
  const t=getTargetLab(); if(!t){ alert('Enter a valid L*a*b* first.'); return; }

  btn.disabled=true; msg.textContent='Predicting…';
  box.style.display='none'; box.innerHTML='';
  $('#editRow').style.display='none';

  try{
    const group=($('#groupSelect').value||''); const body={L:t.L,a:t.a,b:t.b,lock_neighbours:true}; if(group) body.group=group;
    const res=await fetch(API_BASE+'/predict',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    if(!res.ok){ throw new Error(`API ${res.status}: ${await res.text()}`); }
    const data=await res.json();
    const formula = (data && typeof data.formula === 'object') ? data.formula : {};
    const pairs=formulaPairs(formula);

    let html='<h2>Suggested Formula</h2><div class="formula-grid" id="suggestedFormulaGrid">';
    if (pairs.length === 0) {
      html += '<div class="fg-ink">—</div><div class="fg-pct">0.00%</div>';
    } else {
      for (const [ink,pct] of pairs) html+=`<div class="fg-ink">${ink}</div><div class="fg-pct">${(+pct).toFixed(2)}%</div>`;
    }
    html+='</div>';
    box.innerHTML=html; box.style.display='block'; msg.textContent='';

    _lastSuggestion={ target:t, formula, group: (group||null) };

    $('#editRow').style.display='flex';
  }catch(err){
    msg.textContent=String(err.message||err);
    $('#editRow').style.display='none';
  } finally {
    btn.disabled=false;
  }
}

// ===== Edit modal / logging =====
const modal = $('#editModal');
const editList = $('#editList');
let working = []; // [{ink, pct}]
function contextLine(){
  const t = _lastSuggestion?.target;
  if (!t) return '';
  const name = _lastContextName ? ` · ${_lastContextName}` : '';
  return `Target: L=${t.L.toFixed(2)} a=${t.a.toFixed(2)} b=${t.b.toFixed(2)}${name}`;
}
function openEdit(){
  if(!_lastSuggestion || !(_lastSuggestion.formula)) { alert('No suggestion to edit yet.'); return; }
  working = formulaPairs(_lastSuggestion.formula).map(([ink,p])=>({ink,pct:+(+p).toFixed(2)}));
  renderEditList();
  const sel = $('#addInkSel'); sel.innerHTML = '';
  _allInks.forEach(name=>{ const opt=document.createElement('option'); opt.value=name; opt.textContent=name; sel.appendChild(opt); });
  $('#addPct').value = '';
  $('#corrNote').value = '';
  $('#editContext').textContent = contextLine();
  modal.style.display='flex';
  updateTotals();
}
function closeEdit(){ modal.style.display='none'; }
function renderEditList(){
  editList.innerHTML = '';
  working.forEach((row, idx)=>{
    const wrap = document.createElement('div'); wrap.className='edit-row';
    const nameInput = document.createElement('input'); nameInput.value=row.ink; nameInput.readOnly=true; nameInput.className='mono';
    const pctInput = document.createElement('input'); pctInput.type='number'; pctInput.step='0.01'; pctInput.value=Number(row.pct).toFixed(2); pctInput.className='pct-input mono'; pctInput.addEventListener('input',()=>{ row.pct = +pctInput.value; updateTotals(); });
    const del = document.createElement('button'); del.className='rem-btn'; del.innerHTML='✕'; del.title='Remove'; del.addEventListener('click',()=>{ working.splice(idx,1); renderEditList(); updateTotals(); });
    wrap.appendChild(nameInput); wrap.appendChild(pctInput); wrap.appendChild(del); editList.appendChild(wrap);
  });
}
function updateTotals(){
  const total = working.reduce((s,r)=> s + (+r.pct||0), 0);
  $('#totalPct').textContent = total.toFixed(2);
  const good = approx(total,100,0.01);
  $('#totalState').textContent = good ? 'normalised' : 'needs normalising';
  $('#totalState').className = good ? 'ok' : 'warn';
}
function normalise(){
  const sum = working.reduce((s,r)=> s + (+r.pct||0), 0) || 1;
  working.forEach(r=> r.pct = +(r.pct * 100 / sum).toFixed(2));
  renderEditList(); updateTotals();
}
function addInk(){
  const name = $('#addInkSel').value; let pct = +($('#addPct').value||0);
  if(!name || !(pct>0)) return;
  const found = working.find(r=> r.ink === name);
  if(found) found.pct = +(found.pct + pct).toFixed(2);
  else working.push({ink:name, pct:+pct.toFixed(2)});
  $('#addPct').value=''; renderEditList(); updateTotals();
}
async function saveCorrection(){
  if(!_lastSuggestion) return;
  const sum = working.reduce((s,r)=> s + (+r.pct||0), 0);
  if (!approx(sum,100,0.02)) normalise();
  const corrected = {}; working.forEach(r=>{ if ((+r.pct)>0) corrected[r.ink] = +(+r.pct).toFixed(2); });
  const payload = {
    target: _lastSuggestion.target,
    group: _lastSuggestion.group || null,
    original: _lastSuggestion.formula,
    corrected,
    context_name: _lastContextName || null,
    note: ($('#corrNote').value||'').trim() || null,
    measured: null
  };
  try{
    const res = await fetch(API_BASE + '/log_correction', {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)
    });
    if(!res.ok){ throw new Error(`API ${res.status}: ${await res.text()}`); }
    alert('Saved correction. It will be available for the next training cycle.');
    closeEdit();
  }catch(err){
    alert('Error saving correction: ' + (err.message||err));
  }
}

// ===== Compare tab logic + 3D viz =====
function setSwatchFromFields(prefix){
  const L=parseFloat($('#'+prefix+'L').value), a=parseFloat($('#'+prefix+'a').value), b=parseFloat($('#'+prefix+'b').value);
  if ([L,a,b].some(v=>Number.isNaN(v))) return; const rgb=labToSrgb(L,a,b);
  $('#swatch'+prefix).style.background=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
  const legend = prefix === 'A' ? $('#legendA') : $('#legendB');
  legend.style.background = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
}
function computeCompareDE(){
  const a={L:parseFloat($('#AL').value),a:parseFloat($('#Aa').value),b:parseFloat($('#Ab').value)};
  const b={L:parseFloat($('#BL').value),a:parseFloat($('#Ba').value),b:parseFloat($('#Bb').value)};
  if ([a.L,a.a,a.b,b.L,b.a,b.b].some(v=>Number.isNaN(v))){
    $('#cmpNumbers').innerHTML=''; $('#cmpResult').style.display='none'; requestLabDraw(); return;
  }
  const de=deltaE2000(a,b), dL=(b.L-a.L), da=(b.a-a.a), db=(b.b-a.b);
  $('#cmpNumbers').innerHTML=`<div class="two-col"><div><strong>ΔE2000:</strong> ${de.toFixed(2)}</div><div><strong>ΔL:</strong> ${dL.toFixed(2)} &nbsp; <strong>Δa:</strong> ${da.toFixed(2)} &nbsp; <strong>Δb:</strong> ${db.toFixed(2)}</div></div>`;
  $('#cmpResult').style.display='block'; requestLabDraw();
}
document.addEventListener('input',(e)=>{
  if (e.target && e.target.tagName==='INPUT' && e.target.type==='number'){
    const id=e.target.id||'';
    if (/^(AL|Aa|Ab)$/.test(id)) { setSwatchFromFields('A'); computeCompareDE(); }
    if (/^(BL|Ba|Bb)$/.test(id)) { setSwatchFromFields('B'); computeCompareDE(); }
  }
});
$('#swapAB').addEventListener('click', ()=>{
  const AL=$('#AL').value, Aa=$('#Aa').value, Ab=$('#Ab').value;
  $('#AL').value=$('#BL').value; $('#Aa').value=$('#Ba').value; $('#Ab').value=$('#Bb').value;
  $('#BL').value=AL; $('#Ba').value=Aa; $('#Bb').value=Ab; setSwatchFromFields('A'); setSwatchFromFields('B'); computeCompareDE();
});

// 3D LAB sphere with coloured panes
const canvas=$('#labCanvas'), ctx=canvas.getContext('2d');
const DEFAULT_VIEW={rx:-0.6, ry:0.8, s:220};
let rotX=DEFAULT_VIEW.rx, rotY=DEFAULT_VIEW.ry, scale3d=DEFAULT_VIEW.s;
let dragging=false,lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup',()=> dragging=false);
window.addEventListener('mousemove',e=>{ if(!dragging) return; const dx=(e.clientX-lastX), dy=(e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; rotY -= dx*0.005; rotX -= dy*0.005; requestLabDraw(); });
canvas.addEventListener('wheel', e=>{ e.preventDefault(); const f=(e.deltaY>0)?0.9:1.1; scale3d=clamp(scale3d*f,80,1200); requestLabDraw(); }, {passive:false});
$('#resetView').addEventListener('click', ()=>{ rotX=DEFAULT_VIEW.rx; rotY=DEFAULT_VIEW.ry; scale3d=DEFAULT_VIEW.s; requestLabDraw(); });

function normLab(L,a,b){ return { x:(a/128), y:((L-50)/50), z:(b/128) }; }
function rot3(p){ const cX=Math.cos(rotX), sX=Math.sin(rotX), cY=Math.cos(rotY), sY=Math.sin(rotY); let y=p.y*cX - p.z*sX; let z=p.y*sX + p.z*cX; let x=p.x*cY + z*sY; z = -p.x*sY + z*cY; return {x,y,z}; }
function proj(p){ const d=3; const z=p.z+3.5; const k=d/(z); return {u:canvas.width/2 + p.x*scale3d*k, v:canvas.height/2 - p.y*scale3d*k, k, z:p.z}; }

function drawSpherePanes(){
  const R=1.08, M=24, P=18, baseAlpha=0.20; const thetas=[...Array(M)].map((_,i)=>-Math.PI + i*(2*Math.PI/(M-1)));
  const phis=[...Array(P)].map((_,j)=>-Math.PI/2 + j*((Math.PI)/(P-1)));
  function objPoint(phi,theta){ return { x0:R*Math.cos(phi)*Math.cos(theta), y0:R*Math.sin(phi), z0:R*Math.cos(phi)*Math.sin(theta) }; }
  function toScreen(o){ const pr=rot3({x:o.x0,y:o.y0,z:o.z0}); const sc=proj(pr); return {u:sc.u,v:sc.v,z:pr.z,k:sc.k}; }
  function rgbaFromObj(o,a){ const L=o.y0*50+50, A=o.x0*128, B=o.z0*128; const rgb=labToSrgb(L,A,B); return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`; }
  const quads=[];
  for(let j=0,idx=0;j<P-1;j++){
    for(let i=0;i<M-1;i++,idx++){
      const o00=objPoint(phis[j],thetas[i]), o10=objPoint(phis[j],thetas[i+1]);
      const o01=objPoint(phis[j+1],thetas[i]), o11=objPoint(phis[j+1],thetas[i+1]);
      const ux=o10.x0-o00.x0, uy=o10.y0-o00.y0, uz=o10.z0-o00.z0;
      const vx=o01.x0-o00.x0, vy=o01.y0-o00.y0, vz=o01.z0-o00.z0;
      const nx=uy*vz-uz*vy, ny=uz*vx-ux*vz, nz=ux*vy-uy*vx;
      const nRot=rot3({x:nx,y:ny,z:nz}); const nLen=Math.hypot(nRot.x,nRot.y,nRot.z)||1e-9; const nzCam=nRot.z/nLen;
      if (nzCam < -0.15) continue;
      const vis = (nzCam<=0)?0: (nzCam>=0.1?1:(nzCam/0.1)); const alpha=baseAlpha*(0.15+0.85*vis);
      const s00=toScreen(o00), s10=toScreen(o10), s01=toScreen(o01), s11=toScreen(o11);
      const avgZ=(s00.z+s10.z+s01.z+s11.z)/4;
      const oMid={ x0:(o00.x0+o10.x0+o01.x0+o11.x0)/4, y0:(o00.y0+o10.y0+o01.y0+o11.y0)/4, z0:(o00.z0+o10.z0+o01.z0+o11.z0)/4 };
      const col=rgbaFromObj(oMid,alpha);
      const stableZ = avgZ + ((i*37 + j*101) % 113) * 1e-6;
      quads.push({stableZ, col, pts:[s00,s10,s11,s01]});
    }
  }
  quads.sort((a,b)=> a.stableZ - b.stableZ);
  ctx.save(); ctx.lineWidth=0.6;
  for(const q of quads){ ctx.fillStyle=q.col; ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.beginPath(); ctx.moveTo(q.pts[0].u,q.pts[0].v); for(let k=1;k<q.pts.length;k++) ctx.lineTo(q.pts[k].u,q.pts[k].v); ctx.closePath(); ctx.fill(); ctx.stroke(); }
  ctx.restore();
}
function drawSphere(){
  const R=1.1, MER=28, PAR=20, STEP=Math.PI/64;
  function tint(x0,y0,z0,a){ const L=y0*50+50,A=x0*128,B=z0*128; const rgb=labToSrgb(L,A,B); return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`; }
  const c=proj(rot3({x:0,y:0,z:0})), edge=proj(rot3({x:R,y:0,z:0})); const rad=Math.hypot(edge.u+c.u*-1, edge.v+c.v*-1);
  ctx.strokeStyle='rgba(255,255,255,0.28)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(c.u,c.v,rad,0,Math.PI*2); ctx.stroke();
  for(let i=0;i<MER;i++){
    const th=-Math.PI + i*(2*Math.PI/(MER-1)); let first=true,lastObj=null,lastScr=null;
    for(let t=-Math.PI/2;t<=Math.PI/2;t+=STEP){
      const x0=R*Math.cos(t)*Math.cos(th), y0=R*Math.sin(t), z0=R*Math.cos(t)*Math.sin(th);
      const p=rot3({x:x0,y:y0,z:z0}), q=proj(p);
      if(!first){ const mx0=(lastObj.x+x0)/2,my0=(lastObj.y+y0)/2,mz0=(lastObj.z+z0)/2; ctx.strokeStyle=tint(mx0,my0,mz0,0.22); ctx.lineWidth=1.6; ctx.beginPath(); ctx.moveTo(lastScr.u,lastScr.v); ctx.lineTo(q.u,q.v); ctx.stroke(); }
      first=false; lastObj={x:x0,y:y0,z:z0}; lastScr=q;
    }
  }
  for(let j=0;j<PAR;j++){
    const ph=-Math.PI/2 + j*(Math.PI/(PAR-1)); let first=true,lastObj=null,lastScr=null;
    for(let t=-Math.PI;t<=Math.PI;t+=STEP){
      const x0=R*Math.cos(ph)*Math.cos(t), y0=R*Math.sin(ph), z0=R*Math.cos(ph)*Math.sin(t);
      const p=rot3({x:x0,y:y0,z:z0}), q=proj(p);
      if(!first){ const mx0=(lastObj.x+x0)/2,my0=(lastObj.y+y0)/2,mz0=(lastObj.z+z0)/2; ctx.strokeStyle=tint(mx0,my0,mz0,0.22); ctx.lineWidth=1.6; ctx.beginPath(); ctx.moveTo(lastScr.u,lastScr.v); ctx.lineTo(q.u,q.v); ctx.stroke(); }
      first=false; lastObj={x:x0,y:y0,z:z0}; lastScr=q;
    }
  }
}
function drawPointLab(L,a,b,label){
  const p=proj(rot3(normLab(L,a,b))), rgb=labToSrgb(L,a,b), col=`rgb(${rgb.r},${rgb.g},${rgb.b})`;
  ctx.fillStyle=col; ctx.strokeStyle='rgba(0,0,0,0.55)'; ctx.beginPath(); ctx.arc(p.u,p.v,6*p.k,0,Math.PI*2); ctx.fill(); ctx.lineWidth=1; ctx.stroke();
  ctx.fillStyle='#e5e7eb'; ctx.font='12px ui-sans-serif, system-ui'; ctx.fillText(label, p.u+8, p.v-8);
  return p;
}
function drawLineLab(A,B){
  const p1=proj(rot3(normLab(A.L,A.a,A.b))); const p2=proj(rot3(normLab(B.L,B.a,B.b)));
  ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p1.u,p1.v); ctx.lineTo(p2.u,p2.v); ctx.stroke();
}
function drawAxes(){
  const axes=[ {from:{L:50,a:-128,b:0},to:{L:50,a:128,b:0},label:'+a*'}, {from:{L:0,a:0,b:0},to:{L:100,a:0,b:0},label:'L*'}, {from:{L:50,a:0,b:-128},to:{L:50,a:0,b:128},label:'+b*'} ];
  ctx.lineWidth=2.2; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.fillStyle='#e5e7eb'; ctx.font='12px ui-sans-serif, system-ui';
  axes.forEach(ax=>{ const p1=proj(rot3(normLab(ax.from.L,ax.from.a,ax.from.b))); const p2=proj(rot3(normLab(ax.to.L,ax.to.a,ax.to.b)));
    ctx.beginPath(); ctx.moveTo(p1.u,p1.v); ctx.lineTo(p2.u,p2.v); ctx.stroke();
    const T=6; for(let i=1;i<T;i++){ const t=i/T; const L=ax.from.L+(ax.to.L-ax.from.L)*t, a=ax.from.a+(ax.to.a-ax.from.a)*t, b=ax.from.b+(ax.to.b-ax.from.b)*t; const p=proj(rot3(normLab(L,a,b)));
      const dirX=(p2.u-p1.u), dirV=(p2.v-p1.v), len=Math.hypot(dirX,dirV)||1, nx=-dirV/len, ny=dirX/len, tick=6*p.k;
      ctx.beginPath(); ctx.moveTo(p.u-nx*tick,p.v-ny*tick); ctx.lineTo(p.u+nx*tick,p.v+ny*tick); ctx.stroke();
    }
    ctx.fillText(ax.label, p2.u+6, p2.v-6);
  });
}
function drawLabScene(){
  const a={L:parseFloat($('#AL').value), a:parseFloat($('#Aa').value), b:parseFloat($('#Ab').value)};
  const b={L:parseFloat($('#BL').value), a:parseFloat($('#Ba').value), b:parseFloat($('#Bb').value)};
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#0f1219'; ctx.fillRect(0,0,canvas.width,canvas.height);
  drawSpherePanes(); drawSphere(); drawAxes();
  const aValid=[a.L,a.a,a.b].every(Number.isFinite), bValid=[b.L,b.a,b.b].every(Number.isFinite);
  if (aValid && bValid){ drawLineLab(a,b); drawPointLab(a.L,a.a,a.b,'A'); drawPointLab(b.L,b.a,b.b,'B'); const de=deltaE2000(a,b); ctx.fillStyle='#e5e7eb'; ctx.font='13px ui-sans-serif, system-ui'; ctx.fillText('ΔE2000: '+de.toFixed(2), 12, 18); }
  else { ctx.fillStyle='#e5e7eb'; ctx.font='13px ui-sans-serif, system-ui'; ctx.fillText('Enter L*a*b* for both A and B to render.', 12, 18); }
}
let rafId=null; function requestLabDraw(){ if(rafId) cancelAnimationFrame(rafId); rafId = requestAnimationFrame(()=>{ rafId=null; drawLabScene(); }); }

// Compare tab datalists based on active library
function refreshCompareDatalists(){
  const opts = COLOURS.map(c=>{
    const name = (c.name||c.Colour||c.color||'').trim();
    return name ? `<option value="${name}">` : '';
  }).join('');
  $('#cmpListA').innerHTML = opts;
  $('#cmpListB').innerHTML = opts;
}

// Tabs switching
const tabBtnMatch=$('#tabBtnMatch'), tabBtnCompare=$('#tabBtnCompare'), tabBtnLibraries=$('#tabBtnLibraries');
const tabMatch=$('#tab-match'), tabCompare=$('#tab-compare'), tabLibraries=$('#tab-libraries');
function showTab(which){
  tabMatch.hidden = which!=='match';
  tabCompare.hidden = which!=='compare';
  tabLibraries.hidden = which!=='libraries';
  tabBtnMatch.setAttribute('aria-selected', which==='match' ? 'true':'false');
  tabBtnCompare.setAttribute('aria-selected', which==='compare' ? 'true':'false');
  tabBtnLibraries.setAttribute('aria-selected', which==='libraries' ? 'true':'false');
  if (which === 'compare') requestLabDraw();
}
tabBtnMatch.addEventListener('click',()=>showTab('match'));
tabBtnCompare.addEventListener('click',()=>showTab('compare'));
tabBtnLibraries.addEventListener('click',()=>showTab('libraries'));

// Wire up
$('#findBtn').addEventListener('click', findClosest);
$('#clearBtn').addEventListener('click', ()=>{ $('#L').value=''; $('#a').value=''; $('#b').value=''; updateTargetEcho(); $('#resultsTbody').innerHTML=''; $('#formulaPanel').style.display='none'; $('#suggestedFormula').style.display='none'; $('#predictMsg').textContent=''; $('#editRow').style.display='none'; });
$('#suggestBtn').addEventListener('click', suggestFormula);
$('#pmsBtn').addEventListener('click', findByPms);
['L','a','b'].forEach(id=>$('#'+id).addEventListener('input', updateTargetEcho));

$('#editFormulaBtn').addEventListener('click', openEdit);
$('#cancelEdit').addEventListener('click', closeEdit);
$('#normaliseBtn').addEventListener('click', normalise);
$('#addInkBtn').addEventListener('click', addInk);
$('#addPct').addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); addInk(); } });
$('#saveCorrection').addEventListener('click', saveCorrection);

// Library UI events
$('#librarySelect').addEventListener('change', (e)=>{
  activeLibraryId = e.target.value || LIB_BASE_ID;
  refreshLibrarySelects();
  refreshActiveColours();
});
$('#cmpLibrarySelect').addEventListener('change', (e)=>{
  activeLibraryId = e.target.value || LIB_BASE_ID;
  refreshLibrarySelects();
  refreshActiveColours();
});
$('#libAddBtn').addEventListener('click', ()=>{
  const name = ($('#libName').value||'').trim();
  const file = $('#libFile').files[0];
  if (!name){ alert('Please enter a library name.'); return; }
  if (!file){ alert('Please choose a CSV file.'); return; }
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const colours = parseCsvColours(reader.result);
      if (!colours.length){ alert('No valid rows found (L/a/b empty?).'); return; }
      const lib = { id: crypto.randomUUID(), name, colours };
      userLibraries.push(lib);
      saveLibraries();
      $('#libName').value=''; $('#libFile').value='';
      renderLibraryList();
      refreshLibrarySelects();
      // keep current library unless you want to auto-switch
    }catch(err){
      alert('Error parsing CSV: ' + (err.message||err));
    }
  };
  reader.onerror = ()=> alert('Error reading file.');
  reader.readAsText(file);
});

// Download example CSV
$('#libTemplateBtn').addEventListener('click', ()=>{
  const csv = [
    'Name,L,a,b',
    'Custom Red 1,50.00,70.00,50.00',
    'Custom Green 1,55.00,-40.00,40.00',
    'Custom Blue 1,45.00,20.00,-50.00',
    'Warm Grey-ish,70.00,2.00,5.00'
  ].join('\r\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'colour_library_template.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// Compare tab quick-load
$('#cmpALoad').addEventListener('click', ()=>{
  const name=$('#cmpASelect').value; if(!name) return;
  const c=COLOURS.find(x=>(x.name||x.Colour||x.color||'')===name); if(!c) return;
  $('#AL').value=c.L; $('#Aa').value=c.a; $('#Ab').value=c.b; setSwatchFromFields('A'); computeCompareDE();
});
$('#cmpBLoad').addEventListener('click', ()=>{
  const name=$('#cmpBSelect').value; if(!name) return;
  const c=COLOURS.find(x=>(x.name||x.Colour||x.color||'')===name); if(!c) return;
  $('#BL').value=c.L; $('#Ba').value=c.a; $('#Bb').value=c.b; setSwatchFromFields('B'); computeCompareDE();
});

// Data load
Promise.all([ fetch('colours.json').then(r=>r.json()), fetch('DC_Formulas.json').then(r=>r.json()) ])
.then(tuple=>{
  BASE_COLOURS=tuple[0].map(c=>({name:c.name||c.Colour||c.color||'', L:c.L, a:c.a, b:c.b}));
  COLOURS = BASE_COLOURS.slice();
  FORMULAS=tuple[1];
  buildFormulaIndex();
  loadLibraries();
  refreshLibrarySelects();
  refreshActiveColours();
  renderLibraryList();
}).catch(err=>{ alert('Error loading JSON: '+err); });

loadGroups(); loadInks(); updateTargetEcho();

// Self-test
try{
  const c={L:50,a:0,b:0};
  console.assert(approx(deltaE2000(c,c),0),'ΔE00 identity');
  const c1={L:60,a:10,b:-5}, c2={L:55,a:-3,b:9};
  console.assert(approx(deltaE2000(c1,c2),deltaE2000(c2,c1),1e-9),'ΔE00 symmetry');
}catch(e){ console.warn('Self-tests failed:', e); }

})();
</script>
</body>
</html>
