<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Ink Mix Predictor — 6v Anilox (Pantone ΔE + KM)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0f1115; --panel:#151923; --muted:#8a90a5; --text:#e9edf3; --accent:#7bd389; --warn:#f6d36b; --bad:#ff7a7a; --chipBorder:#272b34;
  }
  *{box-sizing:border-box}
  body{margin:0; font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:var(--bg); color:var(--text)}
  header{padding:18px 22px; border-bottom:1px solid #232737; background:linear-gradient(180deg,#141824,#11141d)}
  h1{margin:0; font-size:18px; letter-spacing:.3px}
  main{display:grid; gap:16px; grid-template-columns: 360px 1fr; padding:18px}
  .card{background:var(--panel); border:1px solid #232737; border-radius:14px; padding:14px}
  .row{display:flex; gap:10px; align-items:center}
  label{display:block; font-size:12px; color:var(--muted); margin-bottom:4px}
  input[type="number"], input[type="text"], select{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a2f3f; background:#0e111a; color:var(--text); outline:none;
  }
  input[type="number"]::-webkit-outer-spin-button, input[type="number"]::-webkit-inner-spin-button{appearance:none;margin:0}
  button{ background:#1c2230; color:var(--text); border:1px solid #2a2f3f; padding:10px 12px; border-radius:10px; cursor:pointer; }
  button.primary{background:var(--accent); color:#0b1016; border:none; font-weight:600}
  .grid{display:grid; gap:10px}
  .grid.cols-2{grid-template-columns:1fr 1fr}
  .grid.cols-3{grid-template-columns:1fr 1fr 1fr}
  .muted{color:var(--muted)}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a2f3f; color:var(--muted); font-size:12px}
  .chip{width:36px; height:24px; border-radius:6px; border:1px solid var(--chipBorder)}
  .list{display:grid; gap:8px; margin-top:6px}
  .swatchRow{display:grid; grid-template-columns: 48px 1fr auto; gap:12px; align-items:center; padding:8px; border-radius:10px; border:1px solid #222738; background:#111521}
  .swatchRow:hover{border-color:#2e3448}
  .linkish{cursor:pointer; text-decoration:none; color:inherit}
  .tag{font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #2a2f3f; color:var(--muted); background:#0f1420}
  .sectionTitle{font-weight:600; margin:4px 0 8px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .flex-between{display:flex; justify-content:space-between; align-items:center}
  .bad{color:var(--bad)} .warn{color:var(--warn)} .good{color:var(--accent)}
  .table{width:100%; border-collapse:separate; border-spacing:0 6px; font-size:13px}
  .table td{padding:6px 8px; background:#0f131f; border-top:1px solid #22283a; border-bottom:1px solid #22283a}
  .table tr td:first-child{border-left:1px solid #22283a; border-top-left-radius:8px; border-bottom-left-radius:8px}
  .table tr td:last-child{border-right:1px solid #22283a; border-top-right-radius:8px; border-bottom-right-radius:8px}
  .small{font-size:12px}
  .sliderRow{display:grid; grid-template-columns:120px 1fr 56px; gap:10px; align-items:center}
  .hint{font-size:12px; color:var(--muted)}
  .hr{height:1px; background:#22283a; margin:10px 0}
  .kbd{font-size:12px; border:1px solid #2a2f3f; background:#111521; padding:2px 6px; border-radius:6px}
  .footer{padding:12px 18px; border-top:1px solid #232737; color:var(--muted); font-size:12px}
</style>
</head>
<body>
<header>
  <h1>🎯 Ink Mix Predictor — Kubelka–Munk (Calibrated: 6-volume anilox)</h1>
</header>

<main>
  <!-- LEFT: Inputs and Nearest Matches -->
  <section class="card">
    <div class="grid">
      <div>
        <label for="pantoneSearch">Pantone search (optional)</label>
        <input id="pantoneSearch" placeholder="e.g., PANTONE 186 C" />
      </div>
      <div class="grid cols-3">
        <div>
          <label for="L">L*</label>
          <input id="L" type="number" step="0.01" value="50" />
        </div>
        <div>
          <label for="a">a*</label>
          <input id="a" type="number" step="0.01" value="0" />
        </div>
        <div>
          <label for="b">b*</label>
          <input id="b" type="number" step="0.01" value="0" />
        </div>
      </div>
      <div class="row">
        <button id="matchBtn" class="primary">Find closest 8</button>
        <span class="hint">Enter LAB or pick a Pantone to prefill LAB.</span>
      </div>
    </div>

    <div class="hr"></div>

    <div id="nearestWrap">
      <div class="flex-between">
        <div class="sectionTitle">Closest Pantone (ΔE00)</div>
        <div class="pill small" id="pantoneCount">0 total</div>
      </div>
      <div class="list" id="nearestList"></div>
    </div>
  </section>

  <!-- RIGHT: Existing Formula + Predictor -->
  <section class="card">
    <div class="grid">
      <div class="sectionTitle">Existing Formula (if available)</div>
      <div id="existingFormula" class="muted small">Click a Pantone from the left to reveal stored formula.</div>

      <div class="hr"></div>

      <div class="sectionTitle">Predict a New Formula (Two-Constant KM)</div>
      <div class="grid cols-2">
        <div class="sliderRow">
          <div class="hint">Max ingredients</div>
          <input id="maxInks" type="range" min="2" max="6" step="1" value="4" />
          <div class="pill" id="maxInksVal">4</div>
        </div>
        <div class="sliderRow">
          <div class="hint">Max Black (%)</div>
          <input id="maxBlack" type="range" min="0" max="40" step="1" value="10" />
          <div class="pill" id="maxBlackVal">10%</div>
        </div>
      </div>
      <div class="grid cols-2">
        <div class="sliderRow">
          <div class="hint">Extender policy</div>
          <select id="preferExt">
            <option value="auto" selected>Auto</option>
            <option value="always">Always include</option>
            <option value="never">Never include</option>
          </select>
          <div class="pill">Filmweight t₀ auto-fit (6v)</div>
        </div>
        <div class="row">
          <button id="predictBtn" class="primary">Suggest formula</button>
          <span id="predictStatus" class="hint"></span>
        </div>
      </div>

      <div class="hr"></div>

      <div id="predictionOutput" style="display:none">
        <div class="flex-between">
          <div class="sectionTitle">Suggested Mix</div>
          <div id="predDe" class="pill">ΔE00: –</div>
        </div>
        <table class="table" id="mixTable"></table>
        <div class="row">
          <div class="pill" id="predLab">L*a*b*: –</div>
          <div id="predWarn" class="hint"></div>
        </div>
        <div class="hint" id="calibHint"></div>
      </div>
    </div>
  </section>
</main>

<div class="footer">
  Files must sit next to this page: <span class="kbd">colours.json</span> · <span class="kbd">DC_Formulas.json</span> · <span class="kbd">DC21_jan25.json</span> · <span class="kbd">assortment_colour_data.json</span>. |
  D50/2°, 45/0, gloss excluded. Filmweight locked by 6v calibration (t₀ auto-fit at load).
</div>

<script>
/* ===========================
   Helpers
=========================== */
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function round2(x){ return Math.round(x*100)/100; }
function numOr(v, alt){
  const n = (v === null || v === undefined || v === '') ? NaN : Number(v);
  if (Number.isFinite(n)) return n;
  const m = (alt === null || alt === undefined || alt === '') ? NaN : Number(alt);
  return Number.isFinite(m) ? m : NaN;
}
async function fetchJSON(path){
  const r = await fetch(path);
  if(!r.ok) throw new Error('Failed to fetch '+path+': '+r.status+' '+r.statusText);
  return r.json();
}
// Normalise “could be array, object, or wrapper with .records/.data”
function asArray(maybe){
  if (Array.isArray(maybe)) return maybe;
  if (maybe && typeof maybe === 'object'){
    if (Array.isArray(maybe.records)) return maybe.records;
    if (Array.isArray(maybe.data)) return maybe.data;
    // object of keyed entries -> values
    return Object.values(maybe);
  }
  return [];
}

/* ===========================
   Colour Math
=========================== */
const WL = Array.from({length:36},(_,i)=>380+10*i);
const CMF = {
  x:[0.001368,0.002236,0.004243,0.007650,0.014310,0.023190,0.043510,0.077630,0.134380,0.214770,0.283900,0.328500,0.348280,0.348060,0.336200,0.318700,0.290800,0.251100,0.195360,0.142100,0.095640,0.057950,0.032010,0.014700,0.004900,0.002400,0.009300,0.029100,0.063270,0.109600,0.165500,0.225750,0.290400,0.359700,0.433450,0.512050],
  y:[0.000039,0.000064,0.000120,0.000217,0.000396,0.000640,0.001210,0.002180,0.004000,0.007300,0.011600,0.016840,0.023000,0.029800,0.038000,0.048000,0.060000,0.073900,0.090980,0.112600,0.139020,0.169300,0.208020,0.258600,0.323000,0.407300,0.503000,0.608200,0.710000,0.793200,0.862000,0.914850,0.954000,0.980300,0.994950,1.000000],
  z:[0.006450,0.010550,0.020050,0.036210,0.067850,0.110200,0.207400,0.371300,0.645600,1.039050,1.385600,1.622960,1.747060,1.782600,1.772110,1.744100,1.669200,1.528100,1.287640,1.041900,0.812950,0.616200,0.465180,0.353300,0.272000,0.212300,0.158200,0.111700,0.078250,0.057250,0.042160,0.029840,0.020300,0.013400,0.008750,0.005750]
};
const D50 = [0.0341,0.3601,0.6861,1.0120,1.3382,1.6643,1.9903,2.3164,2.6424,2.9685,3.2945,3.6205,3.9466,4.2726,4.5987,4.9247,5.2508,5.5768,5.9029,6.2289,6.5550,6.8810,7.2070,7.5331,7.8591,8.1852,8.5112,8.8373,9.1633,9.4893,9.8154,10.141,10.467,10.793,11.119,11.445];
function trapz(y, step){ let s=0; for(let i=1;i<y.length;i++) s += (y[i-1]+y[i]); return s * step/2; }
const k_norm = 100 / trapz(WL.map((_,i)=>D50[i]*CMF.y[i]),10);
const whiteD50 = (()=>({ X: k_norm*trapz(WL.map((_,i)=>D50[i]*CMF.x[i]),10), Y:100, Z: k_norm*trapz(WL.map((_,i)=>D50[i]*CMF.z[i]),10) }))();

function xyzFromSpectrum(R){
  const X = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.x[i]),10);
  const Y = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.y[i]),10);
  const Z = k_norm*trapz(WL.map((_,i)=>D50[i]*R[i]*CMF.z[i]),10);
  return {X,Y,Z};
}
function labFromXYZ(X,Y,Z){
  const xr = X/whiteD50.X, yr = Y/whiteD50.Y, zr = Z/whiteD50.Z;
  const f = t => t>0.008856? Math.cbrt(t): (7.787*t + 16/116);
  const fx=f(xr), fy=f(yr), fz=f(zr);
  const L = 116*fy - 16, a = 500*(fx-fy), b = 200*(fy-fz);
  return {L,a,b};
}
function labFromSpectrum(R){ const {X,Y,Z} = xyzFromSpectrum(R); return labFromXYZ(X,Y,Z); }
function deltaE00(l1,l2){
  const L1=l1.L, a1=l1.a, b1=l1.b, L2=l2.L, a2=l2.a, b2=l2.b;
  const kL=1,kC=1,kH=1;
  const C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2), Cbar=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(Cbar,7)/(Math.pow(Cbar,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2, C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2);
  const h1p=(Math.atan2(b1,a1p)*180/Math.PI+(Math.atan2(b1,a1p)<0?360:0));
  const h2p=(Math.atan2(b2,a2p)*180/Math.PI+(Math.atan2(b2,a2p)<0?360:0));
  const dLp=L2-L1, dCp=C2p-C1p;
  let dhp=0; if(C1p*C2p!==0){ dhp=h2p-h1p; if(dhp>180) dhp-=360; if(dhp<-180) dhp+=360; }
  const dHp=2*Math.sqrt(C1p*C2p)*Math.sin((dhp*Math.PI/180)/2);
  const Lbar=(L1+L2)/2, Cbarp=(C1p+C2p)/2;
  const hbarp=(C1p*C2p===0)?(h1p+h2p): (Math.abs(h1p-h2p)>180?(h1p+h2p+360)/2:(h1p+h2p)/2);
  const T=1-0.17*Math.cos((hbarp-30)*Math.PI/180)+0.24*Math.cos((2*hbarp)*Math.PI/180)+0.32*Math.cos((3*hbarp+6)*Math.PI/180)-0.20*Math.cos((4*hbarp-63)*Math.PI/180);
  const Sl=1+(0.015*Math.pow(Lbar-50,2))/Math.sqrt(20+Math.pow(Lbar-50,2)), Sc=1+0.045*Cbarp, Sh=1+0.015*Cbarp*T;
  const delTheta=30*Math.exp(-Math.pow((hbarp-275)/25,2)); const Rc=2*Math.sqrt(Math.pow(Cbarp,7)/(Math.pow(Cbarp,7)+Math.pow(25,7)));
  const Rt=-Rc*Math.sin(2*delTheta*Math.PI/180);
  return Math.sqrt(Math.pow(dLp/(kL*Sl),2)+Math.pow(dCp/(kC*Sc),2)+Math.pow(dHp/(kH*Sh),2)+Rt*(dCp/(kC*Sc))*(dHp/(kH*Sh)));
}
function hexFromLab(L,a,b){
  const fy=(L+16)/116, fx=a/500+fy, fz=fy-b/200;
  const xr=fx**3>0.008856?fx**3:(116*fx-16)/903.3;
  const yr=L>8?fy**3:L/903.3;
  const zr=fz**3>0.008856?fz**3:(116*fz-16)/903.3;
  let X=xr*whiteD50.X, Y=yr*whiteD50.Y, Z=zr*whiteD50.Z;
  const Ma=[[0.8951,0.2664,-0.1614],[-0.7502,1.7135,0.0367],[0.0389,-0.0685,1.0296]];
  const MaI=[[0.9869929,-0.1470543,0.1599627],[0.4323053,0.5183603,0.0492912],[-0.0085287,0.0400428,0.9684867]];
  const mul=(M,v)=>[M[0][0]*v[0]+M[0][1]*v[1]+M[0][2]*v[2],M[1][0]*v[0]+M[1][1]*v[1]+M[1][2]*v[2],M[2][0]*v[0]+M[2][1]*v[1]+M[2][2]*v[2]];
  const D50w=[whiteD50.X,whiteD50.Y,whiteD50.Z], D65w=[95.047,100,108.883];
  const cW=mul(Ma,D50w), cD=mul(Ma,D65w), c=mul(Ma,[X,Y,Z]);
  const S=[cD[0]/cW[0], cD[1]/cW[1], cD[2]/cW[2]], aXYZ=mul(MaI,[c[0]*S[0],c[1]*S[1],c[2]*S[2]]);
  X=aXYZ[0]; Y=aXYZ[1]; Z=aXYZ[2];
  let r= 3.2406*X/100 + -1.5372*Y/100 + -0.4986*Z/100;
  let g=-0.9689*X/100 +  1.8758*Y/100 +  0.0415*Z/100;
  let b2= 0.0557*X/100 + -0.2040*Y/100 +  1.0570*Z/100;
  const gamma=u=>u<=0.0031308?12.92*u:(1.055*Math.pow(u,1/2.4)-0.055);
  [r,g,b2]=[r,g,b2].map(u=>gamma(clamp(u,0,1)));
  const toHex=t=>(Math.round(t*255)).toString(16).padStart(2,'0');
  return `#${toHex(r)}${toHex(g)}${toHex(b2)}`;
}

/* ===========================
   KM Engine — Two-Constant
   Filmweight locked via t0 (6v)
=========================== */
function mixReflectance(colorantSet, fractions, t0, substrateR){
  const n = WL.length;
  const K = new Array(n).fill(0), S = new Array(n).fill(0);
  for(let i=0;i<colorantSet.length;i++){
    const f = fractions[i]*t0;
    if(f<=0) continue;
    const cst = colorantSet[i].consts;
    const k1=cst.k1, k2=cst.k2, s1=cst.s1, s2=cst.s2;
    for(let j=0;j<n;j++){
      K[j] += k1[j]*f + k2[j]*f*f;
      S[j] += s1[j]*f + s2[j]*f*f;
    }
  }
  for(let j=0;j<n;j++){ if(S[j]<=1e-12) S[j]=1e-12; }
  const R = new Array(n);
  for(let j=0;j<n;j++){
    const a = 1 + K[j]/S[j];
    const b = Math.sqrt(Math.max(a*a - 1, 1e-12));
    const r_inf = a - b;
    const tau = Math.exp(-2*b*S[j]); // thickness 1 here; t0 applied in f
    const Rg = substrateR[j];
    const denom = 1 - Rg*r_inf*tau;
    R[j] = denom===0 ? r_inf : (r_inf + (Rg - r_inf)*tau/denom);
    R[j] = clamp(R[j], 0.0001, 0.9999);
  }
  return R;
}

/* ===========================
   App State
=========================== */
const state = {
  pantones: [],
  formulas: new Map(),
  colorants: [],
  substrateR: new Array(WL.length).fill(0.9),
  t0: 1.0,
  blackNames: ['black','pp60 top black','k'],
  extenderNames: ['extender','transparent','clear','base','varnish'],
  assort: null
};

function indexOfBlack(){
  for (let i=0;i<state.colorants.length;i++){
    const nm = state.colorants[i].name.toLowerCase();
    for(const kw of state.blackNames){ if(nm.includes(kw)) return i; }
  }
  return -1;
}
function indexOfExtender(){
  for (let i=0;i<state.colorants.length;i++){
    const nm = state.colorants[i].name.toLowerCase();
    for(const kw of state.extenderNames){ if(nm.includes(kw)) return i; }
  }
  return -1;
}
function defaultInkSet(){ return state.colorants.slice(); }

/* ===========================
   Load JSON & Fit t0 (6v)
=========================== */
async function loadAll(){
  // colours.json
  const coloursRaw = await fetchJSON('colours.json');
  const colours = asArray(coloursRaw);
  state.pantones = colours.map(o=>{
    const L = numOr(o.L, o.l);
    const a = numOr(o.a, o.A);
    const b = numOr(o.b, o.B);
    return {
      name: (o.Name||o.name||o.Pantone||o.pantone||o.title||'').toString(),
      L, a, b,
      hex: o.Hex || o.hex || hexFromLab(L, a, b)
    };
  }).filter(x => Number.isFinite(x.L) && Number.isFinite(x.a) && Number.isFinite(x.b));

  // DC_Formulas.json — robust to array/object/wrapper
  const formRaw = await fetchJSON('DC_Formulas.json');
  const formArr = asArray(formRaw);
  // If still empty and it's a plain object map (Pantone -> record), turn into array:
  const maybeMapKeys = (!formArr.length && formRaw && typeof formRaw==='object') ? Object.keys(formRaw) : [];
  const records = formArr.length ? formArr : maybeMapKeys.map(k => ({ Pantone: k, ...(formRaw[k]||{}) }));

  for(const rec of records){
    const name = (rec.Pantone || rec.Pantone_Name || rec.Name || rec.name || '').toString().trim();
    if(!name) continue;
    const entries = [];

    // Try generic “InkX / PercentX”-style keys first
    for(let i=1;i<=8;i++){
      const inkKeyCandidates = [`Ink ${i}`, `Ink${i}`, `Colour ${i}`, `Color ${i}`, `Colorant ${i}`];
      let inkName = '';
      for(const key of inkKeyCandidates){ if(rec[key]!==undefined){ inkName = (rec[key]||'').toString().trim(); break; } }
      // percent/amount keys
      const pctKeys = [ (i===1?'%':'%'+i), (i===1?'1%':i+'%'), `Percent${i}`, `P${i}`, `Amount${i}` ];
      let pct = NaN;
      for(const pk of pctKeys){ if(rec[pk]!==undefined){ const v = Number(rec[pk]); if(Number.isFinite(v)){ pct = v; break; } } }
      if(inkName && Number.isFinite(pct)) entries.push({ink: inkName, percent: pct});
    }

    // Fallback: scan arbitrary keys for “Ink” and a matching % key nearby
    if(entries.length===0){
      const keys = Object.keys(rec);
      for(const k of keys){
        const m = k.match(/ink\s*([0-9]+)/i);
        if(m){
          const idx = m[1];
          const inkName = (rec[k]||'').toString().trim();
          const pct = Number(rec['%'+(idx==='1'?'':idx)] ?? rec[idx+'%'] ?? rec['Percent'+idx] ?? rec['P'+idx]);
          if(inkName && Number.isFinite(pct)) entries.push({ink: inkName, percent: pct});
        }
      }
    }

    if(entries.length) state.formulas.set(name, entries);
  }

  // DC21_jan25.json
  const dc21 = await fetchJSON('DC21_jan25.json');
  if(dc21 && dc21.substrate && dc21.substrate.reflectance){
    const r = [];
    for(const wl of WL){
      const val = (dc21.substrate.reflectance[wl] !== undefined) ? dc21.substrate.reflectance[wl]
                : dc21.substrate.reflectance[String(wl)];
      r.push( Number(val) || 0.9 );
    }
    state.substrateR = r;
  }
  const cArr = asArray(dc21 && dc21.colorants);
  if(cArr && cArr.length){
    state.colorants = cArr.map(c=>{
      const kc = c.km_constants || {};
      const arr = (a)=> WL.map((_,i)=> Number((a && a[i]) || 0));
      return {
        id: (c.id || c.code || c.name || '').toString(),
        name: (c.name || c.code || c.id || 'Ink').toString(),
        consts: { k1:arr(kc.k1), k2:arr(kc.k2), s1:arr(kc.s1), s2:arr(kc.s2) }
      };
    }).filter(c => c.consts.k1.some(v=>v!==0) && c.consts.s1.some(v=>v!==0));
  }

  // assortment_colour_data.json (optional)
  try{ const assortRaw = await fetchJSON('assortment_colour_data.json'); state.assort = assortRaw; }catch(e){ state.assort=null; }

  document.getElementById('pantoneCount').textContent = String(state.pantones.length) + ' total';

  // Fit thickness scalar t0 from ladders if present
  const tFit = fitThicknessFromLadders();
  state.t0 = Number.isFinite(tFit) ? tFit : 1.0;
  const hint = document.getElementById('calibHint');
  if(hint) hint.textContent = 'Calibrated for 6v: thickness scalar t₀ = ' + state.t0.toFixed(3) + ' (auto-fit)';
}

function fitThicknessFromLadders(){
  if(!state.assort || state.colorants.length===0) return NaN;

  const idxByName = {};
  for(const c of state.colorants){ idxByName[c.name.toLowerCase()] = c; }

  const samples = [];
  (function scan(obj){
    if(!obj) return;
    if(Array.isArray(obj)){ for(const v of obj) scan(v); return; }
    if(typeof obj==='object'){
      const keys = Object.keys(obj);
      const hasConc = keys.some(k=>/concentration|percent|strength|load/i.test(k));
      const L = numOr(obj.L, obj.l), A = numOr(obj.A, obj.a), B = numOr(obj.B, obj.b);
      const hasLab = Number.isFinite(L)&&Number.isFinite(A)&&Number.isFinite(B);
      if(hasConc && hasLab){
        const name = (obj.name || obj.colorant || obj.Colorant || obj.ink || '').toString().trim().toLowerCase();
        const cobj = idxByName[name];
        if(cobj){
          let conc = obj.concentration; if(!Number.isFinite(Number(conc))) conc = obj.percent || obj.strength || obj.load;
          conc = Number(conc);
          if(Number.isFinite(conc)){
            if(conc>1.0001) conc = conc/100;
            conc = clamp(conc, 0, 1);
            samples.push({cobj, conc, lab:{L, a:A, b:B}});
          }
        }
      }
      for(const v of Object.values(obj)) scan(v);
    }
  })(state.assort);

  if(samples.length < 12) return NaN;

  const extIdx = indexOfExtender();

  function rmsDE(t0){
    let se=0, n=0;
    for(const s of samples){
      const inks = extIdx>=0 ? [s.cobj, state.colorants[extIdx]] : [s.cobj];
      const fr = extIdx>=0 ? [s.conc, 1 - s.conc] : [s.conc];
      const R = mixReflectance(inks, fr, t0, state.substrateR);
      const lab = labFromSpectrum(R);
      const dE = deltaE00(lab, s.lab);
      se += dE*dE; n++;
    }
    return Math.sqrt(se/Math.max(1,n));
  }

  let bestT = 1.0, bestE = Infinity;
  for(let t=0.6; t<=1.6; t += 0.02){
    const tt = Number(t.toFixed(2));
    const e = rmsDE(tt);
    if(e < bestE){ bestE = e; bestT = tt; }
  }
  return bestT;
}

/* ===========================
   Nearest Pantone + Existing Formula
=========================== */
function findNearestPantones(L,a,b, k){
  const target = {L:Number(L), a:Number(a), b:Number(b)};
  const scored = state.pantones.map(p=>{
    const dE = deltaE00(target, {L:p.L,a:p.a,b:p.b});
    return {name:p.name, L:p.L, a:p.a, b:p.b, hex:p.hex, dE:dE};
  }).sort((x,y)=>x.dE - y.dE);
  return scored.slice(0,k);
}

function showExistingFormula(name){
  const wrap = document.getElementById('existingFormula');
  const rec = state.formulas.get(name);
  if(!rec){ wrap.innerHTML = '<span class="muted">No stored formula for <b>'+name+'</b>.</span>'; return; }
  const rows = rec.map(r=>(
    '<tr><td class="mono">'+r.ink+'</td><td class="mono" style="text-align:right">'+round2(r.percent)+'%</td></tr>'
  )).join('');
  wrap.innerHTML = '<div class="flex-between"><div class="sectionTitle" style="margin:0 0 6px 0">'+name+
    '</div><div class="pill small">Total: '+round2(rec.reduce((s,x)=>s+x.percent,0))+'%</div></div>'+
    '<table class="table">'+rows+'</table>';
}

/* ===========================
   Predictor (Constraints + Optimiser)
=========================== */
function predictMixForLab(targetLab, options){
  const maxInks = Number(options.maxInks)||4;
  const maxBlackPct = Number(options.maxBlackPct)||10;
  const preferExt = options.preferExt || 'auto';
  const seedPantone = options.seedPantone || null;

  const inks = defaultInkSet();
  if(inks.length===0) throw new Error('No colorants loaded');
  const n = inks.length;

  let fractions = new Array(n).fill(0);

  // Seed
  if(seedPantone && state.formulas.has(seedPantone)){
    const rec = state.formulas.get(seedPantone); let sum=0;
    for(const r of rec){
      const idx = inks.findIndex(c=> c.name.toLowerCase() === r.ink.toLowerCase());
      if(idx>=0){ fractions[idx] = Math.max(0, r.percent/100); sum += r.percent/100; }
    }
    if(sum>0){ for(let i=0;i<n;i++) fractions[i]/=sum; }
  } else {
    const ext = indexOfExtender(); if(ext>=0 && preferExt!=='never') fractions[ext]=0.3;
    function score(i){
      const test = fractions.slice(); test[i] += 0.35;
      let s = 0; for(const v of test) s+=v; if(s>1){ for(let j=0;j<n;j++) test[j]/=s; }
      const R = mixReflectance(inks, test, state.t0, state.substrateR);
      const lab = labFromSpectrum(R);
      return -deltaE00(targetLab, lab);
    }
    const picks = inks.map((_,i)=>({i,s:score(i)})).sort((a,b)=>b.s-a.s).slice(0,3).map(x=>x.i);
    const extIdx = indexOfExtender();
    let chromaSlots = picks.length - (picks.includes(extIdx)?1:0);
    for(const i of picks){
      if(i===extIdx) continue;
      fractions[i] += (chromaSlots>0? (0.7/chromaSlots) : 0.7);
    }
    let s=0; for(const v of fractions) s+=v; if(s>0){ for(let j=0;j<n;j++) fractions[j]/=s; }
  }

  const blackIdx = indexOfBlack(), extIdx = indexOfExtender(), kMaxBlack = maxBlackPct/100;

  function project(vec){
    for(let i=0;i<n;i++) vec[i] = Math.max(0, vec[i]);
    if(blackIdx>=0) vec[blackIdx] = Math.min(vec[blackIdx], kMaxBlack);
    if(extIdx>=0){
      if(preferExt==='never') vec[extIdx]=0;
      if(preferExt==='always') vec[extIdx]=Math.max(vec[extIdx], 0.1);
    }
    const ranked = []; for(let i=0;i<n;i++) ranked.push({i,v:vec[i]});
    ranked.sort((a,b)=>b.v-a.v);
    const keep = new Set(ranked.slice(0,maxInks).map(x=>x.i));
    for(let i=0;i<n;i++) if(!keep.has(i)) vec[i]=0;
    let sum = 0; for(const v of vec) sum+=v;
    if(sum<=0){ if(extIdx>=0) vec[extIdx]=1; else vec[0]=1; sum=1; }
    for(let i=0;i<n;i++) vec[i]/=sum;
    return vec;
  }

  function objective(vec){
    const R = mixReflectance(inks, vec, state.t0, state.substrateR);
    const lab = labFromSpectrum(R);
    const dE = deltaE00(targetLab, lab);
    const pen = 0.002 * vec.reduce((s,x)=> s + Math.abs(x), 0);
    return {val:dE+pen, dE, lab};
  }

  let x = project(fractions.slice()); let best = objective(x), bestX = x.slice();
  let step = 0.28;
  for(let it=0; it<150; it++){
    const eps=1e-3, g=new Array(n).fill(0);
    const f0=objective(x).val;
    for(let i=0;i<n;i++){
      const x1=x.slice(); x1[i]+=eps; project(x1);
      const f1=objective(x1).val; g[i]=(f1-f0)/eps;
    }
    let xCand=x.map((xi,i)=> xi - step*g[i]); xCand=project(xCand);
    const fCand=objective(xCand);
    if(fCand.val <= best.val){ x=xCand; best=fCand; bestX=xCand.slice(); step*=1.05; }
    else step*=0.5;
  }

  const comp = bestX.map((v,i)=>({name: inks[i].name, idx:i, pct: v*100}))
                    .filter(c=>c.pct>0.05).sort((a,b)=>b.pct-a.pct);
  return {components: comp, predictedLab: best.lab, dE: best.dE};
}

/* ===========================
   UI
=========================== */
function el(id){ return document.getElementById(id); }

function renderNearest(list){
  const wrap=el('nearestList'); wrap.innerHTML='';
  for(const p of list){
    const row=document.createElement('a'); row.className='swatchRow linkish';
    row.innerHTML = '<div class="chip" style="background:'+p.hex+'"></div>'+
      '<div><div><b>'+p.name+'</b></div>'+
      '<div class="muted small">ΔE00 '+round2(p.dE)+' · L*a*b* '+round2(p.L)+', '+round2(p.a)+', '+round2(p.b)+'</div></div>'+
      '<div><span class="tag">Select</span></div>';
    row.addEventListener('click', ()=>{
      el('L').value = p.L.toFixed(2);
      el('a').value = p.a.toFixed(2);
      el('b').value = p.b.toFixed(2);
      showExistingFormula(p.name);
      el('predictBtn').dataset.seed = p.name;
    });
    wrap.appendChild(row);
  }
}

function renderPrediction(result){
  const out=el('predictionOutput'), table=el('mixTable'), labPill=el('predLab'), dEPill=el('predDe'), warn=el('predWarn');
  const rows = result.components.map(c=>'<tr><td class="mono">'+c.name+'</td><td class="mono" style="text-align:right">'+round2(c.pct)+'%</td></tr>').join('');
  table.innerHTML = rows || '<tr><td colspan="2" class="muted">No components found.</td></tr>';
  labPill.textContent = 'L*a*b*: '+round2(result.predictedLab.L)+', '+round2(result.predictedLab.a)+', '+round2(result.predictedLab.b);
  dEPill.textContent = 'ΔE00: ' + round2(result.dE);
  dEPill.className = 'pill ' + (result.dE<=1.5 ? 'good' : (result.dE<=3 ? 'warn' : 'bad'));
  warn.textContent = (result.components.length>4? 'Many components may be impractical; reduce Max ingredients.' : '');
  out.style.display='block';
}

/* ===========================
   Bootstrap
=========================== */
window.addEventListener('DOMContentLoaded', async ()=>{
  const status=el('predictStatus');
  const maxInks=el('maxInks'), maxInksVal=el('maxInksVal');
  maxInks.addEventListener('input', ()=> maxInksVal.textContent = String(maxInks.value));
  const maxBlack=el('maxBlack'), maxBlackVal=el('maxBlackVal');
  maxBlack.addEventListener('input', ()=> maxBlackVal.textContent = String(maxBlack.value)+'%');

  try{
    await loadAll();
  }catch(e){
    console.error(e);
    alert('Failed to load one or more JSON files. See console for details.\n'+e.message);
  }

  el('pantoneSearch').addEventListener('input', (e)=>{
    const q=(e.target.value||'').toLowerCase().trim(); if(!q) return;
    const hit = state.pantones.find(p=>(p.name||'').toLowerCase().includes(q));
    if(hit){ el('L').value=hit.L.toFixed(2); el('a').value=hit.a.toFixed(2); el('b').value=hit.b.toFixed(2); }
  });

  el('matchBtn').addEventListener('click', ()=>{
    const L = Number(el('L').value), a = Number(el('a').value), b = Number(el('b').value);
    const nearest = findNearestPantones(L,a,b,8);
    renderNearest(nearest);
  });

  el('predictBtn').addEventListener('click', ()=>{
    const L = Number(el('L').value), a = Number(el('a').value), b = Number(el('b').value);
    const seed = el('predictBtn').dataset.seed || null;
    const opts = { maxInks: Number(el('maxInks').value), maxBlackPct: Number(el('maxBlack').value), preferExt: el('preferExt').value, seedPantone: seed };
    el('predictStatus').textContent = 'Optimising…';
    setTimeout(()=>{ try{
      const result = predictMixForLab({L,a,b}, opts);
      renderPrediction(result);
      el('predictStatus').textContent = '';
    }catch(err){ el('predictStatus').textContent = 'Error: ' + (err && err.message ? err.message : String(err)); } }, 10);
  });
});
</script>
</body>
</html>
